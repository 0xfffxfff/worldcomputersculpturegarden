{
  "language": "Solidity",
  "sources": {
    "@ensdomains/ens-contracts/contracts/registry/ENS.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface ENS {\n    // Logged when the owner of a node assigns a new owner to a subnode.\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\n\n    // Logged when the owner of a node transfers ownership to a new account.\n    event Transfer(bytes32 indexed node, address owner);\n\n    // Logged when the resolver for a node changes.\n    event NewResolver(bytes32 indexed node, address resolver);\n\n    // Logged when the TTL of a node changes\n    event NewTTL(bytes32 indexed node, uint64 ttl);\n\n    // Logged when an operator is added or removed.\n    event ApprovalForAll(\n        address indexed owner,\n        address indexed operator,\n        bool approved\n    );\n\n    function setRecord(\n        bytes32 node,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeRecord(\n        bytes32 node,\n        bytes32 label,\n        address owner,\n        address resolver,\n        uint64 ttl\n    ) external;\n\n    function setSubnodeOwner(\n        bytes32 node,\n        bytes32 label,\n        address owner\n    ) external returns (bytes32);\n\n    function setResolver(bytes32 node, address resolver) external;\n\n    function setOwner(bytes32 node, address owner) external;\n\n    function setTTL(bytes32 node, uint64 ttl) external;\n\n    function setApprovalForAll(address operator, bool approved) external;\n\n    function owner(bytes32 node) external view returns (address);\n\n    function resolver(bytes32 node) external view returns (address);\n\n    function ttl(bytes32 node) external view returns (uint64);\n\n    function recordExists(bytes32 node) external view returns (bool);\n\n    function isApprovedForAll(\n        address owner,\n        address operator\n    ) external view returns (bool);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4;\n\ninterface INameResolver {\n    event NameChanged(bytes32 indexed node, string name);\n\n    /**\n     * Returns the name associated with an ENS node, for reverse records.\n     * Defined in EIP181.\n     * @param node The ENS node to query.\n     * @return The associated name.\n     */\n    function name(bytes32 node) external view returns (string memory);\n}\n"
    },
    "@ensdomains/ens-contracts/contracts/reverseRegistrar/IReverseRegistrar.sol": {
      "content": "pragma solidity >=0.8.4;\n\ninterface IReverseRegistrar {\n    function setDefaultResolver(address resolver) external;\n\n    function claim(address owner) external returns (bytes32);\n\n    function claimForAddr(\n        address addr,\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function claimWithResolver(\n        address owner,\n        address resolver\n    ) external returns (bytes32);\n\n    function setName(string memory name) external returns (bytes32);\n\n    function setNameForAddr(\n        address addr,\n        address owner,\n        address resolver,\n        string memory name\n    ) external returns (bytes32);\n\n    function node(address addr) external pure returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "contracts/ENSResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Author: @yigitduman\n// Source: https://github.com/ygtdmn/drakeflipping/blob/main/src/DrakeflippingRenderer.sol\npragma solidity >=0.8.0;\n\nimport \"solady/src/utils/LibString.sol\";\nimport { ENS } from \"@ensdomains/ens-contracts/contracts/registry/ENS.sol\";\nimport { IReverseRegistrar } from \"@ensdomains/ens-contracts/contracts/reverseRegistrar/IReverseRegistrar.sol\";\nimport { INameResolver } from \"@ensdomains/ens-contracts/contracts/resolvers/profiles/INameResolver.sol\";\n\nlibrary ENSResolver {\n    /**\n     * @notice Retrieves the ENS name or checksummed address for a given address.\n     * @param addr The address to retrieve the ENS name or checksummed address for.\n     * @return The ENS name if available, otherwise the checksummed address.\n     */\n    function resolveAddress(address addr) external view returns (string memory) {\n        ENS ens = ENS(0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e);\n        IReverseRegistrar reverseRegistrar = IReverseRegistrar(/*sepolia*/0xA0a1AbcDAe1a2a4A2EF8e9113Ff0e02DD81DC0C6);\n        bytes32 node = reverseRegistrar.node(addr);\n        address resolverAddress = ens.resolver(node);\n\n        if (resolverAddress != address(0)) {\n            // If the resolver is not the zero address, try to get the name from the resolver\n            try INameResolver(resolverAddress).name(node) returns (string memory name) {\n                // If a name is found and it's not empty, return it\n                if (bytes(name).length > 0) {\n                    return name;\n                }\n            } catch {}\n        }\n\n        // If no valid name is found, return the address as a string\n        return LibString.toHexStringChecksummed(addr);\n    }\n}"
    },
    "contracts/Essay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"solady/src/utils/SSTORE2.sol\";\nimport \"./Sculpture.sol\";\n\ncontract Essay is Sculpture, Ownable {\n\n    address private pointer1;\n    address private pointer2;\n    string private t;\n    string private a = \"maltefr\";\n    string[] private u;\n\n    constructor () Ownable(msg.sender) {}\n\n    function title() external view returns (string memory) {\n        return t;\n    }\n\n    function authors() public view returns (string[] memory authors_) {\n        authors_ = new string[](1);\n        authors_[0] = a;\n        return authors_;\n    }\n\n    function addresses() external view returns (address[] memory) {\n        address[] memory _addresses = new address[](1);\n        _addresses[0] = address(this);\n        return _addresses;\n    }\n\n    function urls() external view returns (string[] memory) {\n        return u;\n    }\n\n    function text() external view returns (string memory) {\n        if (pointer1 == address(0)) {\n            return \"\";\n        }\n        return string.concat(\n            string(SSTORE2.read(pointer1)),\n            pointer2 == address(0) ? \"\" : string(SSTORE2.read(pointer2))\n        );\n    }\n\n    function setTitle(string memory _title) external onlyOwner {\n        t = _title;\n    }\n\n    function setAuthor(string memory _author) external onlyOwner {\n        a = _author;\n    }\n\n    function setUrls(string[] memory _urls) external onlyOwner {\n        u = _urls;\n    }\n\n    function setTextPt1(string memory _text) external onlyOwner {\n        pointer1 = SSTORE2.write(bytes(_text));\n    }\n\n    function setTextPt2(string memory _text) external onlyOwner {\n        pointer2 = SSTORE2.write(bytes(_text));\n    }\n\n    function html() external view returns (string memory html) {\n        html = string.concat(\n            \"<h1>\", t, \"</h1>\",\n            \"<br><br><br>\",\n            \"<h2><i>Written by \", authors()[0], \"</i></h2>\",\n            \"<br><br>\",\n            \"<div>\",\n                pointer1 == address(0)\n                    ? \"\"\n                    : string.concat(\n                        string(SSTORE2.read(pointer1)),\n                        pointer2 == address(0) ? \"\" : string(SSTORE2.read(pointer2))\n                    ),\n            \"</div>\");\n    }\n}"
    },
    "contracts/GardenContributions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"solady/src/utils/LibString.sol\";\nimport \"./IGarden.sol\";\nimport \"./Sculpture.sol\";\n\nlibrary GardenContributions {\n    function html(address garden) external view returns (string memory html) {\n        uint256 guests = IGarden(garden).guests();\n        uint256 flowers = IGarden(garden).flowers();\n        html = string.concat(html,\n            '<div class=\"w\"><div class=\"s\">',\n                '<div id=\"field1\" class=\"field\"></div>'\n                '<br><br><br>',\n                '<p style=\"text-align:center;\">',\n                'Guestbook',\n                '<br><br>',\n                'You may leave a flower here by sending 0.01 ETH (or multiples thereof)<br> to the show contract at <span class=\"a\">',\n                    LibString.toHexStringChecksummed(garden),\n                '</span><br><br>',\n                LibString.toString(guests),\n                guests == 1 ? ' guest has' : ' guests have',\n                ' planted ', LibString.toString(flowers),\n                ' flower' , flowers == 1 ? '' : 's',\n                '</p><br><br><br>',\n                '<div id=\"field2\" class=\"field\"></div>',\n                '<style>'\n                    '.tooltip { font-size: 0.8em; background: white; border: 1px solid black; padding: 0.5em; width: 220px; }',\n                    '.tooltip.r { text-align: right; }',\n                    '.tooltip .address { overflow-wrap: break-word; }',\n                '</style>',\n                '<script>',\n                    'document.addEventListener(\"DOMContentLoaded\", () => {',\n                    'const flowers = ', LibString.toString(IGarden(garden).flowers()), ';',\n                    unicode'console.log(`Welcome to the ', Sculpture(garden).title(), '`);',\n                    unicode'console.log(` ⚘                    ⚘                  ⚘\\n',\n                    unicode'             ⚘                       ⚘\\n',\n                    unicode'    ⚘\\n',\n                    unicode'                      ⚘                     ⚘\\n\\n',\n                    unicode'    Initializing garden with ${flowers} flowers\\n\\n',\n                    unicode'             ⚘                         ⚘\\n',\n                    unicode'⚘                        ⚘                   ⚘\\n',\n                    unicode'    ⚘                                ⚘\\n',\n                    unicode'                      ⚘`);',\n                    'function calculateThreshold(planted) {',\n                        'const min = 30, max = 10000, lower = 0.99, higher = 0.8;',\n                        'if (planted <= min) return lower;',\n                        'if (planted >= max) return higher;',\n                        'const normalized = (planted - min) / (max - min);',\n                        'const logValue = Math.log10(1 + normalized * (10 - 1));',\n                        'return higher + (lower - higher) * (1 - logValue);',\n                    '}',\n                    'function isConditionMet(planted, val) {',\n                        'const threshold = calculateThreshold(planted);',\n                        'return val > threshold || val < -threshold;',\n                    '}',\n                    'function gridNoise(x, z, seed) {',\n                        'var n = (1619 * x + 31337 * z + 1013 * seed) & 0x7fffffff;',\n                        'n = BigInt((n >> 13) ^ n);',\n                        'n = n * (n * n * 60493n + 19990303n) + 1376312589n;',\n                        'n = parseInt(n.toString(2).slice(-31), 2);',\n                        'return 1 - n / 1073741824;',\n                    '}',\n                    'const width = 90;',\n                    'let lines = [\"\"], counter = 0, planted = 0;',\n                    'while (planted < flowers) {',\n                        'const val = gridNoise(counter % width, Math.floor(counter / width), 0xf);',\n                        'const threshold = calculateThreshold(planted);',\n                        'if (val > threshold || val < -threshold) {',\n                            unicode'lines[Math.floor(counter / width)] += `<a href=\"#${planted+1}\" id=\"flower-${planted+1}\" style=\"position:relative;\" data-flower-id=\"${planted+1}\">⚘</a>`;',\n                            'planted++;',\n                        '} else { lines[Math.floor(counter / width)] += \" \"; }',\n                        'if (counter % width == (width-1) && planted < flowers) { lines.push(\"\"); }',\n                        'counter++;'\n                    '}',\n                    'lines = lines.reduce((acc, line) => { if (line.trim().length > 0) acc.push(line); return acc; }, []);',\n                    'document.querySelector(\"#field1\").innerHTML = lines.slice(0,Math.min(7,Math.ceil(lines.length/2))).join(\"\\\\n\");',\n                    'document.querySelector(\"#field2\").innerHTML = lines.slice(Math.min(7,Math.ceil(lines.length/2))).join(\"\\\\n\");',\n                    'const flowerEls = document.querySelectorAll(\".field a\");',\n                    'flowerEls.forEach((el) => {',\n                        'el.addEventListener(\"mouseenter\", (e) => {',\n                        'const flowerId = e.target.dataset.flowerId;',\n                        'if (flowerId) {',\n                            'e.preventDefault();'\n                            'showTooltip(flowerId);',\n                        '}',\n                    '});',\n                    'el.addEventListener(\"mouseleave\", (e) => {',\n                    '    document.querySelectorAll(\".tooltip\").forEach((el) => el.remove());',\n                    '});',\n                    '});'\n                    'window.addEventListener(\"resize\", () => document.querySelectorAll(\".tooltip\").forEach((el) => el.remove()));',\n                    'document.querySelectorAll(\".field\").forEach((el) => el.addEventListener(\"scroll\", () => document.querySelectorAll(\".tooltip\").forEach((el) => el.remove())));',\n                    'function showTooltip(flowerId) {',\n                        'document.querySelectorAll(\".tooltip\").forEach((el) => el.remove());',\n                        'const tooltip = document.createElement(\"div\");',\n                        'tooltip.classList.add(\"tooltip\");',\n                        'tooltip.id = \"tooltip\" + flowerId;',\n                        'tooltip.innerHTML = `Loading Flower #${flowerId} ...`;',\n                        'tooltip.style.position = \"absolute\";',\n                        'const flower = document.getElementById(\"flower-\" + flowerId);',\n                        'const clientRect = flower.getBoundingClientRect();',\n                        'const offsetTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;',\n                        'tooltip.style.top = clientRect.top + (offsetTop) + flower.clientHeight + \"px\";',\n                        'const offsetLeft = window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0;',\n                        'const leftPos = clientRect.left + offsetLeft;',\n                        'tooltip.style.left = leftPos > window.innerWidth - 250 ? leftPos - 220 + \"px\" : leftPos + \"px\";',\n                        'if (leftPos > window.innerWidth - 250) tooltip.classList.add(\"r\");',\n                        'document.body.appendChild(tooltip);',\n                        'loadFlower(flowerId);',\n                    '}',\n                    'const fetchFlowerMemo = (() => {',\n                    '    const cache = {};',\n                    '    return async function(flowerId) {',\n                    '        if (cache[flowerId]) return { ...cache[flowerId] };',\n                    '        const res = await fetch(\"/flower/\" + flowerId);',\n                    '        const data = await res.json();',\n                    '        cache[flowerId] = { ...data };',\n                    '        return data;',\n                    '    }',\n                    '})();',\n                    'async function loadFlower(flowerId) {',\n                    '    try {',\n                    '        const data = await fetchFlowerMemo(flowerId);',\n                    '        console.log(`Loaded Flower #${flowerId}`, data);',\n                    '        const tooltip = document.getElementById(\"tooltip\" + flowerId);',\n                    '        if (!tooltip) return;',\n                    unicode'        tooltip.innerHTML = `Flower #${flowerId}<br> <span class=\"address\">${data.planter}</span><br> ${formatTime(data.timestamp)}`;',\n                    '    } catch (e) {',\n                    '         console.error(\"Error loading flower\", e);',\n                    '    }',\n                    '}',\n                    'function formatTime(t) {',\n                    '    const date = new Date(t * 1000);',\n                    '    const options = { month: \"long\" };',\n                    '    const month = new Intl.DateTimeFormat(\"en-US\", options).format(date);',\n                    '    const day = date.getDate();',\n                    '    const year = date.getFullYear();',\n                    '    let hours = date.getHours();',\n                    '    const minutes = date.getMinutes().toString().padStart(2, \"0\");',\n                    '    const amPm = hours >= 12 ? \"pm\" : \"am\";',\n                    '    hours = hours % 12 || 12;',\n                    '    return `${month} ${day}, ${year}, ${hours}:${minutes}${amPm}`;',\n                    '}',\n                    '});',\n                '</script>',\n            '</div></div>'\n        );\n    }\n}"
    },
    "contracts/GardenEssay.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"solady/src/utils/LibString.sol\";\nimport \"./GardenHTML.sol\";\nimport \"./IGarden.sol\";\nimport \"./Essay.sol\";\nimport \"./Sculpture.sol\";\n\nlibrary GardenEssay {\n    function html(address garden, address essayContract) public view returns (string memory html) {\n        html = string.concat(html,\n            '<div class=\"c essay\"><div class=\"w\"><div class=\"s g\">',\n                '<p><i>This text was published as part of the contract show: <a href=\"/\" style=\"display: block\">', Sculpture(garden).title() ,'</a></i></p>',\n                '<br><br><br>',\n                unicode'⚘',\n                '<br><br><br><br>',\n                '<article>',\n                Essay(essayContract).html(),\n                '</article>',\n                '<br><br><br><br>',\n                unicode'⚘',\n                '<br><br><br>',\n                '<p>', LibString.toHexStringChecksummed(garden),' </p>',\n                '<br><br>',\n                '<p><i>This text was published as part of the show <a href=\"/\" style=\"display: block\">', Sculpture(garden).title() ,'</a></i></p>',\n                '<br>',\n            '</div></div></div>',\n            unicode'<div class=\"f\"><a href=\"/\" style=\"text-decoration: none;\">⚘</a></div>'\n        );\n\n        string memory description = string.concat(\n            'The essay \"', Essay(essayContract).title(),\n            '\" written by ', Essay(essayContract).authors()[0] ,\n            ' was published as part of the contract show: ', Sculpture(garden).title());\n\n        return GardenHTML.html(html, Sculpture(garden).title(), description);\n    }\n}"
    },
    "contracts/GardenHTML.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nlibrary GardenHTML {\n    function html(string memory body, string memory title, string memory description) external pure returns (string memory) {\n        string memory html_ = '<!DOCTYPE html><html lang=\"en\">';\n        html_ = string.concat(html_,\n            '<head><meta charset=\"UTF-8\"><meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">',\n            '<link rel=\"icon\" type=\"image/svg+xml\" href=\"data:image/svg+xml,%3Csvg%20xmlns=', unicode\"'http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Cstyle%3E%20text%20%7B%20fill:%20%23000;%20%7D%20@media%20(prefers-color-scheme:%20dark)%20%7B%20text%20%7B%20fill:%20%23fff;%20%7D%20%7D%20%3C/style%3E%3Ctext%20y='.9em'%20font-size='90'%3E%20⚘%20%3C/text%3E%3C/svg%3E%0A\",'\">',\n            '<title>', title ,'</title>',\n            \"<meta name='description' content='\", description, \"'>\",\n            '<style>',\n            '*, *::before, *::after { box-sizing: border-box; }',\n            'html { -moz-text-size-adjust: none; -webkit-text-size-adjust: none; text-size-adjust: none; } html, body { margin: 0; padding: 0; } body { min-height: 100vh } html,body,pre { font-family: \"Courier New\", \"Courier\", monospace; font-size: 15px; line-height: 1.3; }',\n            'h1,h2,h3 { margin: 0; font-size: inherit; font-style: inherit; font-weight: inherit;}',\n            '.c { max-width: 860px; margin: 0 auto; padding: 0 20px; box-sizing: border-box; }',\n            '.c.essay { max-width: 620px; }',\n            'a { color: inherit; text-decoration: underline; }',\n            '.w { position: relative; min-height: 100vh; display: flex; align-items: center; padding: 10em 0; }',\n            '.s { width: 100%; max-width: 860px; }',\n            '.s:not(.g) a { max-width: 100%; display: inline-block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }',\n            '.t { max-width: 100%; overflow-x: auto; margin: 1em 0; }',\n            '.i { margin: 0 0 5em; }',\n            '.f { position: fixed; bottom: 1em; right: 1.3em; }',\n            '.p { position: absolute; bottom: 2rem; left: 50%; transform: translateX(-50%); font-size: 1.4em; }',\n            '.field { white-space: pre; margin: 0 auto; max-width: 100%; overflow-x: auto; }',\n            '.field a { text-decoration: none; }',\n            '.a { overflow: hidden; display: inline-block; max-width: 100%; text-overflow: ellipsis; vertical-align: middle; ',\n            '</style>',\n            '</head>'\n        );\n        html_ = string.concat(html_, '<body>', body, '</body></html>');\n        return html_;\n    }\n}"
    },
    "contracts/GardenIndex.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"solady/src/utils/LibString.sol\";\nimport \"./GardenHTML.sol\";\nimport \"./GardenContributions.sol\";\nimport \"./lib/Format.sol\";\nimport \"./Essay.sol\";\nimport \"./IGarden.sol\";\nimport \"./Sculpture.sol\";\nimport \"./Mod.sol\";\n\nlibrary GardenIndex {\n    function html(address garden, address essayContract, address data) public view returns (string memory html) {\n        address[] memory sculptures = IGarden(garden).getSculptures();\n\n        // Header\n        html = string.concat(html,\n            '<div class=\"c\">',\n            '<div class=\"w\">',\n            '<div class=\"s g\">',\n            '<pre class=\"garden\">',\n            unicode\"       ⚘                    ⚘\\n\",\n            unicode\"             ⚘\\n\",\n            unicode\"⚘                       ⚘         ⚘\\n\",\n            unicode\"        ⚘         ⚘\\n\",\n            unicode\"   ⚘                          ⚘\\n\",\n            unicode\"</pre>\",\n            '<br><br>',\n            unicode\"<h1>\", Sculpture(garden).title(), \"</h1>\\n\",\n            '<br><br>'\n        );\n\n        // Artist names\n        for (uint256 i = 0; i < sculptures.length; i++) {\n            try Sculpture(sculptures[i]).authors() returns (string[] memory authors) {\n                for (uint256 j = 0; j < authors.length; j++) {\n                    if (bytes(authors[j]).length == 0) continue; // ignore empty\n                    html = string.concat(html, authors[j], \"<br>\");\n                }\n            } catch {\n                html = string.concat(html, \"Unkown<br>\");\n            }\n        }\n\n        // Header End\n        html = string.concat(html,\n            '<br><br>',\n            '<h2 class=\"a\">', LibString.toHexStringChecksummed(garden), '</h2><br><br>',\n            '<pre class=\"garden\">',\n            unicode'      ⚘                      ⚘\\n',\n            unicode'              ⚘\\n',\n            unicode' ⚘                     ⚘         ⚘\\n',\n            unicode'          ⚘      ⚘\\n',\n            unicode'     ⚘                     ⚘\\n',\n            unicode'</pre><br>',\n            '<p>',\n            'A contract show curated by ',\n            '<a href=\"', Mod(data).fffUrl() ,'\" target=\"_blank\" rel=\"noopener noreferrer\">', Mod(data).fff(), '</a><br>',\n            'with special thanks to ',\n            '<a href=\"', Mod(data).lukeUrl(), '\" target=\"_blank\" rel=\"noopener noreferrer\">', Mod(data).luke() ,'</a> and ',\n            '<a href=\"', Mod(data).oneOneThreeUrl(), '\" rel=\"noopener noreferrer\" target=\"_blank\">', Mod(data).oneOneThree(),'</a>',\n            '<br><br>',\n            '<a href=\"/essay\">', Sculpture(essayContract).title() ,'</a> by <a href=\"', Mod(data).malteUrl(), '\" target=\"_blank\" rel=\"noopener noreferrer\">', Mod(data).malte() ,'</a>',\n            '</p><br><br>'\n        );\n\n        // Scroll Indicator\n        html = string.concat(\n            html,\n            '<br></div>',\n            unicode'<div class=\"p\">↓</div></div>'\n        );\n\n        // Text\n        html = string.concat(html,\n            '<div class=\"w\"><div class=\"s\">',\n            Sculpture(garden).text(),\n            '<br>',\n            '<p>The website you are viewing was generated from the show contract itself at block ', LibString.toString(block.number) ,'. ',\n            'Over time, as people engage with the artworks and artists activate their pieces, the information rendered here will change. Block by block. Year by year.</p>',\n            '</div></div>'\n        );\n\n        // Sculptures\n        for (uint256 i = 0; i < sculptures.length; i++) {\n            Sculpture sculpture = Sculpture(sculptures[i]);\n\n            html = string.concat(html, '<div class=\"w\"><div class=\"s\">');\n\n            // Authors\n            try sculpture.authors() returns (string[] memory authors) {\n                if (authors.length > 0) {\n                    html = string.concat(html, '<h2>');\n                    for (uint256 j = 0; j < authors.length; j++) {\n                        if (bytes(authors[j]).length == 0) continue; // ignore empty\n                        html = string.concat(html, authors[j], '<br>');\n                    }\n                    html = string.concat(html, '</h2>');\n                }\n            } catch {\n                html = string.concat(html, '<h2><i>Unkown</i></h2>');\n            }\n\n            // Title\n            try sculpture.title() returns (string memory title) {\n                if (bytes(title).length > 0) {\n                    html = string.concat(html, '<h3><i>', title, '</i></h3>');\n                } else {\n                    html = string.concat(html, '<h3><i>Untitled</i></h3>');\n                }\n            } catch {\n                html = string.concat(html, '<h3><i>Untitled</i></h3>');\n            }\n\n            // Addresses\n            try sculpture.addresses() returns (address[] memory addresses) {\n                if (addresses.length > 0) {\n                    html = string.concat(html, '<p>');\n                    for (uint256 j = 0; j < addresses.length; j++) {\n                        html = string.concat(html, '<span class=\"a\">', LibString.toHexStringChecksummed(addresses[j]), '</span><br>');\n                    }\n                    html = string.concat(html, '</p>');\n                }\n            } catch {\n                html = string.concat(html, '<p><span class=\"a\">', LibString.toHexStringChecksummed(sculptures[i]) , '</span></p>');\n            }\n\n            // Urls\n            try sculpture.urls() returns (string[] memory urls) {\n                if (urls.length > 0) {\n                    html = string.concat(html, '<p>');\n                    for (uint256 j = 0; j < urls.length; j++) {\n                        if (bytes(urls[j]).length == 0) continue; // ignore empty\n                        html = string.concat(html, Format.renderUrl(urls[j]), '<br>');\n                    }\n                    html = string.concat(html, '</p>');\n                }\n            } catch {\n                // ignore reverting urls\n            }\n\n            // Text\n            try sculpture.text() returns (string memory text) {\n                if (bytes(text).length > 0) {\n                    html = string.concat(html, '<div class=\"t\">', text, '</div>');\n                }\n            } catch {\n                html = string.concat(html, '<div class=\"t\"><i>Contract Reverted</i></div>');\n            }\n\n            html = string.concat(html, '</div></div>');\n        }\n\n        // Contributions\n        html = string.concat(html, GardenContributions.html(garden));\n\n        // Footer\n        html = string.concat(html, '<div class=\"i\">Generated in block ', LibString.toString(block.number), ' from <span class=\"a\">', LibString.toHexStringChecksummed(address(this)) ,\"</span></div>\");\n\n        // End\n        html = string.concat(html, '</div>');\n\n        string memory description = string.concat('Contract Show: World Computer Sculpture Garden at ', LibString.toHexStringChecksummed(garden), '. Curated by ', Mod(data).fff(), '.');\n\n        return GardenHTML.html(html, Sculpture(garden).title(), description);\n    }\n}"
    },
    "contracts/GardenRenderer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"solady/src/utils/LibString.sol\";\nimport \"./lib/Web3url.sol\";\nimport \"./Sculpture.sol\";\nimport \"./Essay.sol\";\nimport \"./GardenRenderer.sol\";\nimport \"./GardenIndex.sol\";\nimport \"./GardenEssay.sol\";\nimport \"./IWeb.sol\";\nimport \"./ENSResolver.sol\";\n\ncontract GardenRenderer is IWeb {\n\n    address immutable public garden;\n    address immutable public essayContract;\n    address immutable public data;\n\n    constructor(address _garden, address _essayContract, address _data) {\n        garden = _garden;\n        essayContract = _essayContract;\n        data = _data;\n    }\n\n    function html() public view returns (string memory) {\n        return index();\n    }\n\n    function index() public view returns (string memory) {\n        return GardenIndex.html(garden, essayContract, data);\n    }\n\n    function essay() public view returns (string memory) {\n        return GardenEssay.html(garden, essayContract);\n    }\n\n    function resolveMode() external pure returns (bytes32) {\n        return \"5219\";\n    }\n\n    // ERC-5219\n    function request(string[] memory resource, KeyValue[] memory params) external view returns (uint statusCode, string memory body, KeyValue[] memory headers) {\n        // Index\n        if(resource.length == 0) {\n            body = index();\n            statusCode = 200;\n            headers = new KeyValue[](1);\n            headers[0].key = \"Content-Type\";\n            headers[0].value = \"text/html; charset=utf-8\";\n            return (statusCode, body, headers);\n\n        // Essay\n        } else if (resource.length == 1 && keccak256(abi.encodePacked(resource[0])) == keccak256(abi.encodePacked(\"essay\"))) {\n            body = essay();\n            statusCode = 200;\n            headers = new KeyValue[](1);\n            headers[0].key = \"Content-Type\";\n            headers[0].value = \"text/html; charset=utf-8\";\n            return (statusCode, body, headers);\n\n        // Flower\n        } else if (resource.length == 2 && keccak256(abi.encodePacked(resource[0])) == keccak256(abi.encodePacked(\"flower\"))) {\n            uint256 flowerId = Format.stringToUint(resource[1]);\n            if (flowerId < 1 || flowerId > IGarden(garden).flowers()) {\n                statusCode = 404;\n                return (statusCode, body, headers);\n            }\n            (address planter, uint256 timestamp) = IGarden(garden).flowerInfo(flowerId);\n            string memory resolvedPlanter;\n            try ENSResolver.resolveAddress(planter) returns (string memory resolved) {\n                resolvedPlanter = resolved;\n            } catch {\n                resolvedPlanter = LibString.toHexStringChecksummed(planter);\n            }\n            body = string(abi.encodePacked(\n                '{',\n                '\"planter\": \"', resolvedPlanter, '\",',\n                '\"timestamp\": ', LibString.toString(timestamp),\n                '}'\n            ));\n            statusCode = 200;\n            headers = new KeyValue[](1);\n            headers[0].key = \"Content-Type\";\n            headers[0].value = \"application/json\";\n            return (statusCode, body, headers);\n        }\n\n        statusCode = 404;\n        return (statusCode, body, headers);\n    }\n}"
    },
    "contracts/IGarden.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IGarden {\n    function getSculptures() external view returns (address[] memory);\n    function flower(uint256 flowerId) external view returns (address);\n    function flowers() external view returns (uint256);\n    function flowersPlanted(address planter) external view returns (uint256);\n    function flowerPlantedAt(uint256 flowerId) external view returns (uint256);\n    function flowerInfo(uint256 flowerId) external view returns (address planter, uint256 timestamp);\n    function guests() external view returns (uint256);\n}"
    },
    "contracts/IWeb.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"./lib/Web3url.sol\";\n\ninterface IWeb is IDecentralizedApp {\n    function html() external view returns (string memory);\n}"
    },
    "contracts/lib/Format.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary Format {\n    function stripURL(string memory url) internal pure returns (string memory) {\n        bytes memory urlBytes = bytes(url);\n        uint256 length = urlBytes.length;\n        uint256 start = 0;\n        uint256 end = length;\n\n        // Handle \"data:\" URLs first\n        if (length >= 5 && urlBytes[0] == \"d\" && urlBytes[1] == \"a\" && urlBytes[2] == \"t\" && urlBytes[3] == \"a\" && urlBytes[4] == \":\") {\n            // we want a shortened version of the data URL, that replaces everything after the first comma with \"...\"\n            // e.g. \"data:text/plain;base64,...\"\n            for (uint256 i = 5; i < length; i++) {\n                if (urlBytes[i] == \",\") {\n                    end = i;\n                    break;\n                }\n            }\n        // Otherwise, handle other URLs\n        } else {\n\n            // Find the position of \"://\", which indicates the end of the protocol\n            for (uint256 i = 0; i < length - 2; i++) {\n                if (urlBytes[i] == \":\" && urlBytes[i + 1] == \"/\" && urlBytes[i + 2] == \"/\") {\n                    start = i + 3; // Skip the \"://\"max\n                    break;\n                }\n            }\n\n            // Find position of \"?\" or \"#\" to determine the end of the main URL\n            for (uint256 i = start; i < length; i++) {\n                if (urlBytes[i] == \"?\" || urlBytes[i] == \"#\") {\n                    end = i;\n                    break;\n                }\n            }\n\n            // Remove trailing slash if present\n            if (end > start && urlBytes[end - 1] == \"/\") {\n                end -= 1;\n            }\n        }\n\n        // Create a new byte array to store the stripped URL\n        bytes memory strippedUrlBytes = new bytes(end - start);\n        for (uint256 i = start; i < end; i++) {\n            strippedUrlBytes[i - start] = urlBytes[i];\n        }\n\n        return string(strippedUrlBytes);\n    }\n\n    function renderUrl(string memory url) internal pure returns (string memory) {\n        string memory strippedUrl = stripURL(url);\n        return string.concat('<a href=\"', url, '\" target=\"_blank\" rel=\"noopener noreferrer\">', strippedUrl ,'</a>');\n    }\n\n    function formatEther(uint256 weiAmount) internal pure returns (string memory) {\n        uint256 etherAmountWhole = weiAmount / 1e18;\n        uint256 etherAmountFraction = (weiAmount % 1e18) / 1e14;  // Get 4 decimals\n\n        string memory fractionStr = removeTrailingZeroes(uint2str(etherAmountFraction));\n\n        if (bytes(fractionStr).length > 0) {\n            return string(abi.encodePacked(\n                uint2str(etherAmountWhole),\n                \".\",\n                fractionStr\n            ));\n        } else {\n            return uint2str(etherAmountWhole);  // Return just the whole part if there are no decimals\n        }\n    }\n\n    function uint2str(uint256 _i) internal pure returns (string memory _uintAsString) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n\n    function removeTrailingZeroes(string memory str) internal pure returns (string memory) {\n        bytes memory bStr = bytes(str);\n        uint256 len = bStr.length;\n\n        // Remove trailing zeros from the fractional part\n        while (len > 0 && bStr[len - 1] == \"0\") {\n            len--;\n        }\n\n        // Return the truncated string\n        bytes memory trimmed = new bytes(len);\n        for (uint256 i = 0; i < len; i++) {\n            trimmed[i] = bStr[i];\n        }\n\n        return string(trimmed);\n    }\n\n    function stringToUint(string memory s) internal pure returns (uint result) {\n        bytes memory b = bytes(s);\n        result = 0;\n        for (uint256 i = 0; i < b.length; i++) {\n            uint256 c = uint256(uint8(b[i]));\n            if (c >= 48 && c <= 57) {\n                result = result * 10 + (c - 48);\n            }\n        }\n        return result;\n    }\n}\n\n"
    },
    "contracts/lib/Web3url.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nstruct KeyValue {\n    string key;\n    string value;\n}\n\ninterface IDecentralizedApp {\n    /// @notice                     Send an HTTP GET-like request to this contract\n    /// @param  resource            The resource to request (e.g. \"/asdf/1234\" turns in to `[\"asdf\", \"1234\"]`)\n    /// @param  params              The query parameters. (e.g. \"?asdf=1234&foo=bar\" turns in to `[{ key: \"asdf\", value: \"1234\" }, { key: \"foo\", value: \"bar\" }]`)\n    /// @return statusCode          The HTTP status code (e.g. 200)\n    /// @return body                The body of the response\n    /// @return headers             A list of header names (e.g. [{ key: \"Content-Type\", value: \"application/json\" }])\n    function request(string[] memory resource, KeyValue[] memory params) external view returns (uint statusCode, string memory body, KeyValue[] memory headers);\n\n    /// @notice                     returns the resolve mode of the contract\n    /// @return resolveMode         The mode of the resolver (e.g. 5219)\n    function resolveMode() external view returns (bytes32);\n}"
    },
    "contracts/Mod.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"solady/src/utils/SSTORE2.sol\";\n\ncontract Mod is Ownable {\n\n    constructor () Ownable(msg.sender) {}\n\n    // text\n    address private exhibitionText;\n\n    function setText(string memory _text) public onlyOwner {\n        exhibitionText = SSTORE2.write(bytes(_text));\n    }\n\n    function text() public view returns (string memory) {\n        if (exhibitionText == address(0)) {\n            return \"\";\n        }\n        return string(SSTORE2.read(exhibitionText));\n    }\n\n    // urls\n    string[] private exhibitionUrls;\n\n    function setExhibitionUrls(string[] memory _urls) public onlyOwner {\n        exhibitionUrls = _urls;\n    }\n\n    function urls() public view returns (string[] memory) {\n        return exhibitionUrls;\n    }\n\n    // fff\n    string public fff = \"0xfff\";\n\n    function setFff(string memory _fff) public onlyOwner {\n        fff = _fff;\n    }\n\n    string public fffUrl = \"https://www.0xfff.love\";\n\n    function setFffUrl(string memory _fffUrl) public onlyOwner {\n        fffUrl = _fffUrl;\n    }\n\n    // 113\n    string public oneOneThree = \"113\";\n\n    function setOneOneThree(string memory _oneOneThree) public onlyOwner {\n        oneOneThree = _oneOneThree;\n    }\n\n    string public oneOneThreeUrl = \"https://x.com/0x113d\";\n\n    function setOneOneThreeUrl(string memory _oneOneThreeUrl) public onlyOwner {\n        oneOneThreeUrl = _oneOneThreeUrl;\n    }\n\n    // sssluke\n    string public luke = \"sssluke\";\n\n    function setLuke(string memory _luke) public onlyOwner {\n        luke = _luke;\n    }\n\n    string public lukeUrl = \"https://x.com/sssluke1\";\n\n    function setLukeUrl(string memory _lukeUrl) public onlyOwner {\n        lukeUrl = _lukeUrl;\n    }\n\n    // maltefr\n    string public malte = \"maltefr\";\n\n    function setMalte(string memory _malte) public onlyOwner {\n        malte = _malte;\n    }\n\n    string public malteUrl = \"https://x.com/maltefr_eth\";\n\n    function setMalteUrl(string memory _malteUrl) public onlyOwner {\n        malteUrl = _malteUrl;\n    }\n}"
    },
    "contracts/Sculpture.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n////////////////////////////////////////////////////////////////////////\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                 ⚘                                  //\n//                             sculpture                              //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n//                                                                    //\n////////////////////////////////////////////////////////////////////////\n\ninterface Sculpture {\n\n    function title() external view returns (string memory);\n\n    function authors() external view returns (string[] memory);\n\n    function addresses() external view returns (address[] memory);\n\n    function urls() external view returns (string[] memory);\n\n    function text() external view returns (string memory);\n\n}\n"
    },
    "solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /// @dev The input string must be a 7-bit ASCII.\n    error StringNot7BitASCII();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\n\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\n\n    /// @dev Lookup for '0123456789'.\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\n\n    /// @dev Lookup for '01234567'.\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\n\n    /// @dev Lookup for '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\n\n    /// @dev Lookup for ' \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\n            mstore(str, 0) // Zeroize the slot after the string.\n\n            let end := str // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let length := sub(end, str)\n            str := sub(str, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(str, length) // Store the length.\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            str = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\n            mstore(str, 0) // Zeroize the slot after the string.\n\n            let end := str // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let strLength := sub(end, str)\n            str := sub(str, 0x20)\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\n            mstore(str, 0) // Zeroize the slot after the string.\n\n            let end := str // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let strLength := sub(end, str)\n            str := sub(str, 0x20)\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            str := add(str, 2)\n            mstore(str, 40) // Store the length.\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string,\n    /// AND all characters are in the `allowed` lookup.\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for {} 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\n    /// To save runtime gas, you can cache the result in an immutable variable.\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for {} 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            mstore(last, 0) // Zeroize the slot after the string.\n            mstore(result, totalLength) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n"
    },
    "solady/src/utils/SSTORE2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Read and write to persistent storage at a fraction of the cost.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SSTORE2.sol)\n/// @author Saw-mon-and-Natalie (https://github.com/Saw-mon-and-Natalie)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SSTORE2.sol)\n/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)\n/// @author Modified from SSTORE3 (https://github.com/Philogy/sstore3)\nlibrary SSTORE2 {\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         CONSTANTS                          */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev The proxy initialization code.\n    uint256 private constant _CREATE3_PROXY_INITCODE = 0x67363d3d37363d34f03d5260086018f3;\n\n    /// @dev Hash of the `_CREATE3_PROXY_INITCODE`.\n    /// Equivalent to `keccak256(abi.encodePacked(hex\"67363d3d37363d34f03d5260086018f3\"))`.\n    bytes32 internal constant CREATE3_PROXY_INITCODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Unable to deploy the storage contract.\n    error DeploymentFailed();\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         WRITE LOGIC                        */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data) // Let `l` be `n + 1`. +1 as we prefix a STOP opcode.\n            /**\n             * ---------------------------------------------------+\n             * Opcode | Mnemonic       | Stack     | Memory       |\n             * ---------------------------------------------------|\n             * 61 l   | PUSH2 l        | l         |              |\n             * 80     | DUP1           | l l       |              |\n             * 60 0xa | PUSH1 0xa      | 0xa l l   |              |\n             * 3D     | RETURNDATASIZE | 0 0xa l l |              |\n             * 39     | CODECOPY       | l         | [0..l): code |\n             * 3D     | RETURNDATASIZE | 0 l       | [0..l): code |\n             * F3     | RETURN         |           | [0..l): code |\n             * 00     | STOP           |           |              |\n             * ---------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(n, 0xb))\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract with `salt`\n    /// and returns its normal CREATE2 deterministic address.\n    function writeCounterfactual(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(n, 0xb), salt)\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Writes `data` into the bytecode of a storage contract and returns its address.\n    /// This uses the so-called \"CREATE3\" workflow,\n    /// which means that `pointer` is agnostic to `data, and only depends on `salt`.\n    function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(0x00, _CREATE3_PROXY_INITCODE) // Store the `_PROXY_INITCODE`.\n            let proxy := create2(0, 0x10, 0x10, salt)\n            if iszero(proxy) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, proxy) // Store the proxy's address.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            if iszero(\n                mul( // The arguments of `mul` are evaluated last to first.\n                    extcodesize(pointer),\n                    call(gas(), proxy, 0, add(data, 0x15), add(n, 0xb), codesize(), 0x00)\n                )\n            ) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                    ADDRESS CALCULATIONS                    */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Returns the initialization code hash of the storage contract for `data`.\n    /// Used for mining vanity addresses with create2crunch.\n    function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xfffe))\n            mstore(data, add(0x61000180600a3d393df300, shl(0x40, n)))\n            hash := keccak256(add(data, 0x15), add(n, 0xb))\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }\n\n    /// @dev Equivalent to `predictCounterfactualAddress(data, salt, address(this))`\n    function predictCounterfactualAddress(bytes memory data, bytes32 salt)\n        internal\n        view\n        returns (address pointer)\n    {\n        pointer = predictCounterfactualAddress(data, salt, address(this));\n    }\n\n    /// @dev Returns the CREATE2 address of the storage contract for `data`\n    /// deployed with `salt` by `deployer`.\n    /// Note: The returned result has dirty upper 96 bits. Please clean if used in assembly.\n    function predictCounterfactualAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }\n\n    /// @dev Equivalent to `predictDeterministicAddress(salt, address(this))`.\n    function predictDeterministicAddress(bytes32 salt) internal view returns (address pointer) {\n        pointer = predictDeterministicAddress(salt, address(this));\n    }\n\n    /// @dev Returns the \"CREATE3\" deterministic address for `salt` with `deployer`.\n    function predictDeterministicAddress(bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, deployer) // Store `deployer`.\n            mstore8(0x0b, 0xff) // Store the prefix.\n            mstore(0x20, salt) // Store the salt.\n            mstore(0x40, CREATE3_PROXY_INITCODE_HASH) // Store the bytecode hash.\n\n            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy's address.\n            mstore(0x40, m) // Restore the free memory pointer.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n        }\n    }\n\n    /*´:°•.°+.*•´.*:˚.°*.˚•´.°:°•.°•.*•´.*:˚.°*.˚•´.°:°•.°+.*•´.*:*/\n    /*                         READ LOGIC                         */\n    /*.•°:°.´+˚.*°.˚:*.´•*.+°.•°:´*.´•*.•°.•°:°.´:•˚°.*°.˚:*.´+°.•*/\n\n    /// @dev Equivalent to `read(pointer, 0, 2 ** 256 - 1)`.\n    function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(sub(extcodesize(pointer), 0x01), 0xffffffffff)\n            extcodecopy(pointer, add(data, 0x1f), 0x00, add(n, 0x21))\n            mstore(data, n) // Store the length.\n            mstore(0x40, add(n, add(data, 0x40))) // Allocate memory.\n        }\n    }\n\n    /// @dev Equivalent to `read(pointer, start, 2 ** 256 - 1)`.\n    function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(sub(extcodesize(pointer), 0x01), 0xffffffffff)\n            extcodecopy(pointer, add(data, 0x1f), start, add(n, 0x21))\n            mstore(data, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(data, add(0x40, mload(data)))) // Allocate memory.\n        }\n    }\n\n    /// @dev Returns a slice of the data on `pointer` from `start` to `end`.\n    /// `start` and `end` will be clamped to the range `[0, args.length]`.\n    /// The `pointer` MUST be deployed via the SSTORE2 write functions.\n    /// Otherwise, the behavior is undefined.\n    /// Out-of-gas reverts if `pointer` does not have any code.\n    function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(pointer, add(data, 0x1f), start, add(d, 0x01))\n            if iszero(and(0xff, mload(add(data, d)))) {\n                let n := sub(extcodesize(pointer), 0x01)\n                returndatacopy(returndatasize(), returndatasize(), shr(64, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(data, d) // Store the length.\n            mstore(add(add(data, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(data, 0x40), d)) // Allocate memory.\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}