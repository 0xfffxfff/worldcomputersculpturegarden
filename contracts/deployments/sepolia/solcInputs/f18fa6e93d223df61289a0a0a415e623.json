{
  "language": "Solidity",
  "sources": {
    "contracts/examples/ExampleRemoteWork.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"solady/src/utils/LibString.sol\";\nimport \"../Sculpture.sol\";\n\n\ncontract RemoteArtwork {\n    function isArt() external view returns (bool) {\n        return block.number % 2 == 0;\n    }\n}\ninterface IRemoteArtwork  {\n    function isArt() external view returns (bool);\n}\n\ncontract ExampleRemoteWork is Sculpture {\n\n    address public immutable remoteArtwork;\n\n    constructor(address _remoteArtwork) {\n        remoteArtwork = _remoteArtwork;\n    }\n\n    function title() external view override returns (string memory) {\n        return string.concat(\"Untitled\");\n    }\n\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"R.M.\";\n        return authors_;\n    }\n\n    function addresses() external view override returns (address[] memory) {\n        address[] memory addresses_ = new address[](1);\n        addresses_[0] = remoteArtwork;\n        return addresses_;\n    }\n\n    function text() public view override returns (string memory) {\n        return string.concat(\"Is Art: \", IRemoteArtwork(remoteArtwork).isArt() ? \"Yes\" : \"No\");\n    }\n\n    function urls() public view override returns (string[] memory urls) {} // empty\n}"
    },
    "contracts/examples/ExampleSculptureDynamic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"solady/src/utils/LibString.sol\";\nimport \"../Sculpture.sol\";\n\ncontract ExampleSculptureDynamic is Sculpture {\n\n    function title() external view override returns (string memory) {\n        // This title is dynamic and always shows the current block timestamp\n        return string.concat(\"Dynamic Title (\", block.number % 2 == 0 ? \"Even Block\" : \"Odd Block\" ,\")\");\n    }\n\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = block.number % 2 == 0 ? \"Artist (Happy)\" : \"Artist (Sad)\";\n        return authors_;\n    }\n\n    function addresses() external view override returns (address[] memory) {\n        address[] memory addresses_ = new address[](1);\n        // this too, could be dynamic or change over time\n        addresses_[0] = address(this);\n        return addresses_;\n    }\n\n    function text() public view override returns (string memory) {\n        // example text with a timestamp and block number\n        return string.concat(\"This is an example that is dynamicly rendering it's fields.<br/> Block number: \", LibString.toString(block.number), \" / Timestamp: \", LibString.toString(block.timestamp));\n    }\n\n    function urls() public view override returns (string[] memory urls) {} // empty\n}"
    },
    "contracts/examples/ExampleSculptureStatic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../Sculpture.sol\";\n\ncontract ExampleSculptureStatic is Sculpture {\n\n    function title() external pure override returns (string memory) {\n        return \"Static Example Sculpture Title\";\n    }\n\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"John Doe\";\n        return authors_;\n    }\n\n    function addresses() external view override returns (address[] memory) {\n        address[] memory addresses_ = new address[](1);\n        addresses_[0] = address(this);\n        return addresses_;\n    }\n\n    function text() public view override returns (string memory) {\n        return \"This is an example sculpture that is static.\";\n    }\n\n    function urls() public view override returns (string[] memory urls) {} // empty\n}"
    },
    "contracts/examples/ExampleSculptureStaticLongUrl.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"../Sculpture.sol\";\n\ncontract ExampleSculptureStaticLongUrl is Sculpture {\n\n    function title() external pure override returns (string memory) {\n        return \"Static Example With Long URL\";\n    }\n\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"John Doe\";\n        return authors_;\n    }\n\n    function addresses() external view override returns (address[] memory) {\n        address[] memory addresses_ = new address[](1);\n        addresses_[0] = address(this);\n        return addresses_;\n    }\n\n    function text() public view override returns (string memory) {\n        return \"This is an example sculpture that is static and has a long url\";\n    }\n\n    function urls() public view override returns (string[] memory urls) {\n        urls = new string[](3);\n        urls[0] = \"https://thisisaverylongsubdomainthatdoesnotexist.0xfff.love/this/is/a/very/long/url/?with=query&params=that&are=long&and=have&many=characters&and=numbers=1234567890#and-also-a-fragment\";\n        urls[1] = \"https://shortdomainbutlonghashtag.0xfff.love/#this-is-a-very-long-fragment-that-is-very-long-and-has-many-characters-and-numbers-1234567890\";\n        urls[2] = \"https://shortonebutlongquery.0xfff.love/?this=is=a&very=long&query=that&has=many&characters=and&numbers=1234567890\";\n    }\n}"
    },
    "contracts/Garden.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport \"solady/src/auth/Ownable.sol\";\nimport \"./Sculpture.sol\";\nimport \"./Web.sol\";\nimport \"./s/ST.sol\";\n\ncontract Garden is Sculpture, ST {\n\n    address[] public sculptures;\n\n    address public immutable render;\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Init\n    ///////////////////////////////////////////////////////////////////////////\n\n    constructor(address[] memory _sculptures, address _render, address _sp) ST(_sp, msg.sender) {\n        sculptures = _sculptures;\n        render = _render;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Web\n    ///////////////////////////////////////////////////////////////////////////\n\n    fallback() external payable {\n        revert(IWeb(render).html());\n    }\n\n    function html() external view returns (string memory) {\n        return IWeb(render).html();\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Sculpture Management\n    ///////////////////////////////////////////////////////////////////////////\n\n    function getSculptures() public view returns (address[] memory) {\n        return sculptures;\n    }\n\n    function setSculptures(address[] memory _sculptures) public onlyOwner {\n        sculptures = _sculptures;\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Show\n    ///////////////////////////////////////////////////////////////////////////\n\n    function title() external pure returns (string memory) {\n        return \"World Computer Sculpture Garden\";\n    }\n\n    function authors() external view returns (string[] memory) {\n        uint256 length;\n        for (uint256 i = 0; i < sculptures.length; i++) {\n            string[] memory sculptureAuthors = Sculpture(sculptures[i]).authors();\n            for (uint256 j = 0; j < sculptureAuthors.length; j++) {\n                length++;\n            }\n        }\n        string[] memory authors_ = new string[](length);\n        uint256 index;\n        for (uint256 i = 0; i < sculptures.length; i++) {\n            string[] memory sculptureAuthors = Sculpture(sculptures[i]).authors();\n            for (uint256 j = 0; j < sculptureAuthors.length; j++) {\n                authors_[index] = sculptureAuthors[j];\n                index++;\n            }\n        }\n        return authors_;\n    }\n\n    function addresses() external view returns (address[] memory) {\n        address[] memory addresses_;\n        for (uint256 i = 0; i < sculptures.length; i++) {\n            Sculpture sculpture = Sculpture(sculptures[i]);\n            address[] memory sculptureAddresses = sculpture.addresses();\n            for (uint256 j = 0; j < sculptureAddresses.length; j++) {\n                addresses_[addresses_.length] = sculpture.addresses()[j];\n            }\n        }\n        return addresses_;\n    }\n\n    string public exhibitionText;\n    function text() public view returns (string memory) {\n        return exhibitionText;\n    }\n    function setText(string memory _text) public onlyOwner {\n        exhibitionText = _text;\n    }\n\n    string[] public exhibitionUrls;\n    function setExhibitionUrls(string[] memory _urls) public onlyOwner {\n        exhibitionUrls = _urls;\n    }\n    function urls() public view returns (string[] memory) {\n        return exhibitionUrls;\n    }\n}"
    },
    "contracts/lib/ABDKMath64x64.sol": {
      "content": "// SPDX-License-Identifier: BSD-4-Clause\n/*\n * ABDK Math 64.64 Smart Contract Library.  Copyright Â© 2019 by ABDK Consulting.\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\n */\npragma solidity ^0.8.0;\n\n/**\n * Smart contract library of mathematical functions operating with signed\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\n * basically a simple fraction whose numerator is signed 128-bit integer and\n * denominator is 2^64.  As long as denominator is always the same, there is no\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\n * represented by int128 type holding only the numerator.\n */\nlibrary ABDKMath64x64 {\n  /*\n   * Minimum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\n\n  /*\n   * Maximum value signed 64.64-bit fixed point number may have. \n   */\n  int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n\n  /**\n   * Convert signed 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromInt (int256 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (x << 64);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 64-bit integer number\n   * rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64-bit integer number\n   */\n  function toInt (int128 x) internal pure returns (int64) {\n    unchecked {\n      return int64 (x >> 64);\n    }\n  }\n\n  /**\n   * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\n   * number.  Revert on overflow.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function fromUInt (uint256 x) internal pure returns (int128) {\n    unchecked {\n      require (x <= 0x7FFFFFFFFFFFFFFF);\n      return int128 (int256 (x << 64));\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into unsigned 64-bit integer\n   * number rounding down.  Revert on underflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return unsigned 64-bit integer number\n   */\n  function toUInt (int128 x) internal pure returns (uint64) {\n    unchecked {\n      require (x >= 0);\n      return uint64 (uint128 (x >> 64));\n    }\n  }\n\n  /**\n   * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\n   * number rounding down.  Revert on overflow.\n   *\n   * @param x signed 128.128-bin fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function from128x128 (int256 x) internal pure returns (int128) {\n    unchecked {\n      int256 result = x >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Convert signed 64.64 fixed point number into signed 128.128 fixed point\n   * number.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 128.128 fixed point number\n   */\n  function to128x128 (int128 x) internal pure returns (int256) {\n    unchecked {\n      return int256 (x) << 64;\n    }\n  }\n\n  /**\n   * Calculate x + y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function add (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) + y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x - y.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sub (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) - y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function mul (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 result = int256(x) * y >> 64;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\n   * number and y is signed 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y signed 256-bit integer number\n   * @return signed 256-bit integer number\n   */\n  function muli (int128 x, int256 y) internal pure returns (int256) {\n    unchecked {\n      if (x == MIN_64x64) {\n        require (y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\n          y <= 0x1000000000000000000000000000000000000000000000000);\n        return -y << 63;\n      } else {\n        bool negativeResult = false;\n        if (x < 0) {\n          x = -x;\n          negativeResult = true;\n        }\n        if (y < 0) {\n          y = -y; // We rely on overflow behavior here\n          negativeResult = !negativeResult;\n        }\n        uint256 absoluteResult = mulu (x, uint256 (y));\n        if (negativeResult) {\n          require (absoluteResult <=\n            0x8000000000000000000000000000000000000000000000000000000000000000);\n          return -int256 (absoluteResult); // We rely on overflow behavior here\n        } else {\n          require (absoluteResult <=\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n          return int256 (absoluteResult);\n        }\n      }\n    }\n  }\n\n  /**\n   * Calculate x * y rounding down, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64 fixed point number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 256-bit integer number\n   */\n  function mulu (int128 x, uint256 y) internal pure returns (uint256) {\n    unchecked {\n      if (y == 0) return 0;\n\n      require (x >= 0);\n\n      uint256 lo = (uint256 (int256 (x)) * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\n      uint256 hi = uint256 (int256 (x)) * (y >> 128);\n\n      require (hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      hi <<= 64;\n\n      require (hi <=\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - lo);\n      return hi + lo;\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero.  Revert on overflow or when y is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function div (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      int256 result = (int256 (x) << 64) / y;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are signed 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x signed 256-bit integer number\n   * @param y signed 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divi (int256 x, int256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n\n      bool negativeResult = false;\n      if (x < 0) {\n        x = -x; // We rely on overflow behavior here\n        negativeResult = true;\n      }\n      if (y < 0) {\n        y = -y; // We rely on overflow behavior here\n        negativeResult = !negativeResult;\n      }\n      uint128 absoluteResult = divuu (uint256 (x), uint256 (y));\n      if (negativeResult) {\n        require (absoluteResult <= 0x80000000000000000000000000000000);\n        return -int128 (absoluteResult); // We rely on overflow behavior here\n      } else {\n        require (absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n        return int128 (absoluteResult); // We rely on overflow behavior here\n      }\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return signed 64.64-bit fixed point number\n   */\n  function divu (uint256 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      require (y != 0);\n      uint128 result = divuu (x, y);\n      require (result <= uint128 (MAX_64x64));\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate -x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function neg (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return -x;\n    }\n  }\n\n  /**\n   * Calculate |x|.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function abs (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != MIN_64x64);\n      return x < 0 ? -x : x;\n    }\n  }\n\n  /**\n   * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\n   * zero.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function inv (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x != 0);\n      int256 result = int256 (0x100000000000000000000000000000000) / x;\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function avg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      return int128 ((int256 (x) + int256 (y)) >> 1);\n    }\n  }\n\n  /**\n   * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\n   * Revert on overflow or in case x * y is negative.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function gavg (int128 x, int128 y) internal pure returns (int128) {\n    unchecked {\n      int256 m = int256 (x) * int256 (y);\n      require (m >= 0);\n      require (m <\n          0x4000000000000000000000000000000000000000000000000000000000000000);\n      return int128 (sqrtu (uint256 (m)));\n    }\n  }\n\n  /**\n   * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\n   * and y is unsigned 256-bit integer number.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @param y uint256 value\n   * @return signed 64.64-bit fixed point number\n   */\n  function pow (int128 x, uint256 y) internal pure returns (int128) {\n    unchecked {\n      bool negative = x < 0 && y & 1 == 1;\n\n      uint256 absX = uint128 (x < 0 ? -x : x);\n      uint256 absResult;\n      absResult = 0x100000000000000000000000000000000;\n\n      if (absX <= 0x10000000000000000) {\n        absX <<= 63;\n        while (y != 0) {\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x2 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x4 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          if (y & 0x8 != 0) {\n            absResult = absResult * absX >> 127;\n          }\n          absX = absX * absX >> 127;\n\n          y >>= 4;\n        }\n\n        absResult >>= 64;\n      } else {\n        uint256 absXShift = 63;\n        if (absX < 0x1000000000000000000000000) { absX <<= 32; absXShift -= 32; }\n        if (absX < 0x10000000000000000000000000000) { absX <<= 16; absXShift -= 16; }\n        if (absX < 0x1000000000000000000000000000000) { absX <<= 8; absXShift -= 8; }\n        if (absX < 0x10000000000000000000000000000000) { absX <<= 4; absXShift -= 4; }\n        if (absX < 0x40000000000000000000000000000000) { absX <<= 2; absXShift -= 2; }\n        if (absX < 0x80000000000000000000000000000000) { absX <<= 1; absXShift -= 1; }\n\n        uint256 resultShift = 0;\n        while (y != 0) {\n          require (absXShift < 64);\n\n          if (y & 0x1 != 0) {\n            absResult = absResult * absX >> 127;\n            resultShift += absXShift;\n            if (absResult > 0x100000000000000000000000000000000) {\n              absResult >>= 1;\n              resultShift += 1;\n            }\n          }\n          absX = absX * absX >> 127;\n          absXShift <<= 1;\n          if (absX >= 0x100000000000000000000000000000000) {\n              absX >>= 1;\n              absXShift += 1;\n          }\n\n          y >>= 1;\n        }\n\n        require (resultShift < 64);\n        absResult >>= 64 - resultShift;\n      }\n      int256 result = negative ? -int256 (absResult) : int256 (absResult);\n      require (result >= MIN_64x64 && result <= MAX_64x64);\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down.  Revert if x < 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function sqrt (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x >= 0);\n      return int128 (sqrtu (uint256 (int256 (x)) << 64));\n    }\n  }\n\n  /**\n   * Calculate binary logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function log_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      int256 msb = 0;\n      int256 xc = x;\n      if (xc >= 0x10000000000000000) { xc >>= 64; msb += 64; }\n      if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n      if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n      if (xc >= 0x100) { xc >>= 8; msb += 8; }\n      if (xc >= 0x10) { xc >>= 4; msb += 4; }\n      if (xc >= 0x4) { xc >>= 2; msb += 2; }\n      if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n      int256 result = msb - 64 << 64;\n      uint256 ux = uint256 (int256 (x)) << uint256 (127 - msb);\n      for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\n        ux *= ux;\n        uint256 b = ux >> 255;\n        ux >>= 127 + b;\n        result += bit * int256 (b);\n      }\n\n      return int128 (result);\n    }\n  }\n\n  /**\n   * Calculate natural logarithm of x.  Revert if x <= 0.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function ln (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x > 0);\n\n      return int128 (int256 (\n          uint256 (int256 (log_2 (x))) * 0xB17217F7D1CF79ABC9E3B39803F2F6AF >> 128));\n    }\n  }\n\n  /**\n   * Calculate binary exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp_2 (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      uint256 result = 0x80000000000000000000000000000000;\n\n      if (x & 0x8000000000000000 > 0)\n        result = result * 0x16A09E667F3BCC908B2FB1366EA957D3E >> 128;\n      if (x & 0x4000000000000000 > 0)\n        result = result * 0x1306FE0A31B7152DE8D5A46305C85EDEC >> 128;\n      if (x & 0x2000000000000000 > 0)\n        result = result * 0x1172B83C7D517ADCDF7C8C50EB14A791F >> 128;\n      if (x & 0x1000000000000000 > 0)\n        result = result * 0x10B5586CF9890F6298B92B71842A98363 >> 128;\n      if (x & 0x800000000000000 > 0)\n        result = result * 0x1059B0D31585743AE7C548EB68CA417FD >> 128;\n      if (x & 0x400000000000000 > 0)\n        result = result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8 >> 128;\n      if (x & 0x200000000000000 > 0)\n        result = result * 0x10163DA9FB33356D84A66AE336DCDFA3F >> 128;\n      if (x & 0x100000000000000 > 0)\n        result = result * 0x100B1AFA5ABCBED6129AB13EC11DC9543 >> 128;\n      if (x & 0x80000000000000 > 0)\n        result = result * 0x10058C86DA1C09EA1FF19D294CF2F679B >> 128;\n      if (x & 0x40000000000000 > 0)\n        result = result * 0x1002C605E2E8CEC506D21BFC89A23A00F >> 128;\n      if (x & 0x20000000000000 > 0)\n        result = result * 0x100162F3904051FA128BCA9C55C31E5DF >> 128;\n      if (x & 0x10000000000000 > 0)\n        result = result * 0x1000B175EFFDC76BA38E31671CA939725 >> 128;\n      if (x & 0x8000000000000 > 0)\n        result = result * 0x100058BA01FB9F96D6CACD4B180917C3D >> 128;\n      if (x & 0x4000000000000 > 0)\n        result = result * 0x10002C5CC37DA9491D0985C348C68E7B3 >> 128;\n      if (x & 0x2000000000000 > 0)\n        result = result * 0x1000162E525EE054754457D5995292026 >> 128;\n      if (x & 0x1000000000000 > 0)\n        result = result * 0x10000B17255775C040618BF4A4ADE83FC >> 128;\n      if (x & 0x800000000000 > 0)\n        result = result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB >> 128;\n      if (x & 0x400000000000 > 0)\n        result = result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9 >> 128;\n      if (x & 0x200000000000 > 0)\n        result = result * 0x10000162E43F4F831060E02D839A9D16D >> 128;\n      if (x & 0x100000000000 > 0)\n        result = result * 0x100000B1721BCFC99D9F890EA06911763 >> 128;\n      if (x & 0x80000000000 > 0)\n        result = result * 0x10000058B90CF1E6D97F9CA14DBCC1628 >> 128;\n      if (x & 0x40000000000 > 0)\n        result = result * 0x1000002C5C863B73F016468F6BAC5CA2B >> 128;\n      if (x & 0x20000000000 > 0)\n        result = result * 0x100000162E430E5A18F6119E3C02282A5 >> 128;\n      if (x & 0x10000000000 > 0)\n        result = result * 0x1000000B1721835514B86E6D96EFD1BFE >> 128;\n      if (x & 0x8000000000 > 0)\n        result = result * 0x100000058B90C0B48C6BE5DF846C5B2EF >> 128;\n      if (x & 0x4000000000 > 0)\n        result = result * 0x10000002C5C8601CC6B9E94213C72737A >> 128;\n      if (x & 0x2000000000 > 0)\n        result = result * 0x1000000162E42FFF037DF38AA2B219F06 >> 128;\n      if (x & 0x1000000000 > 0)\n        result = result * 0x10000000B17217FBA9C739AA5819F44F9 >> 128;\n      if (x & 0x800000000 > 0)\n        result = result * 0x1000000058B90BFCDEE5ACD3C1CEDC823 >> 128;\n      if (x & 0x400000000 > 0)\n        result = result * 0x100000002C5C85FE31F35A6A30DA1BE50 >> 128;\n      if (x & 0x200000000 > 0)\n        result = result * 0x10000000162E42FF0999CE3541B9FFFCF >> 128;\n      if (x & 0x100000000 > 0)\n        result = result * 0x100000000B17217F80F4EF5AADDA45554 >> 128;\n      if (x & 0x80000000 > 0)\n        result = result * 0x10000000058B90BFBF8479BD5A81B51AD >> 128;\n      if (x & 0x40000000 > 0)\n        result = result * 0x1000000002C5C85FDF84BD62AE30A74CC >> 128;\n      if (x & 0x20000000 > 0)\n        result = result * 0x100000000162E42FEFB2FED257559BDAA >> 128;\n      if (x & 0x10000000 > 0)\n        result = result * 0x1000000000B17217F7D5A7716BBA4A9AE >> 128;\n      if (x & 0x8000000 > 0)\n        result = result * 0x100000000058B90BFBE9DDBAC5E109CCE >> 128;\n      if (x & 0x4000000 > 0)\n        result = result * 0x10000000002C5C85FDF4B15DE6F17EB0D >> 128;\n      if (x & 0x2000000 > 0)\n        result = result * 0x1000000000162E42FEFA494F1478FDE05 >> 128;\n      if (x & 0x1000000 > 0)\n        result = result * 0x10000000000B17217F7D20CF927C8E94C >> 128;\n      if (x & 0x800000 > 0)\n        result = result * 0x1000000000058B90BFBE8F71CB4E4B33D >> 128;\n      if (x & 0x400000 > 0)\n        result = result * 0x100000000002C5C85FDF477B662B26945 >> 128;\n      if (x & 0x200000 > 0)\n        result = result * 0x10000000000162E42FEFA3AE53369388C >> 128;\n      if (x & 0x100000 > 0)\n        result = result * 0x100000000000B17217F7D1D351A389D40 >> 128;\n      if (x & 0x80000 > 0)\n        result = result * 0x10000000000058B90BFBE8E8B2D3D4EDE >> 128;\n      if (x & 0x40000 > 0)\n        result = result * 0x1000000000002C5C85FDF4741BEA6E77E >> 128;\n      if (x & 0x20000 > 0)\n        result = result * 0x100000000000162E42FEFA39FE95583C2 >> 128;\n      if (x & 0x10000 > 0)\n        result = result * 0x1000000000000B17217F7D1CFB72B45E1 >> 128;\n      if (x & 0x8000 > 0)\n        result = result * 0x100000000000058B90BFBE8E7CC35C3F0 >> 128;\n      if (x & 0x4000 > 0)\n        result = result * 0x10000000000002C5C85FDF473E242EA38 >> 128;\n      if (x & 0x2000 > 0)\n        result = result * 0x1000000000000162E42FEFA39F02B772C >> 128;\n      if (x & 0x1000 > 0)\n        result = result * 0x10000000000000B17217F7D1CF7D83C1A >> 128;\n      if (x & 0x800 > 0)\n        result = result * 0x1000000000000058B90BFBE8E7BDCBE2E >> 128;\n      if (x & 0x400 > 0)\n        result = result * 0x100000000000002C5C85FDF473DEA871F >> 128;\n      if (x & 0x200 > 0)\n        result = result * 0x10000000000000162E42FEFA39EF44D91 >> 128;\n      if (x & 0x100 > 0)\n        result = result * 0x100000000000000B17217F7D1CF79E949 >> 128;\n      if (x & 0x80 > 0)\n        result = result * 0x10000000000000058B90BFBE8E7BCE544 >> 128;\n      if (x & 0x40 > 0)\n        result = result * 0x1000000000000002C5C85FDF473DE6ECA >> 128;\n      if (x & 0x20 > 0)\n        result = result * 0x100000000000000162E42FEFA39EF366F >> 128;\n      if (x & 0x10 > 0)\n        result = result * 0x1000000000000000B17217F7D1CF79AFA >> 128;\n      if (x & 0x8 > 0)\n        result = result * 0x100000000000000058B90BFBE8E7BCD6D >> 128;\n      if (x & 0x4 > 0)\n        result = result * 0x10000000000000002C5C85FDF473DE6B2 >> 128;\n      if (x & 0x2 > 0)\n        result = result * 0x1000000000000000162E42FEFA39EF358 >> 128;\n      if (x & 0x1 > 0)\n        result = result * 0x10000000000000000B17217F7D1CF79AB >> 128;\n\n      result >>= uint256 (int256 (63 - (x >> 64)));\n      require (result <= uint256 (int256 (MAX_64x64)));\n\n      return int128 (int256 (result));\n    }\n  }\n\n  /**\n   * Calculate natural exponent of x.  Revert on overflow.\n   *\n   * @param x signed 64.64-bit fixed point number\n   * @return signed 64.64-bit fixed point number\n   */\n  function exp (int128 x) internal pure returns (int128) {\n    unchecked {\n      require (x < 0x400000000000000000); // Overflow\n\n      if (x < -0x400000000000000000) return 0; // Underflow\n\n      return exp_2 (\n          int128 (int256 (x) * 0x171547652B82FE1777D0FFDA0D23A7D12 >> 128));\n    }\n  }\n\n  /**\n   * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\n   * integer numbers.  Revert on overflow or when y is zero.\n   *\n   * @param x unsigned 256-bit integer number\n   * @param y unsigned 256-bit integer number\n   * @return unsigned 64.64-bit fixed point number\n   */\n  function divuu (uint256 x, uint256 y) private pure returns (uint128) {\n    unchecked {\n      require (y != 0);\n\n      uint256 result;\n\n      if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\n        result = (x << 64) / y;\n      else {\n        uint256 msb = 192;\n        uint256 xc = x >> 192;\n        if (xc >= 0x100000000) { xc >>= 32; msb += 32; }\n        if (xc >= 0x10000) { xc >>= 16; msb += 16; }\n        if (xc >= 0x100) { xc >>= 8; msb += 8; }\n        if (xc >= 0x10) { xc >>= 4; msb += 4; }\n        if (xc >= 0x4) { xc >>= 2; msb += 2; }\n        if (xc >= 0x2) msb += 1;  // No need to shift xc anymore\n\n        result = (x << 255 - msb) / ((y - 1 >> msb - 191) + 1);\n        require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 hi = result * (y >> 128);\n        uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n\n        uint256 xh = x >> 192;\n        uint256 xl = x << 64;\n\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n        lo = hi << 128;\n        if (xl < lo) xh -= 1;\n        xl -= lo; // We rely on overflow behavior here\n\n        result += xh == hi >> 128 ? xl / y : 1;\n      }\n\n      require (result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\n      return uint128 (result);\n    }\n  }\n\n  /**\n   * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\n   * number.\n   *\n   * @param x unsigned 256-bit integer number\n   * @return unsigned 128-bit integer number\n   */\n  function sqrtu (uint256 x) private pure returns (uint128) {\n    unchecked {\n      if (x == 0) return 0;\n      else {\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) { xx >>= 128; r <<= 64; }\n        if (xx >= 0x10000000000000000) { xx >>= 64; r <<= 32; }\n        if (xx >= 0x100000000) { xx >>= 32; r <<= 16; }\n        if (xx >= 0x10000) { xx >>= 16; r <<= 8; }\n        if (xx >= 0x100) { xx >>= 8; r <<= 4; }\n        if (xx >= 0x10) { xx >>= 4; r <<= 2; }\n        if (xx >= 0x4) { r <<= 1; }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return uint128 (r < r1 ? r : r1);\n      }\n    }\n  }\n}\n"
    },
    "contracts/lib/HitchensOrderStatisticsTreeLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/* \nOrder Statistics Tree by Envelop \nBased on\nHitchens Order Statistics Tree v0.99\n\nA Solidity Red-Black Tree library to store and maintain a sorted data\nstructure in a Red-Black binary search tree, with O(log 2n) insert, remove\nand search time (and gas, approximately)\n\nhttps://github.com/rob-Hitchens/OrderStatisticsTree\n\nCopyright (c) Rob Hitchens. the MIT License\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\nSignificant portions from BokkyPooBahsRedBlackTreeLibrary, \nhttps://github.com/bokkypoobah/BokkyPooBahsRedBlackTreeLibrary\n\nTHIS SOFTWARE IS NOT TESTED OR AUDITED. DO NOT USE FOR PRODUCTION.\n*/\n\nlibrary HitchensOrderStatisticsTreeLib {\n    uint private constant EMPTY = 0;\n    struct Node {\n        uint parent;\n        uint left;\n        uint right;\n        bool red;\n        bytes32[] keys;\n        mapping(bytes32 => uint) keyMap;\n        uint count;\n    }\n    struct Tree {\n        uint root;\n        mapping(uint => Node) nodes;\n    }\n\n    function first(Tree storage self) internal view returns (uint _value) {\n        _value = self.root;\n        if (_value == EMPTY) return 0;\n        while (self.nodes[_value].left != EMPTY) {\n            _value = self.nodes[_value].left;\n        }\n    }\n\n    function last(Tree storage self) internal view returns (uint _value) {\n        _value = self.root;\n        if (_value == EMPTY) return 0;\n        while (self.nodes[_value].right != EMPTY) {\n            _value = self.nodes[_value].right;\n        }\n    }\n\n    function next(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _cursor) {\n        require(\n            value != EMPTY,\n            'OrderStatisticsTree(401) - Starting value cannot be zero'\n        );\n        if (self.nodes[value].right != EMPTY) {\n            _cursor = treeMinimum(self, self.nodes[value].right);\n        } else {\n            _cursor = self.nodes[value].parent;\n            while (_cursor != EMPTY && value == self.nodes[_cursor].right) {\n                value = _cursor;\n                _cursor = self.nodes[_cursor].parent;\n            }\n        }\n    }\n\n    function prev(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _cursor) {\n        require(\n            value != EMPTY,\n            'OrderStatisticsTree(402) - Starting value cannot be zero'\n        );\n        if (self.nodes[value].left != EMPTY) {\n            _cursor = treeMaximum(self, self.nodes[value].left);\n        } else {\n            _cursor = self.nodes[value].parent;\n            while (_cursor != EMPTY && value == self.nodes[_cursor].left) {\n                value = _cursor;\n                _cursor = self.nodes[_cursor].parent;\n            }\n        }\n    }\n\n    function exists(\n        Tree storage self,\n        uint value\n    ) internal view returns (bool _exists) {\n        if (value == EMPTY) return false;\n        if (value == self.root) return true;\n        if (self.nodes[value].parent != EMPTY) return true;\n        return false;\n    }\n\n    function keyExists(\n        Tree storage self,\n        bytes32 key,\n        uint value\n    ) internal view returns (bool _exists) {\n        if (!exists(self, value)) return false;\n        return self.nodes[value].keys[self.nodes[value].keyMap[key]] == key;\n    }\n\n    function getNode(\n        Tree storage self,\n        uint value\n    )\n        internal\n        view\n        returns (\n            uint _parent,\n            uint _left,\n            uint _right,\n            bool _red,\n            uint keyCount,\n            uint _count\n        )\n    {\n        require(\n            exists(self, value),\n            'OrderStatisticsTree(403) - Value does not exist.'\n        );\n        Node storage gn = self.nodes[value];\n        return (\n            gn.parent,\n            gn.left,\n            gn.right,\n            gn.red,\n            gn.keys.length,\n            gn.keys.length + gn.count\n        );\n    }\n\n    function getNode2(\n        Tree storage self,\n        uint value\n    ) internal view returns (Node storage node) {\n        require(\n            exists(self, value),\n            'OrderStatisticsTree(403) - Value does not exist.'\n        );\n        node = self.nodes[value];\n    }\n\n    function getNodeCount(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _count) {\n        Node storage gn = self.nodes[value];\n        return gn.keys.length + gn.count;\n    }\n\n    function getNodeKeysLength(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _count) {\n        self.nodes[value];\n        return self.nodes[value].keys.length;\n    }\n\n    function valueKeyAtIndex(\n        Tree storage self,\n        uint value,\n        uint index\n    ) internal view returns (bytes32 _key) {\n        require(\n            exists(self, value),\n            'OrderStatisticsTree(404) - Value does not exist.'\n        );\n        return self.nodes[value].keys[index];\n    }\n\n    function count(Tree storage self) internal view returns (uint _count) {\n        return getNodeCount(self, self.root);\n    }\n\n    function percentile(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _percentile) {\n        uint denominator = count(self);\n        uint numerator = rank(self, value);\n        _percentile =\n            ((uint(1000) * numerator) / denominator + (uint(5))) /\n            uint(10);\n    }\n\n    function permil(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _permil) {\n        uint denominator = count(self);\n        uint numerator = rank(self, value);\n        _permil =\n            ((uint(10000) * numerator) / denominator + (uint(5))) /\n            uint(10);\n    }\n\n    function atPercentile(\n        Tree storage self,\n        uint _percentile\n    ) internal view returns (uint _value) {\n        uint findRank = (((_percentile * count(self)) / uint(10)) + uint(5)) /\n            uint(10);\n        return atRank(self, findRank);\n    }\n\n    function atPermil(\n        Tree storage self,\n        uint _permil\n    ) internal view returns (uint _value) {\n        uint findRank = (((_permil * count(self)) / uint(100)) + uint(5)) /\n            uint(10);\n        return atRank(self, findRank);\n    }\n\n    function median(Tree storage self) internal view returns (uint value) {\n        return atPercentile(self, 50);\n    }\n\n    function below(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _below) {\n        if (count(self) > 0 && value > 0) _below = rank(self, value) - uint(1);\n    }\n\n    function above(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _above) {\n        if (count(self) > 0) _above = count(self) - rank(self, value);\n    }\n\n    function rank(\n        Tree storage self,\n        uint value\n    ) internal view returns (uint _rank) {\n        if (count(self) > 0) {\n            bool finished;\n            uint cursor = self.root;\n            Node storage c = self.nodes[cursor];\n            uint smaller = getNodeCount(self, c.left);\n            while (!finished) {\n                uint keyCount = c.keys.length;\n                if (cursor == value) {\n                    finished = true;\n                } else {\n                    if (cursor < value) {\n                        cursor = c.right;\n                        c = self.nodes[cursor];\n                        smaller += keyCount + getNodeCount(self, c.left);\n                    } else {\n                        cursor = c.left;\n                        c = self.nodes[cursor];\n                        if (\n                            smaller >= (keyCount + getNodeCount(self, c.right))\n                        ) {\n                            smaller -= (keyCount + getNodeCount(self, c.right));\n                        } else {\n                            smaller = 0;\n                            finished = true;\n                        }\n                    }\n                }\n                if (!exists(self, cursor)) {\n                    finished = true;\n                }\n            }\n            return smaller + 1;\n        }\n    }\n\n    function atRank(\n        Tree storage self,\n        uint _rank\n    ) internal view returns (uint _value) {\n        bool finished;\n        uint cursor = self.root;\n        Node storage c = self.nodes[cursor];\n        // Case when only one node exist\n        if (c.parent == 0 && c.left == 0 && c.right == 0) {\n            _value = cursor;\n            return _value;\n        }\n        uint smaller = getNodeCount(self, c.left);\n        while (!finished) {\n            _value = cursor;\n            c = self.nodes[cursor];\n            uint keyCount = c.keys.length;\n            if (smaller + 1 >= _rank && smaller + keyCount <= _rank) {\n                _value = cursor;\n                finished = true;\n            } else {\n                if (smaller + keyCount <= _rank) {\n                    cursor = c.right;\n                    c = self.nodes[cursor];\n                    smaller += keyCount + getNodeCount(self, c.left);\n                } else {\n                    cursor = c.left;\n                    c = self.nodes[cursor];\n                    if (smaller >= (keyCount + getNodeCount(self, c.right))) {\n                        smaller -= (keyCount + getNodeCount(self, c.right));\n                    } else {\n                        smaller = 0;\n                        finished = true;\n                    }\n                }\n            }\n            if (!exists(self, cursor)) {\n                finished = true;\n            }\n        }\n    }\n\n    function insert(Tree storage self, bytes32 key, uint value) internal {\n        require(\n            value != EMPTY,\n            'OrderStatisticsTree(405) - Value to insert cannot be zero'\n        );\n        require(\n            !keyExists(self, key, value),\n            'OrderStatisticsTree(406) - Value and Key pair exists. Cannot be inserted again.'\n        );\n        uint cursor;\n        uint probe = self.root;\n        while (probe != EMPTY) {\n            cursor = probe;\n            if (value < probe) {\n                probe = self.nodes[probe].left;\n            } else if (value > probe) {\n                probe = self.nodes[probe].right;\n            } else if (value == probe) {\n                self.nodes[probe].keys.push(key);\n                self.nodes[probe].keyMap[key] =\n                    self.nodes[probe].keys.length -\n                    uint256(1);\n                return;\n            }\n            self.nodes[cursor].count++;\n        }\n        Node storage nValue = self.nodes[value];\n        nValue.parent = cursor;\n        nValue.left = EMPTY;\n        nValue.right = EMPTY;\n        nValue.red = true;\n        nValue.keys.push(key);\n        nValue.keyMap[key] = nValue.keys.length - uint256(1);\n        if (cursor == EMPTY) {\n            self.root = value;\n        } else if (value < cursor) {\n            self.nodes[cursor].left = value;\n        } else {\n            self.nodes[cursor].right = value;\n        }\n        insertFixup(self, value);\n    }\n\n    function remove(Tree storage self, bytes32 key, uint value) internal {\n        require(\n            value != EMPTY,\n            'OrderStatisticsTree(407) - Value to delete cannot be zero'\n        );\n        require(\n            keyExists(self, key, value),\n            'OrderStatisticsTree(408) - Value to delete does not exist.'\n        );\n        Node storage nValue = self.nodes[value];\n        uint rowToDelete = nValue.keyMap[key];\n\n        // Remove key from array. In Solidity only last array member\n        // can be delete. So we need some replace logic.\n        // But if there is only one array member we dont need any replacing\n        // and can safe some gas\n        if (nValue.keys.length > 1) {\n            // 1. First just replace key at delete index with last array key\n            nValue.keys[rowToDelete] = nValue.keys[\n                nValue.keys.length - uint256(1)\n            ];\n            // 2. Save new array index for just replaced key in mapping\n            //nValue.keyMap[nValue.keys[nValue.keys.length - uint256(1)]]=rowToDelete;\n            nValue.keyMap[nValue.keys[rowToDelete]] = rowToDelete;\n        }\n        // 3. Remove last array key\n        nValue.keys.pop();\n        // 4. Clean mapping for deleted key\n        delete nValue.keyMap[key];\n\n        uint probe;\n        uint cursor;\n        if (nValue.keys.length == 0) {\n            if (\n                self.nodes[value].left == EMPTY ||\n                self.nodes[value].right == EMPTY\n            ) {\n                cursor = value;\n            } else {\n                cursor = self.nodes[value].right;\n                while (self.nodes[cursor].left != EMPTY) {\n                    cursor = self.nodes[cursor].left;\n                }\n            }\n            if (self.nodes[cursor].left != EMPTY) {\n                probe = self.nodes[cursor].left;\n            } else {\n                probe = self.nodes[cursor].right;\n            }\n            uint cursorParent = self.nodes[cursor].parent;\n            self.nodes[probe].parent = cursorParent;\n            if (cursorParent != EMPTY) {\n                if (cursor == self.nodes[cursorParent].left) {\n                    self.nodes[cursorParent].left = probe;\n                } else {\n                    self.nodes[cursorParent].right = probe;\n                }\n            } else {\n                self.root = probe;\n            }\n            bool doFixup = !self.nodes[cursor].red;\n            if (cursor != value) {\n                replaceParent(self, cursor, value);\n                self.nodes[cursor].left = self.nodes[value].left;\n                self.nodes[self.nodes[cursor].left].parent = cursor;\n                self.nodes[cursor].right = self.nodes[value].right;\n                self.nodes[self.nodes[cursor].right].parent = cursor;\n                self.nodes[cursor].red = self.nodes[value].red;\n                (cursor, value) = (value, cursor);\n                fixCountRecurse(self, value);\n            }\n            if (doFixup) {\n                removeFixup(self, probe);\n            }\n            fixCountRecurse(self, cursorParent);\n            delete self.nodes[cursor];\n        }\n    }\n\n    function fixCountRecurse(Tree storage self, uint value) private {\n        while (value != EMPTY) {\n            self.nodes[value].count =\n                getNodeCount(self, self.nodes[value].left) +\n                getNodeCount(self, self.nodes[value].right);\n            value = self.nodes[value].parent;\n        }\n    }\n\n    function treeMinimum(\n        Tree storage self,\n        uint value\n    ) private view returns (uint) {\n        while (self.nodes[value].left != EMPTY) {\n            value = self.nodes[value].left;\n        }\n        return value;\n    }\n\n    function treeMaximum(\n        Tree storage self,\n        uint value\n    ) private view returns (uint) {\n        while (self.nodes[value].right != EMPTY) {\n            value = self.nodes[value].right;\n        }\n        return value;\n    }\n\n    function rotateLeft(Tree storage self, uint value) private {\n        uint cursor = self.nodes[value].right;\n        uint parent = self.nodes[value].parent;\n        uint cursorLeft = self.nodes[cursor].left;\n        self.nodes[value].right = cursorLeft;\n        if (cursorLeft != EMPTY) {\n            self.nodes[cursorLeft].parent = value;\n        }\n        self.nodes[cursor].parent = parent;\n        if (parent == EMPTY) {\n            self.root = cursor;\n        } else if (value == self.nodes[parent].left) {\n            self.nodes[parent].left = cursor;\n        } else {\n            self.nodes[parent].right = cursor;\n        }\n        self.nodes[cursor].left = value;\n        self.nodes[value].parent = cursor;\n        self.nodes[value].count =\n            getNodeCount(self, self.nodes[value].left) +\n            getNodeCount(self, self.nodes[value].right);\n        self.nodes[cursor].count =\n            getNodeCount(self, self.nodes[cursor].left) +\n            getNodeCount(self, self.nodes[cursor].right);\n    }\n\n    function rotateRight(Tree storage self, uint value) private {\n        uint cursor = self.nodes[value].left;\n        uint parent = self.nodes[value].parent;\n        uint cursorRight = self.nodes[cursor].right;\n        self.nodes[value].left = cursorRight;\n        if (cursorRight != EMPTY) {\n            self.nodes[cursorRight].parent = value;\n        }\n        self.nodes[cursor].parent = parent;\n        if (parent == EMPTY) {\n            self.root = cursor;\n        } else if (value == self.nodes[parent].right) {\n            self.nodes[parent].right = cursor;\n        } else {\n            self.nodes[parent].left = cursor;\n        }\n        self.nodes[cursor].right = value;\n        self.nodes[value].parent = cursor;\n        self.nodes[value].count =\n            getNodeCount(self, self.nodes[value].left) +\n            getNodeCount(self, self.nodes[value].right);\n        self.nodes[cursor].count =\n            getNodeCount(self, self.nodes[cursor].left) +\n            getNodeCount(self, self.nodes[cursor].right);\n    }\n\n    function insertFixup(Tree storage self, uint value) private {\n        uint cursor;\n        while (value != self.root && self.nodes[self.nodes[value].parent].red) {\n            uint valueParent = self.nodes[value].parent;\n            if (\n                valueParent == self.nodes[self.nodes[valueParent].parent].left\n            ) {\n                cursor = self.nodes[self.nodes[valueParent].parent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[valueParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    value = self.nodes[valueParent].parent;\n                } else {\n                    if (value == self.nodes[valueParent].right) {\n                        value = valueParent;\n                        rotateLeft(self, value);\n                    }\n                    valueParent = self.nodes[value].parent;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    rotateRight(self, self.nodes[valueParent].parent);\n                }\n            } else {\n                cursor = self.nodes[self.nodes[valueParent].parent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[valueParent].red = false;\n                    self.nodes[cursor].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    value = self.nodes[valueParent].parent;\n                } else {\n                    if (value == self.nodes[valueParent].left) {\n                        value = valueParent;\n                        rotateRight(self, value);\n                    }\n                    valueParent = self.nodes[value].parent;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[valueParent].parent].red = true;\n                    rotateLeft(self, self.nodes[valueParent].parent);\n                }\n            }\n        }\n        self.nodes[self.root].red = false;\n    }\n\n    function replaceParent(Tree storage self, uint a, uint b) private {\n        uint bParent = self.nodes[b].parent;\n        self.nodes[a].parent = bParent;\n        if (bParent == EMPTY) {\n            self.root = a;\n        } else {\n            if (b == self.nodes[bParent].left) {\n                self.nodes[bParent].left = a;\n            } else {\n                self.nodes[bParent].right = a;\n            }\n        }\n    }\n\n    function removeFixup(Tree storage self, uint value) private {\n        uint cursor;\n        while (value != self.root && !self.nodes[value].red) {\n            uint valueParent = self.nodes[value].parent;\n            if (value == self.nodes[valueParent].left) {\n                cursor = self.nodes[valueParent].right;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[valueParent].red = true;\n                    rotateLeft(self, valueParent);\n                    cursor = self.nodes[valueParent].right;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].left].red &&\n                    !self.nodes[self.nodes[cursor].right].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    value = valueParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].right].red) {\n                        self.nodes[self.nodes[cursor].left].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateRight(self, cursor);\n                        cursor = self.nodes[valueParent].right;\n                    }\n                    self.nodes[cursor].red = self.nodes[valueParent].red;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[cursor].right].red = false;\n                    rotateLeft(self, valueParent);\n                    value = self.root;\n                }\n            } else {\n                cursor = self.nodes[valueParent].left;\n                if (self.nodes[cursor].red) {\n                    self.nodes[cursor].red = false;\n                    self.nodes[valueParent].red = true;\n                    rotateRight(self, valueParent);\n                    cursor = self.nodes[valueParent].left;\n                }\n                if (\n                    !self.nodes[self.nodes[cursor].right].red &&\n                    !self.nodes[self.nodes[cursor].left].red\n                ) {\n                    self.nodes[cursor].red = true;\n                    value = valueParent;\n                } else {\n                    if (!self.nodes[self.nodes[cursor].left].red) {\n                        self.nodes[self.nodes[cursor].right].red = false;\n                        self.nodes[cursor].red = true;\n                        rotateLeft(self, cursor);\n                        cursor = self.nodes[valueParent].left;\n                    }\n                    self.nodes[cursor].red = self.nodes[valueParent].red;\n                    self.nodes[valueParent].red = false;\n                    self.nodes[self.nodes[cursor].left].red = false;\n                    rotateRight(self, valueParent);\n                    value = self.root;\n                }\n            }\n        }\n        self.nodes[value].red = false;\n    }\n}"
    },
    "contracts/lib/Perlin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ABDKMath64x64.sol\";\n\nlibrary Perlin {\n    int16 constant vecsDenom = 1000;\n    uint16 constant perlinMax = 64;\n\n    // Perlin Noise\n    // interpolation function [0,1] -> [0,1]\n    function smoothStep(int128 x) public pure returns (int128) {\n        return x;\n    }\n\n    // returns a random unit vector\n    // implicit denominator of vecsDenom\n    function getGradientAt(\n        uint32 x,\n        uint32 y,\n        uint32 scale,\n        uint32 seed\n    ) public view returns (int16[2] memory) {\n        uint256 idx = uint256(keccak256(abi.encodePacked(x, y, scale, seed))) % 16;\n        int16[2][16] memory vecs = [\n            [int16(1000), int16(0)],\n            [int16(923), int16(382)],\n            [int16(707), int16(707)],\n            [int16(382), int16(923)],\n            [int16(0), int16(1000)],\n            [int16(-383), int16(923)],\n            [int16(-708), int16(707)],\n            [int16(-924), int16(382)],\n            [int16(-1000), int16(0)],\n            [int16(-924), int16(-383)],\n            [int16(-708), int16(-708)],\n            [int16(-383), int16(-924)],\n            [int16(-1), int16(-1000)],\n            [int16(382), int16(-924)],\n            [int16(707), int16(-708)],\n            [int16(923), int16(-383)]\n        ];\n        return vecs[idx];\n    }\n\n    // the computed perlin value at a point is a weighted average of dot products with\n    // gradient vectors at the four corners of a grid square.\n    // this isn't scaled; there's an implicit denominator of scale ** 2\n    function getWeight(\n        uint32 cornerX,\n        uint32 cornerY,\n        uint32 x,\n        uint32 y,\n        uint32 scale\n    ) public pure returns (uint64) {\n        uint64 res = 1;\n\n        if (cornerX > x) res *= (scale - (cornerX - x));\n        else res *= (scale - (x - cornerX));\n\n        if (cornerY > y) res *= (scale - (cornerY - y));\n        else res *= (scale - (y - cornerY));\n\n        return res;\n    }\n\n    function getCorners(\n        uint32 x,\n        uint32 y,\n        uint32 scale\n    ) public pure returns (uint32[2][4] memory) {\n        uint32 lowerX = (x / scale) * scale;\n        uint32 lowerY = (y / scale) * scale;\n\n        return [\n            [lowerX, lowerY],\n            [lowerX + scale, lowerY],\n            [lowerX + scale, lowerY + scale],\n            [lowerX, lowerY + scale]\n        ];\n    }\n\n    function getSingleScalePerlin(\n        uint32 x,\n        uint32 y,\n        uint32 scale,\n        uint32 seed\n    ) public view returns (int128) {\n        uint32[2][4] memory corners = getCorners(x, y, scale);\n\n        int128 resNumerator = 0;\n\n        for (uint8 i = 0; i < 4; i++) {\n            uint32[2] memory corner = corners[i];\n\n            // this has an implicit denominator of scale\n            int32[2] memory offset = [int32(x) - int32(corner[0]), int32(y) - int32(corner[1])];\n\n            // this has an implicit denominator of vecsDenom\n            int16[2] memory gradient = getGradientAt(corner[0], corner[1], scale, seed);\n\n            // this has an implicit denominator of vecsDenom * scale\n            int64 dot = offset[0] * int64(gradient[0]) + offset[1] * int64(gradient[1]);\n\n            // this has an implicit denominator of scale ** 2\n            uint64 weight = getWeight(corner[0], corner[1], x, y, scale);\n\n            // this has an implicit denominator of vecsDenom * scale ** 3\n            resNumerator += int128(int64(weight)) * int128(dot);\n        }\n\n        return\n            ABDKMath64x64.divi(int256(resNumerator), int256(vecsDenom) * int256(int32(scale))**3);\n    }\n\n    function computePerlin(\n        uint32 x,\n        uint32 y,\n        uint32 seed,\n        uint32 scale\n    ) public view returns (uint256) {\n        int128 perlin = ABDKMath64x64.fromUInt(0);\n\n        for (uint8 i = 0; i < 3; i++) {\n            int128 v = getSingleScalePerlin(x, y, scale * uint32(2**i), seed);\n            perlin = ABDKMath64x64.add(perlin, v);\n        }\n        perlin = ABDKMath64x64.add(perlin, getSingleScalePerlin(x, y, scale * uint32(2**0), seed));\n\n        perlin = ABDKMath64x64.div(perlin, ABDKMath64x64.fromUInt(4));\n        int128 perlinScaledShifted = ABDKMath64x64.add(\n            ABDKMath64x64.mul(perlin, ABDKMath64x64.fromUInt(uint256(perlinMax / 2))),\n            ABDKMath64x64.fromUInt((uint256(perlinMax / 2)))\n        );\n\n        return ABDKMath64x64.toUInt(perlinScaledShifted);\n    }\n}\n"
    },
    "contracts/placeholders/Placeholders.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../Sculpture.sol\";\n\nabstract contract PlaceholderSculpture is Sculpture {\n    function title() external pure override virtual returns (string memory) {\n        return \"Untitled (Placeholder)\";\n    }\n\n    function addresses() external view override virtual returns (address[] memory) {\n        address[] memory addresses_ = new address[](1);\n        addresses_[0] = address(0x0);\n        return addresses_;\n    }\n\n    function text() public view override virtual returns (string memory) {}\n\n    function urls() public view override virtual returns (string[] memory urls) {} // empty\n}\n\ncontract Placeholder113 is PlaceholderSculpture {\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"113\";\n        return authors_;\n    }\n}\n\ncontract Placeholderpaulseidler is PlaceholderSculpture {\n\n    function title() external pure override returns (string memory) {\n        return \"Real Abstraction (A Line Made by Proofs)\";\n    }\n\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"Paul Seidler\";\n        return authors_;\n    }\n\n    function addresses() external view override returns (address[] memory) {\n        address[] memory addresses_ = new address[](2);\n        addresses_[0] = address(0x6a7139325371a314Fe1374063869F89cB7c09D57);\n        addresses_[1] = address(0x6Fc6FC7d76db89Dd30C19Df2B05b9fF339548EC8);\n        return addresses_;\n    }\n\n    function text() public view override returns (string memory) {\n        return\n            \"Two points on a map. The beginning of a virtual plane and the end, both connected by a straight line. Suddenly structures appear - drawn by entities with addresses. The line finds its way through the emerging labyrinth of walls, it adapts, through their curves and dead ends. At some point the whole structure solidifies, becomes immutable and invisible, unknowable. Only the line remains visible, while the actual origin from which the path was calculated is buried in a cryptographic proof, indecipherable to anyone who didn't take part in its creation. The physical materiality of the mathematical cryptographic proof constitutes an unknowable underlying structure. This plane is connected to another plane that starts from the same point of origin, which is connected to another, and so on - forming a possible infinite line whose underlying exact conditions of production can never be revealed. The appearance of the line is an artefact and remains a surface phenomenon of a cryptographic but provable underlying production.\";\n    }\n}\n\ncontract Placeholder0xhaiku is PlaceholderSculpture {\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"0xhaiku\";\n        return authors_;\n    }\n\n    function title() external pure override returns (string memory) {\n        return \"Flattend Verse Protocol\";\n    }\n\n    function addresses() external view override returns (address[] memory) {\n        address[] memory addresses_ = new address[](1);\n        addresses_[0] = address(0xa964cD6fAA26bb425D13f63246Ebd7fF9ccCaBC4);\n        return addresses_;\n    }\n\n    function urls() public pure override returns (string[] memory) {\n        string[] memory urls_ = new string[](1);\n        urls_[0] = \"https://0xhaiku.com/protocol\";\n        return urls_;\n    }\n\n    function text() public view override returns (string memory) {\n        return\n            \"Technological advancements have given us overly abundant communication methods, sometimes distancing us from poetic sensibility. This artwork collaboratively generates an endless poem through a smart contract that allows only specific words defined by the artist to be input. The parent contract creates contracts with an interface accepting only specified inputs (function input(string calldata word)). Each contract has its own unique, limited dictionary, and anyone can contribute. Through blockchain, everyone has become a flat existence represented by an address. This flat chain of poetry connects people of different cultural backgrounds on an equal flat plane, building new relationships through words. Below are the created contracts. Please try linking your words.\";\n    }\n}\n\ncontract Placeholderfigure31 is PlaceholderSculpture {\n    function title() public pure override returns (string memory) {\n       return \"Dear God, Layer of Roads (Travellers)\";\n    }\n\n    function authors() public view override returns (string[] memory) {\n        string[] memory _authors = new string[](1);\n        _authors[0] = \"Loucas Braconnier (Figure31)\";\n        return _authors;\n    }\n\n    function addresses() public view override returns (address[] memory) {\n        address[] memory _addresses = new address[](1);\n        _addresses[0] = address(0);\n        return _addresses;\n    }\n\n    function urls() public view override returns (string[] memory) {}\n\n    function text() public view override returns (string memory) {\n        return string.concat(\n            unicode\"This contract is a machine that lays time. It expands beyond the boundaries of the machine on which it operates. As time unravels, travellers may use it to journey toward both the future and the past. Once on this road, their presence simultaneously generates and marks the landscape. New land is discovered with every block of time, and with each passing day, fragments of these travellers are left behind for others to bear witness.\",\n            \"<br/><br/>\",\n            unicode\"DGLR (T) is a dynamic smart contract artwork on the Ethereum Blockchain, allowing individual addresses to travel through time, represented by Ethereum Blocks. These travellers may move forward or backward in time. As they freely start and end their journeys, each block spent travelling adds a character to an endlessly long string, shaping their individual landscape. With each passing day (approximately 7000 blocks), they leave a footprint on a collective landscape, which spreads and becomes part of all other individual landscapes. The contractâs limited read functions only allow viewers to generate fragments. However, complete landscapes can be generated off-chain using the algorithm provided within the contract.\",\n            \"<br/><br/>\",\n            unicode\"This artwork creates parallels between real and virtual time, scaling alongside another perpetually expanding network. It forever pushes beyond the limited computational environment of the Ethereum blockchainâa negative space growing within a positive one. After Michael Heizer, Double Negative.\",\n            \"<br/><br/>\"\n        );\n    }\n}\n\ncontract Placeholderrheamyers is PlaceholderSculpture {\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"Rhea Myers\";\n        return authors_;\n    }\n}\n\ncontract Placeholdermaterial is PlaceholderSculpture {\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"Material\";\n        return authors_;\n    }\n\n    function text() public view override returns (string memory) {\n        return '<style>.grid{display:grid;grid-template-columns:repeat(140,6px);grid-template-rows:repeat(70,6px)}.cell{display:flex;align-items:center;justify-content:center;font-size:5px;font-weight:900; font-family: \"Courier New\", monospace;}</style><div class=grid id=grid> </div><script>const colors=[\"#f0f0f0\",\"#e0e0e0\",\"#d0d0d0\",\"#c0c0c0\",\"#b0b0b0\",\"#a0a0a0\",\"#909090\",\"#808080\",\"#707070\",\"#F0F0F0\",\"#505050\",\"#404040\",\"#303030\",\"#202020\",\"#101010\",\"#1a1a1a\"],grid=document.getElementById(\"grid\"),data=\"11111111011111111111111111111101111111111111111101111111111111111111111111111111111110110111111111111111111111111111111111111111111111111111100000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011111100000000000000000000000000000111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000011110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009990000000000000000000000000000101100000dd00000000000000000000000000000000000000dd0000000000000000000000000000000000000000000000000000000000900000000000000000000000000000010110000d0dd0000000000000000dd000000000000111100d00d0ddd00000000000000000000000000000099990000000000000000009000900000000000000000000000000010110000000d00000000dddddd00ddd0000000000ddd0000dd0ddd0dd00000000009090099090909090009009900000000000000000090000000000000000000000000090000101100000000d0000000d0000d000ddddddddd001ddd00000ddd6600d0000000990000000000000606699999900000000000000000009000000000099990000000990099000010010000000dd0000000d0000d0000d000000d0100dd000000d00060d0099690000000000000606000009606000000000000000000000000900000090009900009000900000010100000000d00000000d0000d0000d0000000d1dddd110111d11016d1916016111000000066000000009000060000000000000000009000000000990000000090009000000010110000000d00000000d000d0000d00000000dd10dd000001d00000d9060006000000000660000000009990000060000000000000000000900000900000990090009000000010010000000d0000000dd000ddddd0000000ddd1001d11111d000111d1600016100001166000000000000000909990999999999000000900000000900000900090000000000010110000000d0000000d000000000000000dd1d1110d01000d666619d16661601000116010000900000000000000000060000099900000009000009000cc9000909000000000101100000100d000000d000000000000001dd1d1110d10000d100699d160006019001619111199916616600000000000060066666990099009000090cc009009090000000000001100000000ddd0ddd100000100e0101011ddd1111d0100d0010691d106006061166999010091906001006000000000060660000999009900cccc9cc00900090c0000000000101100000000000dd000000000000ee000000d10111d000d6991060d119069699691961161019916000000066011100999660000990900009c0000990c09009000c0000000000111000000000000000000000000000e000001011dd0000d690199d0900060609600000006100991600010006011100909060000990900cc99911c0900990900000c0000000000110000000000000000000000000000e0000110d10010d090196dd0106000610906000001009609999101116111000999006166099900000990110900999000000099000000011100000000000000000000000000000e000111d00000d191960d0d6600016109006111100900601600199999991969000100060000c00009999909009900009999999000000111000000000000000000eee00000000e000111d100ddd199010dddd11110610099600109911111666666600000660099000000000c000009099999099900990000c09000000011000000000000000000e0ee0000000e000111d10dddd606000d6ddd00016000009999900000000000060616161011109000000000000000900c1999c000000000c09000000111000000000000000000e000e000000e001100ddddddd100061d6ddd001106600060010000000000000000010100000aa99aaa000c000000900c190c0990000000c09000000011000000000000000000e000ee00000e001100100ddd01111061dddd0000000666600100100000001100001000000a00000999000cc0c000900cc90c0090000000009000000111000000000000000000e0010ee1100e0011100006010000006660d0000100000000010000000000aa01110000a00000000000099c000cc0900090000090000000c09000000111000000000000000001ee00000e000e00011ee0e6000000001000dd660dddd0000001000000000a101a0a10a000000000000000c90000c900090000099c000000c9900000001100000000000000001000e00000e0e000e1e10600e0e000061ee0edddddd0d000000011100001a000000010a000000000aaa000cc9000c90090000cc900c0000099000000011100000000000000100000ee00001eeeeee10110a0aa0eee0e000060000e0dd0000aaaaa000001a1000000aa00000000aa000a0c0099cc90099c000c99000c00999000000000110000000000000100000000eeeee1ee0000eea6e0e0e000e1000660006e0000600a000a0000100a0aaaaa010000a0a0000000ac0009990009ccc0099099999900c00000000011000000000001000000000000000e0000a0ae6100010a066ee0660000ee1000066aa001a001000aa000a0aaaaaa0000000000ac1119910c9000cc99c9cc00000c00000000001100000000000100000000000a0ae1a0a0000e61000166660660eeee0e0610000006a09a1100000aaaaa0010000aaaa0000011acc999ccc09000cc99900c000c0c0000000000110000000000100000000000000e000000000eaa1aaa6aaa01666000000661000006aaaa09900a0001000100a0aa10a1001110a0990901c9900c9999cfcc0000c010001000001100000000001000000000000e00100001000ea1110660a1a6a1aa0a1000661000a0aaa00100a0000000010a00a10001111000a0909900990099100cff00000cc000000000001100000000010000000000ee0000000000000e61110666a6610006000a1a0a60a66090001a0a09000101100a00a0111a100000a09990009999cc010fff0000c0c0000000000011000011000100000000ee000000eeee00000aa666010a6001000600000001166600090010aa0900110001a000a000aaa0a111a0000000900c00000ff0c0cc00000000000000110001000010000eeeee0000000e000ee00000ea11000aa0100006100aa001000000009100a00a9110000a0000a0aa001110a1a000000000c0000fff00001000c000000000001100010000100ee000000000000e00000e0000e11a0aaa001a0aaa0aacaa0001000000100a00011aa00aaaa0a0aa00001100a1a000000c0c000f00cf0000001000000000000001001000001ee0000000000000e111010ee0001e110000aa0aaaaaaaaaaaaaaaaa01100000900900010a00000aaa000011000aa00000000c000000c0ff00000c01000000000011000000001e10000000000011e00000001e0001e01000011000060000c0aaaaaa0000000aa00100011a00aaaa0a00000a00aa0000000c0c00000c00000ff0000001000000000100000000e00011010111010e1100000000e011ee0001100000600000c000c10000000009a9010a0a1aa000000a0011aa1a1aaaaa00000cccc0c00000000ffc0000000000001110000000e00000000000100e0000010010ee0111ee1e8801116000001cc1c100009909000000100001a000000a010aa0aaaa101aaa10c0000000000000000f0000000010001100000000e10000000001000e10000000000000101800ee000180101111c0cc110910010018808800101a0111aa00a01aaa0a00aaaa01cc00000000000000cf0000000000001100000000e1000eee1100000e1000880000000e108011008eeeee1810000c1c0090000008000000811000a0aa000a11aa0a0a000a001000000000000000000f0000000000000100000000e01eee1ee000000e08800800000000ee1000110068cceeec00cc10091111101900000080010111010010a0aaaa0a0000001000c0000000000000cf00000000000011000000000e0e0000e000008e1000080100008108ee00001860cc10eeec10011100000809110000080000000000a0a00a000a00aa0010000c0000000000c000000000000000110000000000ee0000e000000e1000108000880088686ee660880c18881eeeee0900008000091000000000000000a000a0a00a0a0001a000000c0000000c0000f00000000000111000000000ee0eee0000008e000000880080080010686e0e8801cccc000100ee000000000001900800000000000a000a0aaa000010000a0000c0cfc0000000f00000000000100001000000e000000000000e10010000800008008888010cce00000c00000001e0080000000001980000000000aa0000a00a01aaaaa0fa00000ffff000000f000000000000100000000100e000000001000e8100080800808000800080c008e0000c00000000e080000000100081010110110a0a0001108800a000ffff010ff0000111000f0000010000001100000000010e10000800000e080000000008800000800c1800c0e000c00000000e100000000000800000000011a10010088000a010fa0f0fff0000f01000ff0000000000001100000000000ee000008800e0088000000008880000088c000008c000c00000008e9100990000008000000000a11aaaa08000000a00fffff0000000f0000ff000000000000011000000000000e0e000000e08081010000881000cc00cc00010008088000090080e0011009000209800000000000000a80000e00a0100000fffffffff0fff1000000000000011000000000000000eeeee00000088111881000cc00cc00055001100e0080808900e0001002900200800000a00000008aa0000e00a00000100000000f010000000000000000011000000000000000000000000000008800000000000000509590091e00009000000000100090020aa0a000000000080a00000e0000e000000eeeee1f0000000000000000000110000000000000000000000000000000100000c000050509000000911009000900e00100a00a02000888000000880aa000000eaa0eee0ee0ee01000f0000000000000000000110000000000000000000000550500000155505505500000900055090e11910991e005505a9000200000080888001aa01000eae100e1e0e0ee001000f0000000000000000000110000000000000000000005000050000500000000000010090000950ee0900900e550000900a0200000000100002a22200ae0e00ee0ee000f010000f0000000000000000000110000000000000000000050000005000501000c000000110090090050e090009e500009000000200000000000220aaa2aa100e00e000e0f00000000f0000100000000000000110000001000000000000000000005000000000c0000000100000900000e5e0ee909900000000002000000022000000002aae00ee0ff00f00000000f0000100000000000000011000001110000500000005000000500005001100000000100090090909090000000000000000aaa222222a0000a0000022ae01eef0fff101001000f0010000000000000000011000001010000000000050000005000005050c00110000100000000000000000000000000aa000a00000a00a0aa0022002ae0000f00ff000000001f1000001100100000000001000000110000050000050000000000001105100011010000009000000000000000000000000000a0000a0222a22220200ae10000fffff000000ff00000e0000000000000001100000000000000000005000005500000000050000000000000000000000000000000000aa000a0a0000aa022a02222222ae200001000f0ffffff010000e0000000000000001100000000000000500005000000000000000055000000000000900000000000000000000a000000aa0000aa0aa2c2220aaae200eeeee00000000000000ee0000010000000001100000000000000555500000000550090005500000000000009000000000000000000011aa000000aaaa0aaaaaaccc00aa0e000e000e00000000000100e0000000000000000110000000000000000000000000000050550900000009009000000000000000000000000000000000000000000aaaaaaaaa0e000e000e0000000000000ee0000100000000000110000000000000000000000000000000000000090000000000000000000000000000000000a0000000000000000ccca0000ee00ee0e00000000eeeeeee0000000000000000011000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000eeeeeeeeeeeeeeee000000000000000000000001100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000011100000000000000000000000000000001111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111110111101111111101111111111111111111111111111111011111111111110111110111101110111100110101101111101010110101111011101111111011111111111111\";data.match(/[0-9a-z]/gi).map((e=>{const a=parseInt(e,16),t=document.createElement(\"div\");t.className=\"cell\",t.style.color=colors[a],t.textContent=a,grid.appendChild(t)}))</script>';\n    }\n}\n\ncontract Placeholdersarahfriend is PlaceholderSculpture {\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"Sarah Friend\";\n        return authors_;\n    }\n\n    function text() public view override returns (string memory) {\n        return \"This is an example sculpture that is static.\";\n    }\n}\n"
    },
    "contracts/placeholders/Travel.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"solady/src/utils/LibString.sol\";\nimport \"../Sculpture.sol\";\nimport \"../lib/Perlin.sol\";\n\ncontract Travel is Sculpture {\n\n    function title() public view override returns (string memory) {\n       return \"Dear God, Layer of Roads (Travellers)\";\n    }\n\n    function authors() public view override returns (string[] memory) {\n        string[] memory _authors = new string[](1);\n        _authors[0] = \"Loucas Braconnier (Figure31)\";\n        return _authors;\n    }\n\n    function addresses() public view override returns (address[] memory) {\n        address[] memory _addresses = new address[](1);\n        _addresses[0] = address(this);\n        return _addresses;\n    }\n\n    function urls() public view override returns (string[] memory) {}\n\n    function text() public view override returns (string memory) {\n        Journey memory journey = journeys[1];\n        uint256 count = block.number - uint(int(journey.fromBlock)) > 80 ? 80 : block.number - uint(int(journey.fromBlock));\n        uint256 offset = block.number - uint(int(journey.fromBlock)) - count;\n        return string.concat(\n            unicode\"This contract is a machine that lays time. It expands beyond the boundaries of the machine on which it operates. As time unravels, travellers may use it to journey toward both the future and the past. Once on this road, their presence simultaneously generates and marks the landscape. New land is discovered with every block of time, and with each passing day, fragments of these travellers are left behind for others to bear witness.\",\n            \"<br/><br/><br/>\",\n            landscape(1, offset, count)\n        );\n    }\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    struct Journey {\n        int48 fromBlock;\n        int48 toBlock;\n        bool forward;\n        bool active;\n        uint48 previousIndex; // index of the previous journey\n        address traveller;\n    }\n    mapping(uint256 => Journey) public journeys;\n    uint256 public journeyCount;\n    uint256 public journeyCompletedCount;\n    mapping(address => uint256) travellerCurrentJourney;\n\n    constructor() {\n        _begin(address(this), true);\n    }\n\n    function begin() public {\n        _begin(msg.sender, true);\n    }\n\n    function begin(address traveller) public {\n        _begin(traveller, true);\n    }\n\n    function begin(bool direction) public {\n        _begin(msg.sender, direction);\n    }\n\n    function _begin(address traveller, bool direction) internal {\n        uint256 currentJourneyIndex = travellerCurrentJourney[traveller];\n        Journey memory currentJourney = journeys[currentJourneyIndex];\n        require(currentJourney.active == false, \"You already have an active journey\");\n        journeyCount++;\n        Journey memory newJourney = Journey({\n            fromBlock: int48(int(block.number)),\n            toBlock: 0,\n            forward: direction,\n            active: true,\n            previousIndex: uint48(currentJourneyIndex),\n            traveller: traveller\n        });\n        journeys[journeyCount] = newJourney;\n        travellerCurrentJourney[traveller] = journeyCount;\n    }\n\n    function end() public {\n        uint256 currentJourneyIndex = travellerCurrentJourney[msg.sender];\n        Journey memory currentJourney = journeys[currentJourneyIndex];\n        require(currentJourney.active == true, \"You don't have an active journey\");\n        journeys[currentJourneyIndex].toBlock = int48(int(block.number));\n        journeys[currentJourneyIndex].active = false;\n        journeyCompletedCount++;\n    }\n\n    function howFarHaveICome() public view returns (int) {\n        uint256 currentJourneyIndex = travellerCurrentJourney[msg.sender];\n        Journey memory currentJourney = journeys[currentJourneyIndex];\n        require(currentJourney.active == true, \"You don't have an active journey\");\n        return int(block.number) - currentJourney.fromBlock;\n    }\n\n    function whereAmI() public view returns (int) {\n        uint256 currentJourneyIndex = travellerCurrentJourney[msg.sender];\n        Journey memory currentJourney = journeys[currentJourneyIndex];\n        require(currentJourney.active == true, \"You don't have an active journey\");\n        if (currentJourney.forward) {\n            return int(block.number);\n        } else {\n            return currentJourney.fromBlock - int48(int(block.number) - currentJourney.fromBlock);\n        }\n    }\n\n    function landscape(uint256 index, uint256 offset, uint256 limit) public view returns (string memory) {\n        Journey memory journey = journeys[index];\n        uint256 seed = uint256(uint160(journey.traveller)) + index; // later this might be prevrandao of end block\n        require(index > 0 && index <= journeyCount, \"Invalid journey index\");\n\n        string memory ls; // = LibString.toString(index);\n        string[4] memory characters = [\"_\", \"-\", unicode\"Â¯\", unicode\"Ë\"];\n\n        int48 _fromBlock = journey.fromBlock;\n        int48 _toBlock = journey.forward ? (journey.active ? int48(int(block.number)) : journey.toBlock) : journey.fromBlock - ((journey.active ? int48(int(block.number)) : journey.toBlock) - journey.fromBlock);\n\n        uint256 counter = offset;\n\n        while (true) {\n            uint32 _x = journey.forward ? uint32(uint256(int(_fromBlock + int(counter))) % uint256(type(uint32).max)) : uint32(uint256(int(_fromBlock - int(counter))) % uint256(type(uint32).max));\n\n            uint256 height = Perlin.computePerlin(_x, uint32(index), uint32(seed), 64);\n            // Estimated Practical range between 16 and 48 (0-64 is the theoretical range)\n            // Put a ceiling on the height\n            height = height > 43 ? 43 : height;\n            // Lower the range by 16 (0-27)\n            height = height > 16 ? height - 16 : 0;\n            // Lower the range to raise the floor and create more flat lands\n            // resulting in a final range of 0 to 16\n            height = height > 11 ? height - 11 : 0;\n\n            ls = string.concat(ls, characters[((height) * characters.length / 16) % characters.length]);\n\n            counter++;\n\n            if (\n                (journey.forward && (uint256(int(_fromBlock)) + counter > uint256(int(_toBlock)) || counter > offset + limit))\n                || (!journey.forward && (_fromBlock - int(counter) < _toBlock || counter > offset + limit))\n            ) {\n                break;\n            }\n        }\n\n        return ls;\n    }\n\n}\n\n"
    },
    "contracts/s/S.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface S {\n    function sign(address who, address recipient) external payable;\n}"
    },
    "contracts/s/SI.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./S.sol\";\n\ncontract SI {\n    address immutable public sp;\n\n    constructor(address _sp) {\n        sp = _sp;\n    }\n\n    receive() external payable {\n        S(sp).sign(msg.sender, address(this));\n    }\n}"
    },
    "contracts/s/SP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract SP {\n    event Signed(address indexed who, address indexed recepient, uint256 value);\n\n    uint256 public registrationCount;\n    mapping(address => uint256) public registeredAddressIndex;\n    mapping(address => uint256) public contributionsReceivedByAddress;\n    mapping(address => uint256) public contributionsMadeByAddress;\n\n    address immutable public origin;\n\n    constructor() {\n        origin = msg.sender;\n        _register(address(this));\n    }\n\n    function sign(address _who, address _recipient) public payable {\n        // Register Recipient\n        if (registeredAddressIndex[_recipient] == 0) {\n            _register(_who);\n        }\n\n        // Track contributions\n        contributionsMadeByAddress[_who] += msg.value;\n        contributionsReceivedByAddress[_recipient] += msg.value;\n\n        // Forward contribution\n        (bool success, ) = _recipient.call{value: msg.value}(\"\");\n        require(success, \"Failed to sign\");\n\n        // Emit Signed Event\n        emit Signed(_who, _recipient, msg.value);\n    }\n\n    function _register(address _contract) internal {\n        registrationCount++; // Start at 1\n        registeredAddressIndex[_contract] = registrationCount;\n    }\n\n    receive() external payable {\n        sign(msg.sender, address(this));\n    }\n}"
    },
    "contracts/s/ST.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"solady/src/auth/Ownable.sol\";\nimport \"../lib/HitchensOrderStatisticsTreeLib.sol\";\nimport \"./S.sol\";\n\ncontract ST is Ownable {\n    address immutable public sp;\n\n    using HitchensOrderStatisticsTreeLib for HitchensOrderStatisticsTreeLib.Tree;\n    HitchensOrderStatisticsTreeLib.Tree tree;\n\n    uint public totalContributions;\n    mapping(address => uint) public contributions;\n\n    constructor(address _sp, address _owner) {\n        sp = _sp;\n        _initializeOwner(_owner);\n    }\n\n    receive() external payable {\n        if (msg.sender == sp) {\n            return;\n        }\n        S(sp).sign(msg.sender, address(this));\n        uint prevContribution = contributions[msg.sender];\n        bytes32 key = bytes32(uint(uint160(msg.sender)));\n        if (prevContribution > 0 && tree.keyExists(key, prevContribution)) {\n            tree.remove(key, prevContribution);\n        }\n        tree.insert(key, prevContribution + msg.value);\n        contributions[msg.sender] = prevContribution + msg.value;\n        totalContributions += msg.value;\n    }\n\n    function topContributors(uint limit) public view returns (address[] memory contributors, uint[] memory contribs) {\n        if (tree.count() == 0) {\n            return (contributors, contribs);\n        }\n        uint top = tree.count() < limit ? tree.count() : limit;\n        contributors = new address[](top);\n        contribs = new uint[](top);\n        uint count = 0;\n        uint value = tree.atRank(tree.count()); // 1 is lowest rank, count() is highest rank\n        while (value != 0 && count < top) {\n            HitchensOrderStatisticsTreeLib.Node storage node = tree.getNode2(value);\n            uint keyCount = node.keys.length;\n            while (keyCount > 0) {\n                keyCount--;\n                address addr = address(uint160(uint(node.keys[keyCount])));\n                contributors[count] = addr;\n                contribs[count] = value;\n                count++;\n                if (count >= top) {\n                    break;\n                }\n            }\n            value = tree.prev(value);\n        }\n    }\n\n    function withdraw(address _to) public onlyOwner() {\n        (bool success, ) = _to.call{value: address(this).balance}(\"\");\n        require(success, \"Failed to withdraw\");\n    }\n\n    function treeFirstValue() public view returns (uint _value) {\n        _value = tree.first();\n    }\n    function treeLastValue() public view returns (uint _value) {\n        _value = tree.last();\n    }\n    function treeNextValue(uint value) public view returns (uint _value) {\n        _value = tree.next(value);\n    }\n    function treePrevValue(uint value) public view returns (uint _value) {\n        _value = tree.prev(value);\n    }\n    function treeValueExists(uint value) public view returns (bool _exists) {\n        _exists = tree.exists(value);\n    }\n    function treeKeyValueExists(bytes32 key, uint value) public view returns(bool _exists) {\n        _exists = tree.keyExists(key, value);\n    }\n    function treeGetNode(uint value) public view returns (uint _parent, uint _left, uint _right, bool _red, uint _keyCount, uint _count) {\n        (_parent, _left, _right, _red, _keyCount, _count) = tree.getNode(value);\n    }\n    function treeGetValueKey(uint value, uint row) public view returns(bytes32 _key) {\n        _key = tree.valueKeyAtIndex(value,row);\n    }\n    function treeValueKeyCount() public view returns(uint _count) {\n        _count = tree.count();\n    }\n    function treeValuePercentile(uint value) public view returns(uint _percentile) {\n        _percentile = tree.percentile(value);\n    }\n    function treeValuePermil(uint value) public view returns(uint _permil) {\n        _permil = tree.permil(value);\n    }\n    function treeValueAtPercentile(uint _percentile) public view returns(uint _value) {\n        _value = tree.atPercentile(_percentile);\n    }\n    function treeValueAtPermil(uint value) public view returns(uint _value) {\n        _value = tree.atPermil(value);\n    }\n    function treeMedianValue() public view returns(uint _value) {\n        return tree.median();\n    }\n    function treeValueRank(uint value) public view returns(uint _rank) {\n        _rank = tree.rank(value);\n    }\n    function treeValuesBelow(uint value) public view returns(uint _below) {\n        _below = tree.below(value);\n    }\n    function treeValuesAbove(uint value) public view returns(uint _above) {\n        _above = tree.above(value);\n    }\n    function treeValueAtRank(uint _rank) public view returns(uint _value) {\n        _value = tree.atRank(_rank);\n    }\n}"
    },
    "contracts/Sculpture.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\ninterface Sculpture {\n\n    function title() external view returns (string memory);\n\n    function authors() external view returns (string[] memory);\n\n    function addresses() external view returns (address[] memory);\n\n    function urls() external view returns (string[] memory);\n\n    function text() external view returns (string memory);\n\n}\n"
    },
    "contracts/ShowCritique.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Show Critique.\n// By Rhea Myers.\n// Copyright 2024 Myers Studio Ltd.\npragma solidity >=0.8.0;\n\nimport \"solady/src/auth/Ownable.sol\";\nimport \"solady/src/utils/LibString.sol\";\nimport \"./Sculpture.sol\";\nimport \"./Garden.sol\";\n\ncontract ShowCritique is Sculpture, Ownable {\n\n    struct Critique {\n        address critic;\n        uint8 critique;\n    }\n\n    uint256 private constant OPINIONS_COUNT = 16;\n\n    string[OPINIONS_COUNT] private OPINIONS = [\n        \"totally awesome\",\n        \"entirely excellent\",\n        \"transcendently fascinating\",\n        \"completely intriguing\",\n        \"deeply moving\",\n        \"profoundly affecting\",\n        \"groundbreaking\",\n        \"so cute\",\n        \"totes adorbs\",\n        \"strikingly profound\",\n        \"triumphantly skilful\",\n        \"a revelation\",\n        \"unignorably brilliant\",\n        \"thought provoking\",\n        \"intellectually stimulating\",\n        \"visually stimulating\"\n    ];\n\n    mapping(address => Critique) private critiques;\n    address payable private gardenAddress;\n\n    constructor () {\n        _initializeOwner(msg.sender);\n    }\n\n    function configure (address payable newGardenAddress) external onlyOwner {\n        gardenAddress = newGardenAddress;\n        Garden garden = Garden(gardenAddress);\n        address critic = msg.sender;\n        address[] memory works = garden.getSculptures();\n        for (uint256 i = 0; i < works.length; i++) {\n            if (critiques[works[i]].critic == address(0x0)) {\n                critiques[works[i]] = Critique(\n                    critic,\n                    uint8(i % OPINIONS_COUNT)\n                );\n            }\n        }\n    }\n\n    function critiqueWork (uint256 workIndex, address workAddress, uint8 critique) external {\n        Garden garden = Garden(gardenAddress);\n        require(\n            garden.getSculptures()[workIndex] == workAddress,\n            \"invalid work (was the garden changed?)\"\n        );\n        require(\n            critique < OPINIONS_COUNT,\n            \"invalid critical opinion (indices start at zero)\"\n        );\n        critiques[workAddress] = Critique(\n            msg.sender,\n            critique\n        );\n    }\n\n    function formatOpinion (address workAddress) internal view returns (string memory) {\n        Sculpture work = Sculpture(workAddress);\n        Critique memory critique = critiques[workAddress];\n        return string.concat(\n            \"<p>\",\n            LibString.toHexStringChecksummed(critique.critic),\n            \" thinks that <i><span style=\\\"white-space: nowrap;\\\">\",\n            work.title(),\n            \"</span></i> <span style=\\\"white-space: nowrap;\\\">by \",\n            work.authors()[0],\n            \"</span> is <span style=\\\"white-space: nowrap;\\\">\",\n            OPINIONS[critique.critique],\n            \".</span></p>\\n\"\n        );\n    }\n\n    function formatOpinions () internal view returns (string memory) {\n        Garden garden = Garden(gardenAddress);\n        address[] memory sculptureAddresses = garden.getSculptures();\n        string memory opinions = \"\";\n        for (uint256 i = 0; i < sculptureAddresses.length; i++) {\n            address workAddress = sculptureAddresses[i];\n            Critique storage critique = critiques[workAddress];\n            if (critique.critic != address(0x0))\n                opinions = string.concat(\n                    opinions,\n                    formatOpinion(workAddress)\n                );\n        }\n        return opinions;\n    }\n\n    function title() external view override returns (string memory) {\n        // This title is dynamic and always shows the current block timestamp\n        return string.concat(\"Critique of This Show\");\n    }\n\n    function authors() external view override returns (string[] memory) {\n        string[] memory authors_ = new string[](1);\n        authors_[0] = \"Rhea Myers et al.\";\n        return authors_;\n    }\n\n    function addresses() external view override returns (address[] memory) {\n        address[] memory addresses_ = new address[](1);\n        // this too, could be dynamic or change over time\n        addresses_[0] = address(this);\n        return addresses_;\n    }\n\n    function text() public view override returns (string memory) {\n        return formatOpinions();\n    }\n\n    function urls() public view override returns (string[] memory) {} // empty\n}\n"
    },
    "contracts/Web.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0;\n\nimport \"solady/src/auth/Ownable.sol\";\nimport \"solady/src/utils/LibString.sol\";\nimport \"./Sculpture.sol\";\n\ninterface IGarden {\n    function getContribution(uint256 index) external view returns (address contributor, uint256 amount);\n    function getContributed() external view returns (uint256);\n    function getSculptures() external view returns (address[] memory);\n}\n\ninterface IWeb {\n    function html() external view returns (string memory);\n}\n\ncontract Web is IWeb, Ownable {\n    address public garden;\n    address public renderer;\n\n    constructor() {\n        _initializeOwner(msg.sender);\n    }\n\n    function html() external view returns (string memory) {\n        return ShowRenderer(renderer).html();\n    }\n\n    function setRenderer(address _renderer) public onlyOwner {\n        renderer = _renderer;\n    }\n}\n\ncontract ShowRenderer {\n\n    address immutable public garden;\n\n    constructor(address _garden) {\n        garden = _garden;\n    }\n\n    function _html(string memory body) internal view returns (string memory) {\n        string memory html = \"<html>\";\n        html = string.concat(html,\n            '<head>',\n            '<meta charset=\"UTF-8\">',\n            '<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">',\n            '<title>', Sculpture(garden).title() ,'</title>',\n            '</head>',\n            \"<style>\",\n            '*, *::before, *::after { box-sizing: border-box; }',\n            'html { -moz-text-size-adjust: none; -webkit-text-size-adjust: none; text-size-adjust: none; }',\n            'html, body { margin: 0; padding: 0; } body { min-height: 100vh }',\n            'html,body,pre { font-family: \"Courier New\", \"Courier\", monospace; font-size: 15px; }',\n            'h1,h2,h3 { margin: 0; font-size: inherit; font-style: inherit; font-weight: inherit;}',\n            \".c { max-width: 840px; margin: 0 auto; padding: 0 1.5em; box-sizing: content-box; }\",\n            \"a { color: inherit; text-decoration: underline; }\",\n            \".w { min-height: 100vh; display: flex; align-items: center; padding: 10em 0; }\",\n            \".s { width: 100%; max-width: 840px; }\",\n            \".s:not(.g) a { max-width: 100%; display: inline-block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }\",\n            \".t { max-width: 100%; overflow-x: auto; margin: 1em 0; }\",\n            \".i { margin: 50vh 0 5em; }\",\n            \"</style>\"\n        );\n        html = string.concat(html, \"<body>\", body, \"</body></html>\");\n        return html;\n    }\n\n    function html() public view returns (string memory html) {\n        address[] memory sculptures = IGarden(garden).getSculptures();\n        html = string.concat(html,\n            '<div class=\"c\">',\n            '<div class=\"w\"><div class=\"s g\">',\n            '<pre class=\"garden\">',\n            unicode\"       â                    â\\n\",\n            unicode\"             â\\n\",\n            unicode\"â                       â         â\\n\",\n            unicode\"        â         â\\n\",\n            unicode\"   â                          â\\n\",\n            unicode\"</pre>\",\n            '<br /><br />',\n            unicode\"<h1>\", Sculpture(garden).title(), \"</h1>\\n\",\n            '<br /><br />'\n        );\n        for (uint256 i = 0; i < sculptures.length; i++) {\n            string[] memory authors = Sculpture(sculptures[i]).authors();\n            // Temporary: For now we just use the first author here\n            if (authors.length > 0) {\n                html = string.concat(html, authors[0], \"<br/>\");\n            }\n        }\n        html = string.concat(html,\n            '<br /><br />',\n            '<pre class=\"garden\">',\n            unicode\"      â                      â\\n\",\n            unicode\"              â\\n\",\n            unicode\" â                     â         â\\n\",\n            unicode\"          â      â\\n\",\n            unicode\"     â                     â\\n\",\n            unicode\"</pre>\",\n            '<br />',\n            '<p>',\n            'A contract show organized by ',\n            '<a href=\"https://0xfff.love\" target=\"_blank\" rel=\"noopener noreferrer\">0xfff</a><br />',\n            'with special thanks to ',\n            '<a href=\"https://x.com/sssluke1\" target=\"_blank\" rel=\"noopener noreferrer\">sssluke</a> and <a href=\"https://x.com/0x113d\" rel=\"noopener noreferrer\" target=\"_blank\">113</a>',\n            \"</p>\",\n            '<br /><br />'\n        );\n\n        html = string.concat(\n            html,\n            \"<br />\",\n            \"</div></div>\"\n        );\n\n        for (uint256 i = 0; i < sculptures.length; i++) {\n            Sculpture sculpture = Sculpture(sculptures[i]);\n            string memory title = sculpture.title();\n            html = string.concat(html, '<div class=\"w\"><div class=\"s\">');\n            string[] memory authors = sculpture.authors();\n            if (authors.length > 0) {\n                html = string.concat(html, \"<h2>\");\n                for (uint256 j = 0; j < authors.length; j++) {\n                    if (bytes(authors[j]).length == 0) continue; // ignore empty\n                    html = string.concat(html, authors[j], \"<br/>\");\n                }\n                html = string.concat(html, \"</h2>\");\n            }\n            if (bytes(title).length > 0) {\n                html = string.concat(html, \"<h3><i>\", title, \"</i></h3>\");\n            } else {\n                html = string.concat(html, \"<h3><i>\", \"Untitled\", \"</i></h3>\");\n            }\n            address[] memory addresses = sculpture.addresses();\n            if (addresses.length > 0) {\n                html = string.concat(html, \"<p>\");\n                for (uint256 j = 0; j < addresses.length; j++) {\n                    html = string.concat(html, LibString.toHexString(addresses[j]), \"<br/>\");\n                }\n                html = string.concat(html, \"</p>\");\n            }\n            string[] memory urls = sculpture.urls();\n            if (urls.length > 0) {\n                html = string.concat(html, \"<p>\");\n                for (uint256 j = 0; j < urls.length; j++) {\n                    if (bytes(urls[j]).length == 0) continue; // ignore empty\n                    html = string.concat(html, renderUrl(urls[j]), \"<br/>\");\n                }\n                html = string.concat(html, \"</p>\");\n            }\n            string memory text = sculpture.text();\n            if (bytes(text).length > 0) {\n                html = string.concat(html, '<div class=\"t\">', text, '</div>');\n            }\n            html = string.concat(html, \"</div></div>\");\n        }\n        // uint contributed = GardenContributions(garden).getContributed();\n        // for (uint256 i = 0; i < contributed; i++) {\n        //     html = string(abi.encodePacked(html, \"<li>\", GardenContributions(garden).getContribution(i), \"</li>\"));\n        // }\n        html = string.concat(html, '<div class=\"i\">Generated at block ', LibString.toString(block.number), \" (\", LibString.toString(block.timestamp), \")</div>\");\n        html = string.concat(html, \"</div>\");\n\n        return _html(html);\n    }\n\n\n    function stripURL(string memory url) internal pure returns (string memory) {\n        bytes memory urlBytes = bytes(url);\n        uint256 length = urlBytes.length;\n        uint256 start = 0;\n        uint256 end = length;\n\n        // Find the position of \"://\", which indicates the end of the protocol\n        for (uint256 i = 0; i < length - 2; i++) {\n            if (urlBytes[i] == \":\" && urlBytes[i + 1] == \"/\" && urlBytes[i + 2] == \"/\") {\n                start = i + 3; // Skip the \"://\"max\n                break;\n            }\n        }\n\n        // Find position of \"?\" or \"#\" to determine the end of the main URL\n        for (uint256 i = start; i < length; i++) {\n            if (urlBytes[i] == \"?\" || urlBytes[i] == \"#\") {\n                end = i;\n                break;\n            }\n        }\n\n        // Remove trailing slash if present\n        if (end > start && urlBytes[end - 1] == \"/\") {\n            end -= 1;\n        }\n\n        // Create a new byte array to store the stripped URL\n        bytes memory strippedUrlBytes = new bytes(end - start);\n        for (uint256 i = start; i < end; i++) {\n            strippedUrlBytes[i - start] = urlBytes[i];\n        }\n\n        return string(strippedUrlBytes);\n    }\n\n    function renderUrl(string memory url) internal pure returns (string memory) {\n        string memory strippedUrl = stripURL(url);\n        return string.concat('<a href=\"', url, '\" target=\"_blank\" rel=\"noopener noreferrer\">', strippedUrl ,'</a>');\n    }\n\n\n}"
    },
    "solady/src/auth/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Simple single owner authorization mixin.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\n///\n/// @dev Note:\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\n///\n/// While the ownable portion follows\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\nabstract contract Ownable {\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                       CUSTOM ERRORS                        */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev The caller is not authorized to call the function.\n    error Unauthorized();\n\n    /// @dev The `newOwner` cannot be the zero address.\n    error NewOwnerIsZeroAddress();\n\n    /// @dev The `pendingOwner` does not have a valid handover request.\n    error NoHandoverRequest();\n\n    /// @dev Cannot double-initialize.\n    error AlreadyInitialized();\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                           EVENTS                           */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\n    /// despite it not being as lightweight as a single argument event.\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\n\n    /// @dev An ownership handover to `pendingOwner` has been requested.\n    event OwnershipHandoverRequested(address indexed pendingOwner);\n\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\n\n    /// @dev `keccak256(bytes(\"OwnershipTransferred(address,address)\"))`.\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverRequested(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\n\n    /// @dev `keccak256(bytes(\"OwnershipHandoverCanceled(address)\"))`.\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                          STORAGE                           */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev The owner slot is given by:\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\"_OWNER_SLOT_NOT\")))))`.\n    /// It is intentionally chosen to be a high value\n    /// to avoid collision with lower slots.\n    /// The choice of manual storage layout is to enable compatibility\n    /// with both regular and upgradeable contracts.\n    bytes32 internal constant _OWNER_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\n\n    /// The ownership handover slot of `newOwner` is given by:\n    /// ```\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\n    ///     let handoverSlot := keccak256(0x00, 0x20)\n    /// ```\n    /// It stores the expiry timestamp of the two-step ownership handover.\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                     INTERNAL FUNCTIONS                     */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\n\n    /// @dev Initializes the owner directly without authorization guard.\n    /// This function must be called upon initialization,\n    /// regardless of whether the contract is upgradeable or not.\n    /// This is to enable generalization to both regular and upgradeable contracts,\n    /// and to save gas in case the initial owner is not the caller.\n    /// For performance reasons, this function will not check if there\n    /// is an existing owner.\n    function _initializeOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                if sload(ownerSlot) {\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\n                    revert(0x1c, 0x04)\n                }\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Store the new value.\n                sstore(_OWNER_SLOT, newOwner)\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\n            }\n        }\n    }\n\n    /// @dev Sets the owner directly without authorization guard.\n    function _setOwner(address newOwner) internal virtual {\n        if (_guardInitializeOwner()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let ownerSlot := _OWNER_SLOT\n                // Clean the upper 96 bits.\n                newOwner := shr(96, shl(96, newOwner))\n                // Emit the {OwnershipTransferred} event.\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\n                // Store the new value.\n                sstore(ownerSlot, newOwner)\n            }\n        }\n    }\n\n    /// @dev Throws if the sender is not the owner.\n    function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }\n\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\n    /// Override to return a different value if needed.\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\n        return 48 * 3600;\n    }\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }\n\n    /// @dev Allows the owner to renounce their ownership.\n    function renounceOwnership() public payable virtual onlyOwner {\n        _setOwner(address(0));\n    }\n\n    /// @dev Request a two-step ownership handover to the caller.\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\n    function requestOwnershipHandover() public payable virtual {\n        unchecked {\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Compute and set the handover slot to `expires`.\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\n                mstore(0x00, caller())\n                sstore(keccak256(0x0c, 0x20), expires)\n                // Emit the {OwnershipHandoverRequested} event.\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\n            }\n        }\n    }\n\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\n    function cancelOwnershipHandover() public payable virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, caller())\n            sstore(keccak256(0x0c, 0x20), 0)\n            // Emit the {OwnershipHandoverCanceled} event.\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\n        }\n    }\n\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and set the handover slot to 0.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            let handoverSlot := keccak256(0x0c, 0x20)\n            // If the handover does not exist, or has expired.\n            if gt(timestamp(), sload(handoverSlot)) {\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\n                revert(0x1c, 0x04)\n            }\n            // Set the handover slot to 0.\n            sstore(handoverSlot, 0)\n        }\n        _setOwner(pendingOwner);\n    }\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                   PUBLIC READ FUNCTIONS                    */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev Returns the owner of the contract.\n    function owner() public view virtual returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_OWNER_SLOT)\n        }\n    }\n\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\n    function ownershipHandoverExpiresAt(address pendingOwner)\n        public\n        view\n        virtual\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the handover slot.\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\n            mstore(0x00, pendingOwner)\n            // Load the handover slot.\n            result := sload(keccak256(0x0c, 0x20))\n        }\n    }\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                         MODIFIERS                          */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev Marks a function as only callable by the owner.\n    modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }\n}\n"
    },
    "solady/src/utils/LibString.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/// @notice Library for converting numbers into strings and other string operations.\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\n///\n/// @dev Note:\n/// For performance and bytecode compactness, most of the string operations are restricted to\n/// byte strings (7-bit ASCII), except where otherwise specified.\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\n/// can lead to undefined behavior.\nlibrary LibString {\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                        CUSTOM ERRORS                       */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev The length of the output is too small to contain all the hex digits.\n    error HexLengthInsufficient();\n\n    /// @dev The length of the string is more than 32 bytes.\n    error TooBigForSmallString();\n\n    /// @dev The input string must be a 7-bit ASCII.\n    error StringNot7BitASCII();\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                         CONSTANTS                          */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev The constant returned when the `search` is not found in the string.\n    uint256 internal constant NOT_FOUND = type(uint256).max;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\n\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\n\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\n\n    /// @dev Lookup for '0123456789'.\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\n\n    /// @dev Lookup for '01234567'.\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\n\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~ \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\n\n    /// @dev Lookup for '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'.\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\n\n    /// @dev Lookup for ' \\t\\n\\r\\x0b\\x0c'.\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                     DECIMAL OPERATIONS                     */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            str := add(mload(0x40), 0x80)\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\n            mstore(str, 0) // Zeroize the slot after the string.\n\n            let end := str // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(str, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let length := sub(end, str)\n            str := sub(str, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(str, length) // Store the length.\n        }\n    }\n\n    /// @dev Returns the base 10 decimal representation of `value`.\n    function toString(int256 value) internal pure returns (string memory str) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            str = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let length := mload(str) // Load the string length.\n            mstore(str, 0x2d) // Store the '-' character.\n            str := sub(str, 1) // Move back the string pointer by a byte.\n            mstore(str, add(length, 1)) // Update the string length.\n        }\n    }\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                   HEXADECIMAL OPERATIONS                   */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2 + 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value, length);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`,\n    /// left-padded to an input length of `length` bytes.\n    /// The output is prefixed with \"0x\" encoded using 2 hexadecimal digits per byte,\n    /// giving a total length of `length * 2` bytes.\n    /// Reverts if `length` is too small for the output to contain all the digits.\n    function toHexStringNoPrefix(uint256 value, uint256 length)\n        internal\n        pure\n        returns (string memory str)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\n            mstore(str, 0) // Zeroize the slot after the string.\n\n            let end := str // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(str, add(length, length))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(str, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let strLength := sub(end, str)\n            str := sub(str, 0x20)\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2 + 2` bytes.\n    function toHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\".\n    /// The output excludes leading \"0\" from the `toHexString` output.\n    /// `0x00: \"0x0\", 0x01: \"0x1\", 0x12: \"0x12\", 0x123: \"0x123\"`.\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(add(str, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output excludes leading \"0\" from the `toHexStringNoPrefix` output.\n    /// `0x00: \"0\", 0x01: \"1\", 0x12: \"12\", 0x123: \"123\"`.\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\n            let strLength := mload(str) // Get the length.\n            str := add(str, o) // Move the pointer, accounting for leading zero.\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    /// As address are 20 bytes long, the output will left-padded to have\n    /// a length of `20 * 2` bytes.\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            str := add(mload(0x40), 0x80)\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\n            mstore(str, 0) // Zeroize the slot after the string.\n\n            let end := str // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                str := add(str, w) // `sub(str, 2)`.\n                mstore8(add(str, 1), mload(and(temp, 15)))\n                mstore8(str, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let strLength := sub(end, str)\n            str := sub(str, 0x20)\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\", encoded using 2 hexadecimal digits per byte,\n    /// and the alphabets are capitalized conditionally according to\n    /// https://eips.ethereum.org/EIPS/eip-55\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\n        str = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(str, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is prefixed with \"0x\" and encoded using 2 hexadecimal digits per byte.\n    function toHexString(address value) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hexadecimal representation of `value`.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            str := mload(0x40)\n            // Allocate the memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(str, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            str := add(str, 2)\n            mstore(str, 40) // Store the length.\n            let o := add(str, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\n        str = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let strLength := add(mload(str), 2) // Compute the length.\n            mstore(str, 0x3078) // Store the \"0x\" prefix.\n            str := sub(str, 2) // Move the pointer.\n            mstore(str, strLength) // Store the length.\n        }\n    }\n\n    /// @dev Returns the hex encoded string from the raw bytes.\n    /// The output is encoded using 2 hexadecimal digits per byte.\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(raw)\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(str, add(length, length)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(str, 0x20)\n            let end := add(raw, length)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                   RUNE STRING OPERATIONS                   */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    /// @dev Returns the number of UTF characters in the string.\n    function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string.\n    /// (i.e. all characters codes are in [0..127])\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(7, div(not(0), 255))\n            result := 1\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }\n\n    /// @dev Returns if this string is a 7-bit ASCII string,\n    /// AND all characters are in the `allowed` lookup.\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for {} 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }\n\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\n    /// To save runtime gas, you can cache the result in an immutable variable.\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for {} 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }\n\n    /*Â´:Â°â¢.Â°+.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°â¢.*â¢Â´.*:Ë.Â°*.Ëâ¢Â´.Â°:Â°â¢.Â°+.*â¢Â´.*:*/\n    /*                   BYTE STRING OPERATIONS                   */\n    /*.â¢Â°:Â°.Â´+Ë.*Â°.Ë:*.Â´â¢*.+Â°.â¢Â°:Â´*.Â´â¢*.â¢Â°.â¢Â°:Â°.Â´:â¢ËÂ°.*Â°.Ë:*.Â´+Â°.â¢*/\n\n    // For performance and bytecode compactness, byte string operations are restricted\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\n    // can lead to undefined behavior.\n\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\n    function replace(string memory subject, string memory search, string memory replacement)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n            let replacementLength := mload(replacement)\n\n            subject := add(subject, 0x20)\n            search := add(search, 0x20)\n            replacement := add(replacement, 0x20)\n            result := add(mload(0x40), 0x20)\n\n            let subjectEnd := add(subject, subjectLength)\n            if iszero(gt(searchLength, subjectLength)) {\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                mstore(result, t)\n                                result := add(result, 1)\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let o := 0 } 1 {} {\n                            mstore(add(result, o), mload(add(replacement, o)))\n                            o := add(o, 0x20)\n                            if iszero(lt(o, replacementLength)) { break }\n                        }\n                        result := add(result, replacementLength)\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(result, t)\n                    result := add(result, 1)\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n            }\n\n            let resultRemainder := result\n            result := add(mload(0x40), 0x20)\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\n            // Copy the rest of the string one word at a time.\n            for {} lt(subject, subjectEnd) {} {\n                mstore(resultRemainder, mload(subject))\n                resultRemainder := add(resultRemainder, 0x20)\n                subject := add(subject, 0x20)\n            }\n            result := sub(result, 0x20)\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\n            mstore(last, 0)\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            mstore(result, k) // Store the length.\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let subjectLength := mload(subject) } 1 {} {\n                if iszero(mload(search)) {\n                    if iszero(gt(from, subjectLength)) {\n                        result := from\n                        break\n                    }\n                    result := subjectLength\n                    break\n                }\n                let searchLength := mload(search)\n                let subjectStart := add(subject, 0x20)\n\n                result := not(0) // Initialize to `NOT_FOUND`.\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\n\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(add(search, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\n\n                if iszero(lt(searchLength, 0x20)) {\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, searchLength), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from left to right.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function indexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = indexOf(subject, search, 0);\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left, starting from `from`.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let searchLength := mload(search)\n                if gt(searchLength, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), searchLength)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\n                    if eq(keccak256(subject, searchLength), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }\n\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\n    /// searching from right to left.\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\n    function lastIndexOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\n    }\n\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\n        return indexOf(subject, search) != NOT_FOUND;\n    }\n\n    /// @dev Returns whether `subject` starts with `search`.\n    function startsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                iszero(gt(searchLength, mload(subject))),\n                eq(\n                    keccak256(add(subject, 0x20), searchLength),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns whether `subject` ends with `search`.\n    function endsWith(string memory subject, string memory search)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLength := mload(search)\n            let subjectLength := mload(subject)\n            // Whether `search` is not longer than `subject`.\n            let withinRange := iszero(gt(searchLength, subjectLength))\n            // Just using keccak256 directly is actually cheaper.\n            // forgefmt: disable-next-item\n            result := and(\n                withinRange,\n                eq(\n                    keccak256(\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\n                        searchLength\n                    ),\n                    keccak256(add(search, 0x20), searchLength)\n                )\n            )\n        }\n    }\n\n    /// @dev Returns `subject` repeated `times`.\n    function repeat(string memory subject, uint256 times)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(or(iszero(times), iszero(subjectLength))) {\n                subject := add(subject, 0x20)\n                result := mload(0x40)\n                let output := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let o := 0 } 1 {} {\n                        mstore(add(output, o), mload(add(subject, o)))\n                        o := add(o, 0x20)\n                        if iszero(lt(o, subjectLength)) { break }\n                    }\n                    output := add(output, subjectLength)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(output, 0) // Zeroize the slot after the string.\n                let resultLength := sub(output, add(result, 0x20))\n                mstore(result, resultLength) // Store the length.\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\n    /// `start` and `end` are byte offsets.\n    function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLength := sub(end, start)\n                mstore(result, resultLength)\n                subject := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\n                    mstore(add(result, o), mload(add(subject, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Zeroize the slot after the string.\n                mstore(add(add(result, 0x20), resultLength), 0)\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\n    /// `start` is a byte offset.\n    function slice(string memory subject, uint256 start)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = slice(subject, start, uint256(int256(-1)));\n    }\n\n    /// @dev Returns all the indices of `search` in `subject`.\n    /// The indices are byte offsets.\n    function indicesOf(string memory subject, string memory search)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let subjectLength := mload(subject)\n            let searchLength := mload(search)\n\n            if iszero(gt(searchLength, subjectLength)) {\n                subject := add(subject, 0x20)\n                search := add(search, 0x20)\n                result := add(mload(0x40), 0x20)\n\n                let subjectStart := subject\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\n                let h := 0\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\n                let s := mload(search)\n                for {} 1 {} {\n                    let t := mload(subject)\n                    // Whether the first `searchLength % 32` bytes of\n                    // `subject` and `search` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\n                                subject := add(subject, 1)\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Append to `result`.\n                        mstore(result, sub(subject, subjectStart))\n                        result := add(result, 0x20)\n                        // Advance `subject` by `searchLength`.\n                        subject := add(subject, searchLength)\n                        if searchLength {\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\n                }\n                let resultEnd := result\n                // Assign `result` to the free memory pointer.\n                result := mload(0x40)\n                // Store the length of `result`.\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(resultEnd, 0x20))\n            }\n        }\n    }\n\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\n    function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            let prevIndex := 0\n            for {} 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let elementLength := sub(index, prevIndex)\n                    mstore(element, elementLength)\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    // Zeroize the slot after the string.\n                    mstore(add(add(element, 0x20), elementLength), 0)\n                    // Allocate memory for the length and the bytes,\n                    // rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\n                    // Store the `element` into the array.\n                    mstore(indexPtr, element)\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }\n\n    /// @dev Returns a concatenated string of `a` and `b`.\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\n    function concat(string memory a, string memory b)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            result := mload(0x40)\n            let aLength := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLength := mload(b)\n            let output := add(result, aLength)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLength := add(aLength, bLength)\n            let last := add(add(result, 0x20), totalLength)\n            mstore(last, 0) // Zeroize the slot after the string.\n            mstore(result, totalLength) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let length := mload(subject)\n            if length {\n                result := add(mload(0x40), 0x20)\n                subject := add(subject, 1)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                let w := not(0)\n                for { let o := length } 1 {} {\n                    o := add(o, w)\n                    let b := and(0xff, mload(add(subject, o)))\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\n                    if iszero(o) { break }\n                }\n                result := mload(0x40)\n                mstore(result, length) // Store the length.\n                let last := add(add(result, 0x20), length)\n                mstore(last, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\n            }\n        }\n    }\n\n    /// @dev Returns a string from a small bytes32 string.\n    /// `s` must be null-terminated, or behavior will be undefined.\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }\n\n    /// @dev Returns the string as a normalized null-terminated small string.\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }\n\n    /// @dev Returns a lowercased copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }\n\n    /// @dev Returns an UPPERCASED copy of the string.\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\n    function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }\n\n    /// @dev Escapes the string to be used within HTML tags.\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(result, c)\n                    result := add(result, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(result, mload(and(t, 0x1f)))\n                result := add(result, shr(5, t))\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\n    function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let end := add(s, mload(s))\n            result := add(mload(0x40), 0x20)\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(result, c)\n                        result := add(result, 1)\n                        continue\n                    }\n                    mstore8(result, 0x5c) // \"\\\\\".\n                    mstore8(add(result, 1), c)\n                    result := add(result, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(result, mload(0x19)) // \"\\\\u00XX\".\n                    result := add(result, 6)\n                    continue\n                }\n                mstore8(result, 0x5c) // \"\\\\\".\n                mstore8(add(result, 1), mload(add(c, 8)))\n                result := add(result, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(result, 34)\n                result := add(1, result)\n            }\n            let last := result\n            mstore(last, 0) // Zeroize the slot after the string.\n            result := mload(0x40)\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\n        }\n    }\n\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }\n\n    /// @dev Returns whether `a` equals `b`.\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }\n\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }\n\n    /// @dev Packs a single string with its length into a single word.\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\n    function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }\n\n    /// @dev Unpacks a string packed using {packOne}.\n    /// Returns the empty string if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }\n\n    /// @dev Packs two strings with their lengths into a single word.\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLength := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\n                        mload(sub(add(b, 0x1e), aLength))\n                    ),\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\n                )\n        }\n    }\n\n    /// @dev Unpacks strings packed using {packTwo}.\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\n    function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }\n\n    /// @dev Directly returns `a` without copying.\n    function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}