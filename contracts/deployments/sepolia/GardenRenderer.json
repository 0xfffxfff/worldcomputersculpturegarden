{
  "address": "0xbdbA5f0681A19Ca160835de23624677982EfD3ff",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_garden",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "garden",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "html",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x19f3765b4228ceceffab111f4b58e64baab979103443a14d35aa78bafb4ed796",
  "receipt": {
    "to": null,
    "from": "0x116ADF6db6aBF17828530Ca868Cac4A80af9f9c2",
    "contractAddress": "0xbdbA5f0681A19Ca160835de23624677982EfD3ff",
    "transactionIndex": 102,
    "gasUsed": "2523474",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xfc1b35d1198c2194830b3baf888ac3aae40291bd29955e477df64cf2e3955e8a",
    "transactionHash": "0x19f3765b4228ceceffab111f4b58e64baab979103443a14d35aa78bafb4ed796",
    "logs": [],
    "blockNumber": 6800369,
    "cumulativeGasUsed": "14875346",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x28D444f480a7ecA55F4944CFF847685c631650d6"
  ],
  "numDeployments": 10,
  "solcInputHash": "4f1f080e08ca7e16fda9204f1e7f07df",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_garden\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"garden\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"html\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Web.sol\":\"GardenRenderer\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Sculpture.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\ninterface Sculpture {\\n\\n    function title() external view returns (string memory);\\n\\n    function authors() external view returns (string[] memory);\\n\\n    function addresses() external view returns (address[] memory);\\n\\n    function urls() external view returns (string[] memory);\\n\\n    function text() external view returns (string memory);\\n\\n}\\n\",\"keccak256\":\"0x42a64bba30b562f327b8313eb924643e9a8e2b39d4f330c9ed2cacdf4d027052\",\"license\":\"UNLICENSED\"},\"contracts/Web.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\nimport \\\"./Sculpture.sol\\\";\\n\\ninterface IGarden {\\n    function getContribution(uint256 index) external view returns (address contributor, uint256 amount);\\n    function getContributed() external view returns (uint256);\\n    function getSculptures() external view returns (address[] memory);\\n}\\n\\ninterface IWeb {\\n    function html() external view returns (string memory);\\n}\\n\\ncontract Web is IWeb, Ownable {\\n    address public garden;\\n    address public renderer;\\n\\n    constructor() {\\n        _initializeOwner(msg.sender);\\n    }\\n\\n    function html() external view returns (string memory) {\\n        return GardenRenderer(renderer).html();\\n    }\\n\\n    function setRenderer(address _renderer) public onlyOwner {\\n        renderer = _renderer;\\n    }\\n}\\n\\ncontract GardenRenderer {\\n\\n    address immutable public garden;\\n\\n    constructor(address _garden) {\\n        garden = _garden;\\n    }\\n\\n    function html() public view returns (string memory) {\\n        string memory html = \\\"<html>\\\";\\n        html = string.concat(html,\\n            '<head>',\\n            '<meta charset=\\\"UTF-8\\\">',\\n            '<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">',\\n            '<title>', Sculpture(garden).title() ,'</title>',\\n            '</head>',\\n            \\\"<style>\\\",\\n            '*, *::before, *::after { box-sizing: border-box; }',\\n            'html { -moz-text-size-adjust: none; -webkit-text-size-adjust: none; text-size-adjust: none; }',\\n            'html, body { margin: 0; padding: 0; } body { min-height: 100vh }',\\n            'html,body,pre { font-family: \\\"Courier New\\\", \\\"Courier\\\", monospace; font-size: 15px; }',\\n            'h1,h2,h3 { margin: 0; font-size: inherit; font-style: inherit; font-weight: inherit;}',\\n            \\\".c { max-width: 840px; margin: 5em auto; padding: 1.5em; }\\\",\\n            \\\"@media screen and (max-width: 760px) { .c { margin: 2.5em auto; } }\\\",\\n            \\\"a { color: inherit; text-decoration: underline; }\\\",\\n            \\\".w { min-height: 100vh; display: flex; align-items: center; box-sizing: border-box; padding: 10em 0; }\\\",\\n            \\\".s { width: 100%; max-width: 840px; }\\\",\\n            \\\".s a { text-decoration: none; max-width: 100%; display: inline-block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }\\\",\\n            \\\".t { max-width: 100%; overflow-x: scroll; }\\\",\\n            \\\".i { margin: 50vh 0 5em; }\\\",\\n            \\\"pre.garden { line-height: 1.3; font-size: 1.2rem;}\\\",\\n            \\\"</style>\\\"\\n        );\\n        html = string.concat(\\n            html, \\\"<body>\\\",\\n            '<div class=\\\"c\\\">',\\n            '<pre class=\\\"garden\\\">',\\nunicode\\\"     \\u2698\\\\n\\\",\\nunicode\\\"              \\u2698         \\u2698\\\\n\\\",\\nunicode\\\"        \\u2698\\\\n\\\",\\nunicode\\\"                     \\u2698     \\u2698\\\\n\\\",\\nunicode\\\"      \\u2698        \\u2698\\\\n\\\",\\nunicode\\\"                       \\u2698\\\\n\\\",\\nunicode\\\"            \\u2698\\\\n\\\",\\nunicode\\\"          </pre>\\\",\\n            \\\"<br><br>\\\",\\n            \\\"<h1>\\\", Sculpture(garden).title() ,\\\"</h1>\\\"\\n            '<br /><br />',\\n        '<p>',\\n        'A contract show organized by ',\\n        '<a href=\\\"https://0xfff.love\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">0xfff</a><br />with special thanks to ',\\n        '<a href=\\\"https://x.com/sssluke1\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">sssluke</a> and <a href=\\\"https://x.com/0x113d\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\">113</a>',\\n        \\\"</p>\\\",\\n        \\\"<br />\\\");\\n\\n        address[] memory sculptures = IGarden(garden).getSculptures();\\n        for (uint256 i = 0; i < sculptures.length; i++) {\\n            Sculpture sculpture = Sculpture(sculptures[i]);\\n            string memory title = sculpture.title();\\n            html = string.concat(html, '<div class=\\\"w\\\"><div class=\\\"s\\\">');\\n            string[] memory authors = sculpture.authors();\\n            if (authors.length > 0) {\\n                html = string.concat(html, \\\"<h2>\\\");\\n                for (uint256 j = 0; j < authors.length; j++) {\\n                    if (bytes(authors[j]).length == 0) continue; // ignore empty\\n                    html = string.concat(html, authors[j], \\\"<br/>\\\");\\n                }\\n                html = string.concat(html, \\\"</h2>\\\");\\n            }\\n            if (bytes(title).length > 0) {\\n                html = string.concat(html, \\\"<h3><i>\\\", title, \\\"</i></h3>\\\");\\n            } else {\\n                html = string.concat(html, \\\"<h3><i>\\\", \\\"Untitled\\\", \\\"</i></h3>\\\");\\n            }\\n            address[] memory addresses = sculpture.addresses();\\n            if (addresses.length > 0) {\\n                html = string.concat(html, \\\"<p>\\\");\\n                for (uint256 j = 0; j < addresses.length; j++) {\\n                    html = string.concat(html, LibString.toHexString(addresses[j]), \\\"<br/>\\\");\\n                }\\n                html = string.concat(html, \\\"</p>\\\");\\n            }\\n            string[] memory urls = sculpture.urls();\\n            if (urls.length > 0) {\\n                html = string.concat(html, \\\"<p>\\\");\\n                for (uint256 j = 0; j < urls.length; j++) {\\n                    if (bytes(urls[j]).length == 0) continue; // ignore empty\\n                    html = string.concat(html, renderUrl(urls[j]), \\\"<br/>\\\");\\n                }\\n                html = string.concat(html, \\\"</p>\\\");\\n            }\\n            string memory text = sculpture.text();\\n            bool isSarah = sculpture.authors().length > 0 && keccak256(abi.encodePacked(sculpture.authors()[0])) == keccak256(abi.encodePacked(\\\"Sarah Friend\\\"));\\n            if (bytes(text).length > 0) {\\n                if (isSarah) { html = string.concat(html, '<div class=\\\"t\\\"><pre>', text, '</pre></div>'); }\\n                else { html = string.concat(html, '<div class=\\\"t\\\"><p>', text, '</p></div>'); }\\n            }\\n            html = string.concat(html, \\\"</div></div>\\\");\\n        }\\n        // uint contributed = GardenContributions(garden).getContributed();\\n        // for (uint256 i = 0; i < contributed; i++) {\\n        //     html = string(abi.encodePacked(html, \\\"<li>\\\", GardenContributions(garden).getContribution(i), \\\"</li>\\\"));\\n        // }\\n        html = string.concat(html, '<div class=\\\"i\\\">Generated at block ', LibString.toString(block.number), \\\" (\\\", LibString.toString(block.timestamp), \\\")</div>\\\");\\n        html = string.concat(html, \\\"</div></body></html>\\\");\\n        return html;\\n    }\\n\\n    function stripURL(string memory url) internal pure returns (string memory) {\\n        bytes memory urlBytes = bytes(url);\\n        uint256 length = urlBytes.length;\\n        uint256 start = 0;\\n        uint256 end = length;\\n\\n        // Find the position of \\\"://\\\", which indicates the end of the protocol\\n        for (uint256 i = 0; i < length - 2; i++) {\\n            if (urlBytes[i] == \\\":\\\" && urlBytes[i + 1] == \\\"/\\\" && urlBytes[i + 2] == \\\"/\\\") {\\n                start = i + 3; // Skip the \\\"://\\\"max\\n                break;\\n            }\\n        }\\n\\n        // Find position of \\\"?\\\" or \\\"#\\\" to determine the end of the main URL\\n        for (uint256 i = start; i < length; i++) {\\n            if (urlBytes[i] == \\\"?\\\" || urlBytes[i] == \\\"#\\\") {\\n                end = i;\\n                break;\\n            }\\n        }\\n\\n        // Remove trailing slash if present\\n        if (end > start && urlBytes[end - 1] == \\\"/\\\") {\\n            end -= 1;\\n        }\\n\\n        // Create a new byte array to store the stripped URL\\n        bytes memory strippedUrlBytes = new bytes(end - start);\\n        for (uint256 i = start; i < end; i++) {\\n            strippedUrlBytes[i - start] = urlBytes[i];\\n        }\\n\\n        return string(strippedUrlBytes);\\n    }\\n\\n    function renderUrl(string memory url) internal pure returns (string memory) {\\n        string memory strippedUrl = stripURL(url);\\n        return string.concat('<a href=\\\"', url, '\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">', strippedUrl ,'</a>');\\n    }\\n\\n\\n}\",\"keccak256\":\"0xd0b42338ea1f58bfdb7bb552d922ec6e2148c21686efa1a2ca50e27250fa7f6b\",\"license\":\"UNLICENSED\"},\"solady/src/auth/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xc208cdd9de02bbf4b5edad18b88e23a2be7ff56d2287d5649329dc7cda64b9a3\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /// @dev The input string must be a 7-bit ASCII.\\n    error StringNot7BitASCII();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\\n\\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\\n\\n    /// @dev Lookup for '0123456789'.\\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\\n\\n    /// @dev Lookup for '01234567'.\\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~ \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\\n\\n    /// @dev Lookup for '!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~'.\\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\\n\\n    /// @dev Lookup for ' \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end of the memory to calculate the length later.\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Store the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\\n                if iszero(temp) { break }\\n            }\\n            let length := sub(end, str)\\n            str := sub(str, 0x20) // Move the pointer 32 bytes back to make room for the length.\\n            mstore(str, length) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) return toString(uint256(value));\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end to calculate the length later.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let strLength := sub(end, str)\\n            str := sub(str, 0x20)\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Store the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end to calculate the length later.\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n            let strLength := sub(end, str)\\n            str := sub(str, 0x20)\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            str := add(str, 2)\\n            mstore(str, 40) // Store the length.\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\\n            value := shl(96, value)\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string,\\n    /// AND all characters are in the `allowed` lookup.\\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            if mload(s) {\\n                let allowed_ := shr(128, shl(128, allowed))\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for {} 1 {} {\\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\\n                    o := add(o, 1)\\n                    if iszero(and(result, lt(o, end))) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\\n    /// To save runtime gas, you can cache the result in an immutable variable.\\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for {} 1 {} {\\n                    result := or(result, shl(byte(0, mload(o)), 1))\\n                    o := add(o, 1)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                if shr(128, result) {\\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            mstore(result, totalLength) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n) // Store the length.\\n            let o := add(result, 0x20)\\n            mstore(o, s) // Store the bytes of the string.\\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(result, 0x40)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40) // Grab the free memory pointer.\\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(result, 0) // Zeroize the length slot.\\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    or( // Load the length and the bytes of `a` and `b`.\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            resultA := mload(0x40) // Grab the free memory pointer.\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retUnpaddedSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retUnpaddedSize), 0)\\n            mstore(retStart, 0x20) // Store the return offset.\\n            // End the transaction, returning the string.\\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbb90caa572b7f65689b74867ec211fed8cde92714314101f4287d00a40d95ab2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051612e16380380612e16833981810160405281019061003291906100cf565b8073ffffffffffffffffffffffffffffffffffffffff1660808173ffffffffffffffffffffffffffffffffffffffff1681525050506100fc565b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061009c82610071565b9050919050565b6100ac81610091565b81146100b757600080fd5b50565b6000815190506100c9816100a3565b92915050565b6000602082840312156100e5576100e461006c565b5b60006100f3848285016100ba565b91505092915050565b608051612ceb61012b6000396000818160b60152818161016d015281816102250152610a590152612ceb6000f3fe608060405234801561001057600080fd5b50600436106100365760003560e01c806333c34ac31461003b57806356ba88b814610059575b600080fd5b610043610077565b604051610050919061104f565b60405180910390f35b610061610a57565b60405161006e91906110b2565b60405180910390f35b606060006040518060400160405280600681526020017f3c68746d6c3e00000000000000000000000000000000000000000000000000008152509050807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561011f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906101489190611207565b604051602001610159929190611b74565b6040516020818303038152906040529050807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156101d6573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906101ff9190611207565b60405160200161021092919061216a565b604051602081830303815290604052905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561028e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906102b791906123a2565b905060005b81518110156109f65760008282815181106102da576102d96123eb565b5b6020026020010151905060008173ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610331573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061035a9190611207565b90508460405160200161036d9190612440565b604051602081830303815290604052945060008273ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa1580156103cb573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906103f49190612547565b90506000815111156104c2578560405160200161041191906125b6565b604051602081830303815290604052955060005b815181101561049e576000828281518110610443576104426123eb565b5b60200260200101515103156104915786828281518110610466576104656123eb565b5b602002602001015160405160200161047f929190612602565b60405160208183030381529060405296505b8080600101915050610425565b50856040516020016104b0919061265b565b60405160208183030381529060405295505b6000825111156104f55785826040516020016104df9291906126cd565b6040516020818303038152906040529550610518565b856040516020016105069190612735565b60405160208183030381529060405295505b60008373ffffffffffffffffffffffffffffffffffffffff1663da0321cd6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610565573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061058e91906123a2565b905060008151111561063f57866040516020016105ab9190612779565b604051602081830303815290604052965060005b815181101561061b57876105ec8383815181106105df576105de6123eb565b5b6020026020010151610a7b565b6040516020016105fd929190612602565b604051602081830303815290604052975080806001019150506105bf565b508660405160200161062d919061279f565b60405160208183030381529060405296505b60008473ffffffffffffffffffffffffffffffffffffffff16632c73dc4a6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561068c573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906106b59190612547565b905060008151111561078b57876040516020016106d29190612779565b604051602081830303815290604052975060005b8151811015610767576000828281518110610704576107036123eb565b5b602002602001015151031561075a578861073783838151811061072a576107296123eb565b5b6020026020010151610aa1565b604051602001610748929190612602565b60405160208183030381529060405298505b80806001019150506106e6565b5087604051602001610779919061279f565b60405160208183030381529060405297505b60008573ffffffffffffffffffffffffffffffffffffffff16631f1bd6926040518163ffffffff1660e01b8152600401600060405180830381865afa1580156107d8573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906108019190611207565b90506000808773ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa158015610851573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061087a9190612547565b5111801561095f575060405160200161089290612811565b604051602081830303815290604052805190602001208773ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa1580156108f3573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061091c9190612547565b60008151811061092f5761092e6123eb565b5b60200260200101516040516020016109479190612826565b60405160208183030381529060405280519060200120145b90506000825111156109c057801561099a578982604051602001610984929190612889565b60405160208183030381529060405299506109bf565b89826040516020016109ad929190612917565b60405160208183030381529060405299505b5b896040516020016109d1919061297f565b60405160208183030381529060405299505050505050505080806001019150506102bc565b5081610a0143610ada565b610a0a42610ada565b604051602001610a1c93929190612a63565b604051602081830303815290604052915081604051602001610a3e9190612ae3565b6040516020818303038152906040529150819250505090565b7f000000000000000000000000000000000000000000000000000000000000000081565b6060610a8682610b2b565b90506002815101613078825260028203915080825250919050565b60606000610aae83610bae565b90508281604051602001610ac3929190612bc7565b604051602081830303815290604052915050919050565b60606080604051019050602081016040526000815280600019835b600115610b16578184019350600a81066030018453600a8104905080610af5575b50828203602084039350808452505050919050565b60606040519050608081016040526f30313233343536373839616263646566600f526002810190506028815260208101600060288201528260601b925060005b600115610ba757808101820184821a600f81165160018301538060041c51825360018301925060148303610ba0575050610ba7565b5050610b6b565b5050919050565b6060600082905060008151905060008082905060005b600284610bd19190612c4d565b811015610d4c577f3a00000000000000000000000000000000000000000000000000000000000000858281518110610c0c57610c0b6123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148015610cb057507f2f0000000000000000000000000000000000000000000000000000000000000085600183610c709190612c81565b81518110610c8157610c806123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8015610d2657507f2f0000000000000000000000000000000000000000000000000000000000000085600283610ce69190612c81565b81518110610cf757610cf66123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610d3f57600381610d389190612c81565b9250610d4c565b8080600101915050610bc4565b5060008290505b83811015610e40577f3f00000000000000000000000000000000000000000000000000000000000000858281518110610d8f57610d8e6123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161480610e2657507f2300000000000000000000000000000000000000000000000000000000000000858281518110610df757610df66123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610e3357809150610e40565b8080600101915050610d53565b508181118015610eba57507f2f0000000000000000000000000000000000000000000000000000000000000084600183610e7a9190612c4d565b81518110610e8b57610e8a6123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610ecf57600181610ecc9190612c4d565b90505b60008282610edd9190612c4d565b67ffffffffffffffff811115610ef657610ef56110eb565b5b6040519080825280601f01601f191660200182016040528015610f285781602001600182028036833780820191505090505b50905060008390505b82811015610fb157858181518110610f4c57610f4b6123eb565b5b602001015160f81c60f81b828583610f649190612c4d565b81518110610f7557610f746123eb565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610f31565b508095505050505050919050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610ff9578082015181840152602081019050610fde565b60008484015250505050565b6000601f19601f8301169050919050565b600061102182610fbf565b61102b8185610fca565b935061103b818560208601610fdb565b61104481611005565b840191505092915050565b600060208201905081810360008301526110698184611016565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061109c82611071565b9050919050565b6110ac81611091565b82525050565b60006020820190506110c760008301846110a3565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61112382611005565b810181811067ffffffffffffffff82111715611142576111416110eb565b5b80604052505050565b60006111556110cd565b9050611161828261111a565b919050565b600067ffffffffffffffff821115611181576111806110eb565b5b61118a82611005565b9050602081019050919050565b60006111aa6111a584611166565b61114b565b9050828152602081018484840111156111c6576111c56110e6565b5b6111d1848285610fdb565b509392505050565b600082601f8301126111ee576111ed6110e1565b5b81516111fe848260208601611197565b91505092915050565b60006020828403121561121d5761121c6110d7565b5b600082015167ffffffffffffffff81111561123b5761123a6110dc565b5b611247848285016111d9565b91505092915050565b600081905092915050565b600061126682610fbf565b6112708185611250565b9350611280818560208601610fdb565b80840191505092915050565b7f3c686561643e0000000000000000000000000000000000000000000000000000815250565b7f3c6d65746120636861727365743d225554462d38223e00000000000000000000815250565b7f3c6d657461206e616d653d2276696577706f72742220636f6e74656e743d227760008201527f696474683d6465766963652d77696474682c20696e697469616c2d7363616c6560208201527f3d312e30223e0000000000000000000000000000000000000000000000000000604082015250565b600061135a604683611250565b9150611365826112d8565b604682019050919050565b7f3c7469746c653e00000000000000000000000000000000000000000000000000815250565b7f3c2f7469746c653e000000000000000000000000000000000000000000000000815250565b7f3c2f686561643e00000000000000000000000000000000000000000000000000815250565b7f3c7374796c653e00000000000000000000000000000000000000000000000000815250565b7f2a2c202a3a3a6265666f72652c202a3a3a6166746572207b20626f782d73697a60008201527f696e673a20626f726465722d626f783b207d0000000000000000000000000000602082015250565b6000611464603283611250565b915061146f82611408565b603282019050919050565b7f68746d6c207b202d6d6f7a2d746578742d73697a652d61646a7573743a206e6f60008201527f6e653b202d7765626b69742d746578742d73697a652d61646a7573743a206e6f60208201527f6e653b20746578742d73697a652d61646a7573743a206e6f6e653b207d000000604082015250565b60006114fc605d83611250565b91506115078261147a565b605d82019050919050565b7f68746d6c2c20626f6479207b206d617267696e3a20303b2070616464696e673a60008201527f20303b207d20626f6479207b206d696e2d6865696768743a203130307668207d602082015250565b600061156e604083611250565b915061157982611512565b604082019050919050565b7f68746d6c2c626f64792c707265207b20666f6e742d66616d696c793a2022436f60008201527f7572696572204e6577222c2022436f7572696572222c206d6f6e6f737061636560208201527f3b20666f6e742d73697a653a20313570783b207d000000000000000000000000604082015250565b6000611606605483611250565b915061161182611584565b605482019050919050565b7f68312c68322c6833207b206d617267696e3a20303b20666f6e742d73697a653a60008201527f20696e68657269743b20666f6e742d7374796c653a20696e68657269743b206660208201527f6f6e742d7765696768743a20696e68657269743b7d0000000000000000000000604082015250565b600061169e605583611250565b91506116a98261161c565b605582019050919050565b7f2e63207b206d61782d77696474683a2038343070783b206d617267696e3a203560008201527f656d206175746f3b2070616464696e673a20312e35656d3b207d000000000000602082015250565b6000611710603a83611250565b915061171b826116b4565b603a82019050919050565b7f406d656469612073637265656e20616e6420286d61782d77696474683a20373660008201527f30707829207b202e63207b206d617267696e3a20322e35656d206175746f3b2060208201527f7d207d0000000000000000000000000000000000000000000000000000000000604082015250565b60006117a8604383611250565b91506117b382611726565b604382019050919050565b7f61207b20636f6c6f723a20696e68657269743b20746578742d6465636f72617460008201527f696f6e3a20756e6465726c696e653b207d000000000000000000000000000000602082015250565b600061181a603183611250565b9150611825826117be565b603182019050919050565b7f2e77207b206d696e2d6865696768743a2031303076683b20646973706c61793a60008201527f20666c65783b20616c69676e2d6974656d733a2063656e7465723b20626f782d60208201527f73697a696e673a20626f726465722d626f783b2070616464696e673a2031306560408201527f6d20303b207d0000000000000000000000000000000000000000000000000000606082015250565b60006118d8606683611250565b91506118e382611830565b606682019050919050565b7f2e73207b2077696474683a20313030253b206d61782d77696474683a2038343060008201527f70783b207d000000000000000000000000000000000000000000000000000000602082015250565b600061194a602583611250565b9150611955826118ee565b602582019050919050565b7f2e732061207b20746578742d6465636f726174696f6e3a206e6f6e653b206d6160008201527f782d77696474683a20313030253b20646973706c61793a20696e6c696e652d6260208201527f6c6f636b3b2077686974652d73706163653a206e6f777261703b206f7665726660408201527f6c6f773a2068696464656e3b20746578742d6f766572666c6f773a20656c6c6960608201527f707369733b207d00000000000000000000000000000000000000000000000000608082015250565b6000611a2e608783611250565b9150611a3982611960565b608782019050919050565b7f2e74207b206d61782d77696474683a20313030253b206f766572666c6f772d7860008201527f3a207363726f6c6c3b207d000000000000000000000000000000000000000000602082015250565b6000611aa0602b83611250565b9150611aab82611a44565b602b82019050919050565b7f2e69207b206d617267696e3a203530766820302035656d3b207d000000000000815250565b7f7072652e67617264656e207b206c696e652d6865696768743a20312e333b206660008201527f6f6e742d73697a653a20312e3272656d3b7d0000000000000000000000000000602082015250565b6000611b38603283611250565b9150611b4382611adc565b603282019050919050565b7f3c2f7374796c653e000000000000000000000000000000000000000000000000815250565b6000611b80828561125b565b9150611b8b8261128c565b600682019150611b9a826112b2565b601682019150611ba98261134d565b9150611bb482611370565b600782019150611bc4828461125b565b9150611bcf82611396565b600882019150611bde826113bc565b600782019150611bed826113e2565b600782019150611bfc82611457565b9150611c07826114ef565b9150611c1282611561565b9150611c1d826115f9565b9150611c2882611691565b9150611c3382611703565b9150611c3e8261179b565b9150611c498261180d565b9150611c54826118cb565b9150611c5f8261193d565b9150611c6a82611a21565b9150611c7582611a93565b9150611c8082611ab6565b601a82019150611c8f82611b2b565b9150611c9a82611b4e565b6008820191508190509392505050565b7f3c626f64793e0000000000000000000000000000000000000000000000000000815250565b7f3c64697620636c6173733d2263223e0000000000000000000000000000000000815250565b7f3c70726520636c6173733d2267617264656e223e000000000000000000000000815250565b7f2020202020e29a980a0000000000000000000000000000000000000000000000815250565b7f2020202020202020202020202020e29a98202020202020202020e29a980a0000815250565b7f2020202020202020e29a980a0000000000000000000000000000000000000000815250565b7f202020202020202020202020202020202020202020e29a982020202020e29a9860008201527f0a00000000000000000000000000000000000000000000000000000000000000602082015250565b6000611dea602183611250565b9150611df582611d8e565b602182019050919050565b7f202020202020e29a982020202020202020e29a980a0000000000000000000000815250565b7f2020202020202020202020202020202020202020202020e29a980a0000000000815250565b7f202020202020202020202020e29a980a00000000000000000000000000000000815250565b7f202020202020202020203c2f7072653e00000000000000000000000000000000815250565b7f3c62723e3c62723e000000000000000000000000000000000000000000000000815250565b7f3c68313e00000000000000000000000000000000000000000000000000000000815250565b7f3c2f68313e3c6272202f3e3c6272202f3e000000000000000000000000000000815250565b7f3c703e0000000000000000000000000000000000000000000000000000000000815250565b7f4120636f6e74726163742073686f77206f7267616e697a656420627920000000815250565b7f3c6120687265663d2268747470733a2f2f30786666662e6c6f7665222074617260008201527f6765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f72656660208201527f6572726572223e30786666663c2f613e3c6272202f3e7769746820737065636960408201527f616c207468616e6b7320746f2000000000000000000000000000000000000000606082015250565b6000611ffe606d83611250565b915061200982611f56565b606d82019050919050565b7f3c6120687265663d2268747470733a2f2f782e636f6d2f7373736c756b65312260008201527f207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e60208201527f6f7265666572726572223e7373736c756b653c2f613e20616e64203c6120687260408201527f65663d2268747470733a2f2f782e636f6d2f307831313364222072656c3d226e60608201527f6f6f70656e6572206e6f726566657272657222207461726765743d225f626c6160808201527f6e6b223e3131333c2f613e00000000000000000000000000000000000000000060a082015250565b600061210860ab83611250565b915061211382612014565b60ab82019050919050565b7f3c2f703e00000000000000000000000000000000000000000000000000000000815250565b7f3c6272202f3e0000000000000000000000000000000000000000000000000000815250565b6000612176828561125b565b915061218182611caa565b60068201915061219082611cd0565b600f8201915061219f82611cf6565b6014820191506121ae82611d1c565b6009820191506121bd82611d42565b601e820191506121cc82611d68565b600c820191506121db82611ddd565b91506121e682611e00565b6015820191506121f582611e26565b601b8201915061220482611e4c565b60108201915061221382611e72565b60108201915061222282611e98565b60088201915061223182611ebe565b600482019150612241828461125b565b915061224c82611ee4565b60118201915061225b82611f0a565b60038201915061226a82611f30565b601d8201915061227982611ff1565b9150612284826120fb565b915061228f8261211e565b60048201915061229e82612144565b6006820191508190509392505050565b600067ffffffffffffffff8211156122c9576122c86110eb565b5b602082029050602081019050919050565b600080fd5b6122e881611091565b81146122f357600080fd5b50565b600081519050612305816122df565b92915050565b600061231e612319846122ae565b61114b565b90508083825260208201905060208402830185811115612341576123406122da565b5b835b8181101561236a578061235688826122f6565b845260208401935050602081019050612343565b5050509392505050565b600082601f830112612389576123886110e1565b5b815161239984826020860161230b565b91505092915050565b6000602082840312156123b8576123b76110d7565b5b600082015167ffffffffffffffff8111156123d6576123d56110dc565b5b6123e284828501612374565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f3c64697620636c6173733d2277223e3c64697620636c6173733d2273223e0000815250565b600061244c828461125b565b91506124578261241a565b601e8201915081905092915050565b600067ffffffffffffffff821115612481576124806110eb565b5b602082029050602081019050919050565b60006124a56124a084612466565b61114b565b905080838252602082019050602084028301858111156124c8576124c76122da565b5b835b8181101561250f57805167ffffffffffffffff8111156124ed576124ec6110e1565b5b8086016124fa89826111d9565b855260208501945050506020810190506124ca565b5050509392505050565b600082601f83011261252e5761252d6110e1565b5b815161253e848260208601612492565b91505092915050565b60006020828403121561255d5761255c6110d7565b5b600082015167ffffffffffffffff81111561257b5761257a6110dc565b5b61258784828501612519565b91505092915050565b7f3c68323e00000000000000000000000000000000000000000000000000000000815250565b60006125c2828461125b565b91506125cd82612590565b60048201915081905092915050565b7f3c62722f3e000000000000000000000000000000000000000000000000000000815250565b600061260e828561125b565b915061261a828461125b565b9150612625826125dc565b6005820191508190509392505050565b7f3c2f68323e000000000000000000000000000000000000000000000000000000815250565b6000612667828461125b565b915061267282612635565b60058201915081905092915050565b7f3c68333e3c693e00000000000000000000000000000000000000000000000000815250565b7f3c2f693e3c2f68333e0000000000000000000000000000000000000000000000815250565b60006126d9828561125b565b91506126e482612681565b6007820191506126f4828461125b565b91506126ff826126a7565b6009820191508190509392505050565b7f556e7469746c6564000000000000000000000000000000000000000000000000815250565b6000612741828461125b565b915061274c82612681565b60078201915061275b8261270f565b60088201915061276a826126a7565b60098201915081905092915050565b6000612785828461125b565b915061279082611f0a565b60038201915081905092915050565b60006127ab828461125b565b91506127b68261211e565b60048201915081905092915050565b7f536172616820467269656e640000000000000000000000000000000000000000600082015250565b60006127fb600c83611250565b9150612806826127c5565b600c82019050919050565b600061281c826127ee565b9150819050919050565b6000612832828461125b565b915081905092915050565b7f3c64697620636c6173733d2274223e3c7072653e000000000000000000000000815250565b7f3c2f7072653e3c2f6469763e0000000000000000000000000000000000000000815250565b6000612895828561125b565b91506128a08261283d565b6014820191506128b0828461125b565b91506128bb82612863565b600c820191508190509392505050565b7f3c64697620636c6173733d2274223e3c703e0000000000000000000000000000815250565b7f3c2f703e3c2f6469763e00000000000000000000000000000000000000000000815250565b6000612923828561125b565b915061292e826128cb565b60128201915061293e828461125b565b9150612949826128f1565b600a820191508190509392505050565b7f3c2f6469763e3c2f6469763e0000000000000000000000000000000000000000815250565b600061298b828461125b565b915061299682612959565b600c8201915081905092915050565b7f3c64697620636c6173733d2269223e47656e65726174656420617420626c6f6360008201527f6b20000000000000000000000000000000000000000000000000000000000000602082015250565b6000612a01602283611250565b9150612a0c826129a5565b602282019050919050565b7f2028000000000000000000000000000000000000000000000000000000000000815250565b7f293c2f6469763e00000000000000000000000000000000000000000000000000815250565b6000612a6f828661125b565b9150612a7a826129f4565b9150612a86828561125b565b9150612a9182612a17565b600282019150612aa1828461125b565b9150612aac82612a3d565b600782019150819050949350505050565b7f3c2f6469763e3c2f626f64793e3c2f68746d6c3e000000000000000000000000815250565b6000612aef828461125b565b9150612afa82612abd565b60148201915081905092915050565b7f3c6120687265663d220000000000000000000000000000000000000000000000815250565b7f22207461726765743d225f626c616e6b222072656c3d226e6f6f70656e65722060008201527f6e6f7265666572726572223e0000000000000000000000000000000000000000602082015250565b6000612b8b602c83611250565b9150612b9682612b2f565b602c82019050919050565b7f3c2f613e00000000000000000000000000000000000000000000000000000000815250565b6000612bd282612b09565b600982019150612be2828561125b565b9150612bed82612b7e565b9150612bf9828461125b565b9150612c0482612ba1565b6004820191508190509392505050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000612c5882612c14565b9150612c6383612c14565b9250828203905081811115612c7b57612c7a612c1e565b5b92915050565b6000612c8c82612c14565b9150612c9783612c14565b9250828201905080821115612caf57612cae612c1e565b5b9291505056fea26469706673582212202db36ccab7a660e1a71318e355e0b0bcbc0204732a69c1b814d5e7bc01d094d464736f6c634300081b0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100365760003560e01c806333c34ac31461003b57806356ba88b814610059575b600080fd5b610043610077565b604051610050919061104f565b60405180910390f35b610061610a57565b60405161006e91906110b2565b60405180910390f35b606060006040518060400160405280600681526020017f3c68746d6c3e00000000000000000000000000000000000000000000000000008152509050807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561011f573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906101489190611207565b604051602001610159929190611b74565b6040516020818303038152906040529050807f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156101d6573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906101ff9190611207565b60405160200161021092919061216a565b604051602081830303815290604052905060007f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561028e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906102b791906123a2565b905060005b81518110156109f65760008282815181106102da576102d96123eb565b5b6020026020010151905060008173ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610331573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061035a9190611207565b90508460405160200161036d9190612440565b604051602081830303815290604052945060008273ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa1580156103cb573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906103f49190612547565b90506000815111156104c2578560405160200161041191906125b6565b604051602081830303815290604052955060005b815181101561049e576000828281518110610443576104426123eb565b5b60200260200101515103156104915786828281518110610466576104656123eb565b5b602002602001015160405160200161047f929190612602565b60405160208183030381529060405296505b8080600101915050610425565b50856040516020016104b0919061265b565b60405160208183030381529060405295505b6000825111156104f55785826040516020016104df9291906126cd565b6040516020818303038152906040529550610518565b856040516020016105069190612735565b60405160208183030381529060405295505b60008373ffffffffffffffffffffffffffffffffffffffff1663da0321cd6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610565573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061058e91906123a2565b905060008151111561063f57866040516020016105ab9190612779565b604051602081830303815290604052965060005b815181101561061b57876105ec8383815181106105df576105de6123eb565b5b6020026020010151610a7b565b6040516020016105fd929190612602565b604051602081830303815290604052975080806001019150506105bf565b508660405160200161062d919061279f565b60405160208183030381529060405296505b60008473ffffffffffffffffffffffffffffffffffffffff16632c73dc4a6040518163ffffffff1660e01b8152600401600060405180830381865afa15801561068c573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906106b59190612547565b905060008151111561078b57876040516020016106d29190612779565b604051602081830303815290604052975060005b8151811015610767576000828281518110610704576107036123eb565b5b602002602001015151031561075a578861073783838151811061072a576107296123eb565b5b6020026020010151610aa1565b604051602001610748929190612602565b60405160208183030381529060405298505b80806001019150506106e6565b5087604051602001610779919061279f565b60405160208183030381529060405297505b60008573ffffffffffffffffffffffffffffffffffffffff16631f1bd6926040518163ffffffff1660e01b8152600401600060405180830381865afa1580156107d8573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906108019190611207565b90506000808773ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa158015610851573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061087a9190612547565b5111801561095f575060405160200161089290612811565b604051602081830303815290604052805190602001208773ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa1580156108f3573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f8201168201806040525081019061091c9190612547565b60008151811061092f5761092e6123eb565b5b60200260200101516040516020016109479190612826565b60405160208183030381529060405280519060200120145b90506000825111156109c057801561099a578982604051602001610984929190612889565b60405160208183030381529060405299506109bf565b89826040516020016109ad929190612917565b60405160208183030381529060405299505b5b896040516020016109d1919061297f565b60405160208183030381529060405299505050505050505080806001019150506102bc565b5081610a0143610ada565b610a0a42610ada565b604051602001610a1c93929190612a63565b604051602081830303815290604052915081604051602001610a3e9190612ae3565b6040516020818303038152906040529150819250505090565b7f000000000000000000000000000000000000000000000000000000000000000081565b6060610a8682610b2b565b90506002815101613078825260028203915080825250919050565b60606000610aae83610bae565b90508281604051602001610ac3929190612bc7565b604051602081830303815290604052915050919050565b60606080604051019050602081016040526000815280600019835b600115610b16578184019350600a81066030018453600a8104905080610af5575b50828203602084039350808452505050919050565b60606040519050608081016040526f30313233343536373839616263646566600f526002810190506028815260208101600060288201528260601b925060005b600115610ba757808101820184821a600f81165160018301538060041c51825360018301925060148303610ba0575050610ba7565b5050610b6b565b5050919050565b6060600082905060008151905060008082905060005b600284610bd19190612c4d565b811015610d4c577f3a00000000000000000000000000000000000000000000000000000000000000858281518110610c0c57610c0b6123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916148015610cb057507f2f0000000000000000000000000000000000000000000000000000000000000085600183610c709190612c81565b81518110610c8157610c806123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8015610d2657507f2f0000000000000000000000000000000000000000000000000000000000000085600283610ce69190612c81565b81518110610cf757610cf66123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610d3f57600381610d389190612c81565b9250610d4c565b8080600101915050610bc4565b5060008290505b83811015610e40577f3f00000000000000000000000000000000000000000000000000000000000000858281518110610d8f57610d8e6123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161480610e2657507f2300000000000000000000000000000000000000000000000000000000000000858281518110610df757610df66123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610e3357809150610e40565b8080600101915050610d53565b508181118015610eba57507f2f0000000000000000000000000000000000000000000000000000000000000084600183610e7a9190612c4d565b81518110610e8b57610e8a6123eb565b5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b15610ecf57600181610ecc9190612c4d565b90505b60008282610edd9190612c4d565b67ffffffffffffffff811115610ef657610ef56110eb565b5b6040519080825280601f01601f191660200182016040528015610f285781602001600182028036833780820191505090505b50905060008390505b82811015610fb157858181518110610f4c57610f4b6123eb565b5b602001015160f81c60f81b828583610f649190612c4d565b81518110610f7557610f746123eb565b5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610f31565b508095505050505050919050565b600081519050919050565b600082825260208201905092915050565b60005b83811015610ff9578082015181840152602081019050610fde565b60008484015250505050565b6000601f19601f8301169050919050565b600061102182610fbf565b61102b8185610fca565b935061103b818560208601610fdb565b61104481611005565b840191505092915050565b600060208201905081810360008301526110698184611016565b905092915050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061109c82611071565b9050919050565b6110ac81611091565b82525050565b60006020820190506110c760008301846110a3565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b61112382611005565b810181811067ffffffffffffffff82111715611142576111416110eb565b5b80604052505050565b60006111556110cd565b9050611161828261111a565b919050565b600067ffffffffffffffff821115611181576111806110eb565b5b61118a82611005565b9050602081019050919050565b60006111aa6111a584611166565b61114b565b9050828152602081018484840111156111c6576111c56110e6565b5b6111d1848285610fdb565b509392505050565b600082601f8301126111ee576111ed6110e1565b5b81516111fe848260208601611197565b91505092915050565b60006020828403121561121d5761121c6110d7565b5b600082015167ffffffffffffffff81111561123b5761123a6110dc565b5b611247848285016111d9565b91505092915050565b600081905092915050565b600061126682610fbf565b6112708185611250565b9350611280818560208601610fdb565b80840191505092915050565b7f3c686561643e0000000000000000000000000000000000000000000000000000815250565b7f3c6d65746120636861727365743d225554462d38223e00000000000000000000815250565b7f3c6d657461206e616d653d2276696577706f72742220636f6e74656e743d227760008201527f696474683d6465766963652d77696474682c20696e697469616c2d7363616c6560208201527f3d312e30223e0000000000000000000000000000000000000000000000000000604082015250565b600061135a604683611250565b9150611365826112d8565b604682019050919050565b7f3c7469746c653e00000000000000000000000000000000000000000000000000815250565b7f3c2f7469746c653e000000000000000000000000000000000000000000000000815250565b7f3c2f686561643e00000000000000000000000000000000000000000000000000815250565b7f3c7374796c653e00000000000000000000000000000000000000000000000000815250565b7f2a2c202a3a3a6265666f72652c202a3a3a6166746572207b20626f782d73697a60008201527f696e673a20626f726465722d626f783b207d0000000000000000000000000000602082015250565b6000611464603283611250565b915061146f82611408565b603282019050919050565b7f68746d6c207b202d6d6f7a2d746578742d73697a652d61646a7573743a206e6f60008201527f6e653b202d7765626b69742d746578742d73697a652d61646a7573743a206e6f60208201527f6e653b20746578742d73697a652d61646a7573743a206e6f6e653b207d000000604082015250565b60006114fc605d83611250565b91506115078261147a565b605d82019050919050565b7f68746d6c2c20626f6479207b206d617267696e3a20303b2070616464696e673a60008201527f20303b207d20626f6479207b206d696e2d6865696768743a203130307668207d602082015250565b600061156e604083611250565b915061157982611512565b604082019050919050565b7f68746d6c2c626f64792c707265207b20666f6e742d66616d696c793a2022436f60008201527f7572696572204e6577222c2022436f7572696572222c206d6f6e6f737061636560208201527f3b20666f6e742d73697a653a20313570783b207d000000000000000000000000604082015250565b6000611606605483611250565b915061161182611584565b605482019050919050565b7f68312c68322c6833207b206d617267696e3a20303b20666f6e742d73697a653a60008201527f20696e68657269743b20666f6e742d7374796c653a20696e68657269743b206660208201527f6f6e742d7765696768743a20696e68657269743b7d0000000000000000000000604082015250565b600061169e605583611250565b91506116a98261161c565b605582019050919050565b7f2e63207b206d61782d77696474683a2038343070783b206d617267696e3a203560008201527f656d206175746f3b2070616464696e673a20312e35656d3b207d000000000000602082015250565b6000611710603a83611250565b915061171b826116b4565b603a82019050919050565b7f406d656469612073637265656e20616e6420286d61782d77696474683a20373660008201527f30707829207b202e63207b206d617267696e3a20322e35656d206175746f3b2060208201527f7d207d0000000000000000000000000000000000000000000000000000000000604082015250565b60006117a8604383611250565b91506117b382611726565b604382019050919050565b7f61207b20636f6c6f723a20696e68657269743b20746578742d6465636f72617460008201527f696f6e3a20756e6465726c696e653b207d000000000000000000000000000000602082015250565b600061181a603183611250565b9150611825826117be565b603182019050919050565b7f2e77207b206d696e2d6865696768743a2031303076683b20646973706c61793a60008201527f20666c65783b20616c69676e2d6974656d733a2063656e7465723b20626f782d60208201527f73697a696e673a20626f726465722d626f783b2070616464696e673a2031306560408201527f6d20303b207d0000000000000000000000000000000000000000000000000000606082015250565b60006118d8606683611250565b91506118e382611830565b606682019050919050565b7f2e73207b2077696474683a20313030253b206d61782d77696474683a2038343060008201527f70783b207d000000000000000000000000000000000000000000000000000000602082015250565b600061194a602583611250565b9150611955826118ee565b602582019050919050565b7f2e732061207b20746578742d6465636f726174696f6e3a206e6f6e653b206d6160008201527f782d77696474683a20313030253b20646973706c61793a20696e6c696e652d6260208201527f6c6f636b3b2077686974652d73706163653a206e6f777261703b206f7665726660408201527f6c6f773a2068696464656e3b20746578742d6f766572666c6f773a20656c6c6960608201527f707369733b207d00000000000000000000000000000000000000000000000000608082015250565b6000611a2e608783611250565b9150611a3982611960565b608782019050919050565b7f2e74207b206d61782d77696474683a20313030253b206f766572666c6f772d7860008201527f3a207363726f6c6c3b207d000000000000000000000000000000000000000000602082015250565b6000611aa0602b83611250565b9150611aab82611a44565b602b82019050919050565b7f2e69207b206d617267696e3a203530766820302035656d3b207d000000000000815250565b7f7072652e67617264656e207b206c696e652d6865696768743a20312e333b206660008201527f6f6e742d73697a653a20312e3272656d3b7d0000000000000000000000000000602082015250565b6000611b38603283611250565b9150611b4382611adc565b603282019050919050565b7f3c2f7374796c653e000000000000000000000000000000000000000000000000815250565b6000611b80828561125b565b9150611b8b8261128c565b600682019150611b9a826112b2565b601682019150611ba98261134d565b9150611bb482611370565b600782019150611bc4828461125b565b9150611bcf82611396565b600882019150611bde826113bc565b600782019150611bed826113e2565b600782019150611bfc82611457565b9150611c07826114ef565b9150611c1282611561565b9150611c1d826115f9565b9150611c2882611691565b9150611c3382611703565b9150611c3e8261179b565b9150611c498261180d565b9150611c54826118cb565b9150611c5f8261193d565b9150611c6a82611a21565b9150611c7582611a93565b9150611c8082611ab6565b601a82019150611c8f82611b2b565b9150611c9a82611b4e565b6008820191508190509392505050565b7f3c626f64793e0000000000000000000000000000000000000000000000000000815250565b7f3c64697620636c6173733d2263223e0000000000000000000000000000000000815250565b7f3c70726520636c6173733d2267617264656e223e000000000000000000000000815250565b7f2020202020e29a980a0000000000000000000000000000000000000000000000815250565b7f2020202020202020202020202020e29a98202020202020202020e29a980a0000815250565b7f2020202020202020e29a980a0000000000000000000000000000000000000000815250565b7f202020202020202020202020202020202020202020e29a982020202020e29a9860008201527f0a00000000000000000000000000000000000000000000000000000000000000602082015250565b6000611dea602183611250565b9150611df582611d8e565b602182019050919050565b7f202020202020e29a982020202020202020e29a980a0000000000000000000000815250565b7f2020202020202020202020202020202020202020202020e29a980a0000000000815250565b7f202020202020202020202020e29a980a00000000000000000000000000000000815250565b7f202020202020202020203c2f7072653e00000000000000000000000000000000815250565b7f3c62723e3c62723e000000000000000000000000000000000000000000000000815250565b7f3c68313e00000000000000000000000000000000000000000000000000000000815250565b7f3c2f68313e3c6272202f3e3c6272202f3e000000000000000000000000000000815250565b7f3c703e0000000000000000000000000000000000000000000000000000000000815250565b7f4120636f6e74726163742073686f77206f7267616e697a656420627920000000815250565b7f3c6120687265663d2268747470733a2f2f30786666662e6c6f7665222074617260008201527f6765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e6f72656660208201527f6572726572223e30786666663c2f613e3c6272202f3e7769746820737065636960408201527f616c207468616e6b7320746f2000000000000000000000000000000000000000606082015250565b6000611ffe606d83611250565b915061200982611f56565b606d82019050919050565b7f3c6120687265663d2268747470733a2f2f782e636f6d2f7373736c756b65312260008201527f207461726765743d225f626c616e6b222072656c3d226e6f6f70656e6572206e60208201527f6f7265666572726572223e7373736c756b653c2f613e20616e64203c6120687260408201527f65663d2268747470733a2f2f782e636f6d2f307831313364222072656c3d226e60608201527f6f6f70656e6572206e6f726566657272657222207461726765743d225f626c6160808201527f6e6b223e3131333c2f613e00000000000000000000000000000000000000000060a082015250565b600061210860ab83611250565b915061211382612014565b60ab82019050919050565b7f3c2f703e00000000000000000000000000000000000000000000000000000000815250565b7f3c6272202f3e0000000000000000000000000000000000000000000000000000815250565b6000612176828561125b565b915061218182611caa565b60068201915061219082611cd0565b600f8201915061219f82611cf6565b6014820191506121ae82611d1c565b6009820191506121bd82611d42565b601e820191506121cc82611d68565b600c820191506121db82611ddd565b91506121e682611e00565b6015820191506121f582611e26565b601b8201915061220482611e4c565b60108201915061221382611e72565b60108201915061222282611e98565b60088201915061223182611ebe565b600482019150612241828461125b565b915061224c82611ee4565b60118201915061225b82611f0a565b60038201915061226a82611f30565b601d8201915061227982611ff1565b9150612284826120fb565b915061228f8261211e565b60048201915061229e82612144565b6006820191508190509392505050565b600067ffffffffffffffff8211156122c9576122c86110eb565b5b602082029050602081019050919050565b600080fd5b6122e881611091565b81146122f357600080fd5b50565b600081519050612305816122df565b92915050565b600061231e612319846122ae565b61114b565b90508083825260208201905060208402830185811115612341576123406122da565b5b835b8181101561236a578061235688826122f6565b845260208401935050602081019050612343565b5050509392505050565b600082601f830112612389576123886110e1565b5b815161239984826020860161230b565b91505092915050565b6000602082840312156123b8576123b76110d7565b5b600082015167ffffffffffffffff8111156123d6576123d56110dc565b5b6123e284828501612374565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f3c64697620636c6173733d2277223e3c64697620636c6173733d2273223e0000815250565b600061244c828461125b565b91506124578261241a565b601e8201915081905092915050565b600067ffffffffffffffff821115612481576124806110eb565b5b602082029050602081019050919050565b60006124a56124a084612466565b61114b565b905080838252602082019050602084028301858111156124c8576124c76122da565b5b835b8181101561250f57805167ffffffffffffffff8111156124ed576124ec6110e1565b5b8086016124fa89826111d9565b855260208501945050506020810190506124ca565b5050509392505050565b600082601f83011261252e5761252d6110e1565b5b815161253e848260208601612492565b91505092915050565b60006020828403121561255d5761255c6110d7565b5b600082015167ffffffffffffffff81111561257b5761257a6110dc565b5b61258784828501612519565b91505092915050565b7f3c68323e00000000000000000000000000000000000000000000000000000000815250565b60006125c2828461125b565b91506125cd82612590565b60048201915081905092915050565b7f3c62722f3e000000000000000000000000000000000000000000000000000000815250565b600061260e828561125b565b915061261a828461125b565b9150612625826125dc565b6005820191508190509392505050565b7f3c2f68323e000000000000000000000000000000000000000000000000000000815250565b6000612667828461125b565b915061267282612635565b60058201915081905092915050565b7f3c68333e3c693e00000000000000000000000000000000000000000000000000815250565b7f3c2f693e3c2f68333e0000000000000000000000000000000000000000000000815250565b60006126d9828561125b565b91506126e482612681565b6007820191506126f4828461125b565b91506126ff826126a7565b6009820191508190509392505050565b7f556e7469746c6564000000000000000000000000000000000000000000000000815250565b6000612741828461125b565b915061274c82612681565b60078201915061275b8261270f565b60088201915061276a826126a7565b60098201915081905092915050565b6000612785828461125b565b915061279082611f0a565b60038201915081905092915050565b60006127ab828461125b565b91506127b68261211e565b60048201915081905092915050565b7f536172616820467269656e640000000000000000000000000000000000000000600082015250565b60006127fb600c83611250565b9150612806826127c5565b600c82019050919050565b600061281c826127ee565b9150819050919050565b6000612832828461125b565b915081905092915050565b7f3c64697620636c6173733d2274223e3c7072653e000000000000000000000000815250565b7f3c2f7072653e3c2f6469763e0000000000000000000000000000000000000000815250565b6000612895828561125b565b91506128a08261283d565b6014820191506128b0828461125b565b91506128bb82612863565b600c820191508190509392505050565b7f3c64697620636c6173733d2274223e3c703e0000000000000000000000000000815250565b7f3c2f703e3c2f6469763e00000000000000000000000000000000000000000000815250565b6000612923828561125b565b915061292e826128cb565b60128201915061293e828461125b565b9150612949826128f1565b600a820191508190509392505050565b7f3c2f6469763e3c2f6469763e0000000000000000000000000000000000000000815250565b600061298b828461125b565b915061299682612959565b600c8201915081905092915050565b7f3c64697620636c6173733d2269223e47656e65726174656420617420626c6f6360008201527f6b20000000000000000000000000000000000000000000000000000000000000602082015250565b6000612a01602283611250565b9150612a0c826129a5565b602282019050919050565b7f2028000000000000000000000000000000000000000000000000000000000000815250565b7f293c2f6469763e00000000000000000000000000000000000000000000000000815250565b6000612a6f828661125b565b9150612a7a826129f4565b9150612a86828561125b565b9150612a9182612a17565b600282019150612aa1828461125b565b9150612aac82612a3d565b600782019150819050949350505050565b7f3c2f6469763e3c2f626f64793e3c2f68746d6c3e000000000000000000000000815250565b6000612aef828461125b565b9150612afa82612abd565b60148201915081905092915050565b7f3c6120687265663d220000000000000000000000000000000000000000000000815250565b7f22207461726765743d225f626c616e6b222072656c3d226e6f6f70656e65722060008201527f6e6f7265666572726572223e0000000000000000000000000000000000000000602082015250565b6000612b8b602c83611250565b9150612b9682612b2f565b602c82019050919050565b7f3c2f613e00000000000000000000000000000000000000000000000000000000815250565b6000612bd282612b09565b600982019150612be2828561125b565b9150612bed82612b7e565b9150612bf9828461125b565b9150612c0482612ba1565b6004820191508190509392505050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000612c5882612c14565b9150612c6383612c14565b9250828203905081811115612c7b57612c7a612c1e565b5b92915050565b6000612c8c82612c14565b9150612c9783612c14565b9250828201905080821115612caf57612cae612c1e565b5b9291505056fea26469706673582212202db36ccab7a660e1a71318e355e0b0bcbc0204732a69c1b814d5e7bc01d094d464736f6c634300081b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}