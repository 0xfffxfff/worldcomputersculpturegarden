{
  "address": "0x3bF65c9E3eE42f5E3eCF258345582F4Ba79C80A2",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "AlreadyInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NewOwnerIsZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoHandoverRequest",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipHandoverCanceled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipHandoverRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "oldOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "addresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "authors",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "cancelOwnershipHandover",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "completeOwnershipHandover",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address payable",
          "name": "newGardenAddress",
          "type": "address"
        }
      ],
      "name": "configure",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "workIndex",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "workAddress",
          "type": "address"
        },
        {
          "internalType": "uint8",
          "name": "critique",
          "type": "uint8"
        }
      ],
      "name": "critiqueWork",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "result",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pendingOwner",
          "type": "address"
        }
      ],
      "name": "ownershipHandoverExpiresAt",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "requestOwnershipHandover",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "text",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "title",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "urls",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x58061fd875b64d92c1e6c02d89411785f9612ef456ab3d978c86011d007a1f27",
  "receipt": {
    "to": null,
    "from": "0x116ADF6db6aBF17828530Ca868Cac4A80af9f9c2",
    "contractAddress": "0x3bF65c9E3eE42f5E3eCF258345582F4Ba79C80A2",
    "transactionIndex": 59,
    "gasUsed": "2183991",
    "logsBloom": "0x00000001000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020001000000000000000000100000000000000000020000000000000000000800000000000000000000000000000000400000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000020000000000004000000000000000000000000800000000000000000000000000000",
    "blockHash": "0x5ebdfe0d10e12db5080fe37eecde8e9d6a2f6b3a3ef9a4fdd51c116cf99ee2f8",
    "transactionHash": "0x58061fd875b64d92c1e6c02d89411785f9612ef456ab3d978c86011d007a1f27",
    "logs": [
      {
        "transactionIndex": 59,
        "blockNumber": 6800571,
        "transactionHash": "0x58061fd875b64d92c1e6c02d89411785f9612ef456ab3d978c86011d007a1f27",
        "address": "0x3bF65c9E3eE42f5E3eCF258345582F4Ba79C80A2",
        "topics": [
          "0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0",
          "0x0000000000000000000000000000000000000000000000000000000000000000",
          "0x000000000000000000000000116adf6db6abf17828530ca868cac4a80af9f9c2"
        ],
        "data": "0x",
        "logIndex": 172,
        "blockHash": "0x5ebdfe0d10e12db5080fe37eecde8e9d6a2f6b3a3ef9a4fdd51c116cf99ee2f8"
      }
    ],
    "blockNumber": 6800571,
    "cumulativeGasUsed": "15311295",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "1c7a33c2368feecec172da447792b304",
  "metadata": "{\"compiler\":{\"version\":\"0.8.27+commit.40a35a09\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NewOwnerIsZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoHandoverRequest\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"OwnershipHandoverRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"authors\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cancelOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"completeOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newGardenAddress\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"workIndex\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"workAddress\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"critique\",\"type\":\"uint8\"}],\"name\":\"critiqueWork\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"result\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner\",\"type\":\"address\"}],\"name\":\"ownershipHandoverExpiresAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestOwnershipHandover\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"text\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"title\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"urls\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AlreadyInitialized()\":[{\"details\":\"Cannot double-initialize.\"}],\"NewOwnerIsZeroAddress()\":[{\"details\":\"The `newOwner` cannot be the zero address.\"}],\"NoHandoverRequest()\":[{\"details\":\"The `pendingOwner` does not have a valid handover request.\"}],\"Unauthorized()\":[{\"details\":\"The caller is not authorized to call the function.\"}]},\"events\":{\"OwnershipHandoverCanceled(address)\":{\"details\":\"The ownership handover to `pendingOwner` has been canceled.\"},\"OwnershipHandoverRequested(address)\":{\"details\":\"An ownership handover to `pendingOwner` has been requested.\"},\"OwnershipTransferred(address,address)\":{\"details\":\"The ownership is transferred from `oldOwner` to `newOwner`. This event is intentionally kept the same as OpenZeppelin's Ownable to be compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173), despite it not being as lightweight as a single argument event.\"}},\"kind\":\"dev\",\"methods\":{\"cancelOwnershipHandover()\":{\"details\":\"Cancels the two-step ownership handover to the caller, if any.\"},\"completeOwnershipHandover(address)\":{\"details\":\"Allows the owner to complete the two-step ownership handover to `pendingOwner`. Reverts if there is no existing ownership handover requested by `pendingOwner`.\"},\"owner()\":{\"details\":\"Returns the owner of the contract.\"},\"ownershipHandoverExpiresAt(address)\":{\"details\":\"Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\"},\"renounceOwnership()\":{\"details\":\"Allows the owner to renounce their ownership.\"},\"requestOwnershipHandover()\":{\"details\":\"Request a two-step ownership handover to the caller. The request will automatically expire in 48 hours (172800 seconds) by default.\"},\"transferOwnership(address)\":{\"details\":\"Allows the owner to transfer the ownership to `newOwner`.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ShowCritique.sol\":\"ShowCritique\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/Garden.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.27;\\n\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"./Sculpture.sol\\\";\\nimport \\\"./Web.sol\\\";\\n\\ncontract Garden is Sculpture, Ownable {\\n\\n    address[] public sculptures;\\n\\n    address public immutable render;\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    // Init\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    constructor(address[] memory _sculptures, address _render) {\\n        sculptures = _sculptures;\\n        render = _render;\\n\\n        _initializeOwner(msg.sender);\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    // Stop by and say hi\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    receive() external payable {\\n        sign();\\n    }\\n\\n    fallback() external payable {\\n        revert(IWeb(render).html());\\n    }\\n\\n    function html() external view returns (string memory) {\\n        return IWeb(render).html();\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    // Sculpture Management\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    function getSculptures() public view returns (address[] memory) {\\n        return sculptures;\\n    }\\n\\n    function setSculptures(address[] memory _sculptures) public onlyOwner {\\n        sculptures = _sculptures;\\n    }\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    // Show/Sculpture\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    function title() external pure returns (string memory) {\\n        return \\\"World Computer Sculpture Garden\\\";\\n    }\\n\\n    function authors() external view returns (string[] memory) {\\n        uint256 length;\\n        for (uint256 i = 0; i < sculptures.length; i++) {\\n            string[] memory sculptureAuthors = Sculpture(sculptures[i]).authors();\\n            for (uint256 j = 0; j < sculptureAuthors.length; j++) {\\n                length++;\\n            }\\n        }\\n        string[] memory authors_ = new string[](length);\\n        uint256 index;\\n        for (uint256 i = 0; i < sculptures.length; i++) {\\n            string[] memory sculptureAuthors = Sculpture(sculptures[i]).authors();\\n            for (uint256 j = 0; j < sculptureAuthors.length; j++) {\\n                authors_[index] = sculptureAuthors[j];\\n                index++;\\n            }\\n        }\\n        return authors_;\\n    }\\n\\n    function addresses() external view returns (address[] memory) {\\n        address[] memory addresses_;\\n        for (uint256 i = 0; i < sculptures.length; i++) {\\n            Sculpture sculpture = Sculpture(sculptures[i]);\\n            address[] memory sculptureAddresses = sculpture.addresses();\\n            for (uint256 j = 0; j < sculptureAddresses.length; j++) {\\n                addresses_[addresses_.length] = sculpture.addresses()[j];\\n            }\\n        }\\n        return addresses_;\\n    }\\n\\n    function text() public view returns (string memory) {\\n        return \\\"here be exhibition text\\\";\\n    }\\n\\n    function urls() public view returns (string[] memory) {\\n        string[] memory urls_;\\n        // Here be a link\\n        return urls_;\\n    }\\n\\n\\n    ///////////////////////////////////////////////////////////////////////////\\n    // Public Garden Contributions\\n    // TODO: Credit 113\\n    ///////////////////////////////////////////////////////////////////////////\\n\\n    event ContributionMade(address indexed contributor, uint256 amount);\\n\\n    uint256 public contributed;\\n    mapping(uint256 => uint256) public contributions;\\n\\n    /// @notice Contribute and plant a tree in the garden\\n    function sign() public payable {\\n        require(msg.value >= 0.01 ether, \\\"Contribute at least 0.01\\\");\\n        contributed += 1;\\n        uint256 amount = msg.value / 0.01 ether;\\n        contributions[contributed] = uint256(\\n            (amount << 160) | uint160(msg.sender)\\n        );\\n        emit ContributionMade(msg.sender, msg.value);\\n    }\\n\\n    function getContribution(uint256 index) public view returns (address contributor, uint256 amount) {\\n        uint256 contribution = contributions[index];\\n        contributor = address(uint160(contribution));\\n        amount = contribution >> 160;\\n    }\\n\\n    function getContributed() public view returns (uint256) {\\n        return contributed;\\n    }\\n}\",\"keccak256\":\"0x45772a2e9d9d71068adb8edc909450cb3bdd27d5ebf6966713ee38bc6f6545c4\",\"license\":\"UNLICENSED\"},\"contracts/Sculpture.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\ninterface Sculpture {\\n\\n    function title() external view returns (string memory);\\n\\n    function authors() external view returns (string[] memory);\\n\\n    function addresses() external view returns (address[] memory);\\n\\n    function urls() external view returns (string[] memory);\\n\\n    function text() external view returns (string memory);\\n\\n}\\n\",\"keccak256\":\"0x42a64bba30b562f327b8313eb924643e9a8e2b39d4f330c9ed2cacdf4d027052\",\"license\":\"UNLICENSED\"},\"contracts/ShowCritique.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// Show Critique.\\n// By Rhea Myers.\\n// Copyright 2024 Myers Studio Ltd.\\npragma solidity >=0.8.0;\\n\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\nimport \\\"./Sculpture.sol\\\";\\nimport \\\"./Garden.sol\\\";\\n\\ncontract ShowCritique is Sculpture, Ownable {\\n\\n    struct Critique {\\n        address critic;\\n        uint8 critique;\\n    }\\n\\n    uint256 private constant OPINIONS_COUNT = 16;\\n\\n    string[OPINIONS_COUNT] private OPINIONS = [\\n        \\\"totally awesome\\\",\\n        \\\"entirely excellent\\\",\\n        \\\"transcendently fascinating\\\",\\n        \\\"completely intriguing\\\",\\n        \\\"deeply moving\\\",\\n        \\\"profoundly affecting\\\",\\n        \\\"groundbreaking\\\",\\n        \\\"so cute\\\",\\n        \\\"totes adorbs\\\",\\n        \\\"strikingly profound\\\",\\n        \\\"triumphantly skilful\\\",\\n        \\\"a revelation\\\",\\n        \\\"unignorably brilliant\\\",\\n        \\\"thought provoking\\\",\\n        \\\"intellectually stimulating\\\",\\n        \\\"visually stimulating\\\"\\n    ];\\n\\n    mapping(address => Critique) private critiques;\\n    address payable private gardenAddress;\\n\\n    constructor () {\\n        _initializeOwner(msg.sender);\\n    }\\n\\n    function configure (address payable newGardenAddress) external onlyOwner {\\n        gardenAddress = newGardenAddress;\\n        Garden garden = Garden(gardenAddress);\\n        address critic = msg.sender;\\n        address[] memory works = garden.getSculptures();\\n        for (uint256 i = 0; i < works.length; i++) {\\n            if (critiques[works[i]].critic == address(0x0)) {\\n                critiques[works[i]] = Critique(\\n                    critic,\\n                    uint8(i % OPINIONS_COUNT)\\n                );\\n            }\\n        }\\n    }\\n\\n    function critiqueWork (uint256 workIndex, address workAddress, uint8 critique) external {\\n        Garden garden = Garden(gardenAddress);\\n        require(\\n            garden.getSculptures()[workIndex] == workAddress,\\n            \\\"invalid work (was the garden changed?)\\\"\\n        );\\n        require(\\n            critique < OPINIONS_COUNT,\\n            \\\"invalid critical opinion (indices start at zero)\\\"\\n        );\\n        critiques[workAddress] = Critique(\\n            msg.sender,\\n            critique\\n        );\\n    }\\n\\n    function formatOpinion (address workAddress) internal view returns (string memory) {\\n        Sculpture work = Sculpture(workAddress);\\n        Critique memory critique = critiques[workAddress];\\n        return string.concat(\\n            \\\"<p>\\\",\\n            LibString.toHexStringChecksummed(critique.critic),\\n            \\\" thinks that <i><span style=\\\\\\\"white-space: nowrap;\\\\\\\">\\\",\\n            work.title(),\\n            \\\"</span></i> <span style=\\\\\\\"white-space: nowrap;\\\\\\\">by \\\",\\n            work.authors()[0],\\n            \\\"</span> is <span style=\\\\\\\"white-space: nowrap;\\\\\\\">\\\",\\n            OPINIONS[critique.critique],\\n            \\\".</span></p>\\\\n\\\"\\n        );\\n    }\\n\\n    function formatOpinions () internal view returns (string memory) {\\n        Garden garden = Garden(gardenAddress);\\n        address[] memory sculptureAddresses = garden.getSculptures();\\n        string memory opinions = \\\"\\\";\\n        for (uint256 i = 0; i < sculptureAddresses.length; i++) {\\n            address workAddress = sculptureAddresses[i];\\n            Critique storage critique = critiques[workAddress];\\n            if (critique.critic != address(0x0))\\n                opinions = string.concat(\\n                    opinions,\\n                    formatOpinion(workAddress)\\n                );\\n        }\\n        return opinions;\\n    }\\n\\n    function title() external view override returns (string memory) {\\n        // This title is dynamic and always shows the current block timestamp\\n        return string.concat(\\\"Critique of This Show\\\");\\n    }\\n\\n    function authors() external view override returns (string[] memory) {\\n        string[] memory authors_ = new string[](1);\\n        authors_[0] = \\\"Rhea Myers et al.\\\";\\n        return authors_;\\n    }\\n\\n    function addresses() external view override returns (address[] memory) {\\n        address[] memory addresses_ = new address[](1);\\n        // this too, could be dynamic or change over time\\n        addresses_[0] = address(this);\\n        return addresses_;\\n    }\\n\\n    function text() public view override returns (string memory) {\\n        return formatOpinions();\\n    }\\n\\n    function urls() public view override returns (string[] memory) {} // empty\\n}\\n\",\"keccak256\":\"0x65ab831d4b3bfee2a87c7af7f037b45e08c8a6941fa8ad140dbb15fe97f4cb09\",\"license\":\"MIT\"},\"contracts/Web.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity >=0.8.0;\\n\\nimport \\\"solady/src/auth/Ownable.sol\\\";\\nimport \\\"solady/src/utils/LibString.sol\\\";\\nimport \\\"./Sculpture.sol\\\";\\n\\ninterface IGarden {\\n    function getContribution(uint256 index) external view returns (address contributor, uint256 amount);\\n    function getContributed() external view returns (uint256);\\n    function getSculptures() external view returns (address[] memory);\\n}\\n\\ninterface IWeb {\\n    function html() external view returns (string memory);\\n}\\n\\ncontract Web is IWeb, Ownable {\\n    address public garden;\\n    address public renderer;\\n\\n    constructor() {\\n        _initializeOwner(msg.sender);\\n    }\\n\\n    function html() external view returns (string memory) {\\n        return ShowRenderer(renderer).html();\\n    }\\n\\n    function setRenderer(address _renderer) public onlyOwner {\\n        renderer = _renderer;\\n    }\\n}\\n\\ncontract ShowRenderer {\\n\\n    address immutable public garden;\\n\\n    constructor(address _garden) {\\n        garden = _garden;\\n    }\\n\\n    function html() public view returns (string memory) {\\n        address[] memory sculptures = IGarden(garden).getSculptures();\\n\\n        string memory html = \\\"<html>\\\";\\n        html = string.concat(html,\\n            '<head>',\\n            '<meta charset=\\\"UTF-8\\\">',\\n            '<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\">',\\n            '<title>', Sculpture(garden).title() ,'</title>',\\n            '</head>',\\n            \\\"<style>\\\",\\n            '*, *::before, *::after { box-sizing: border-box; }',\\n            'html { -moz-text-size-adjust: none; -webkit-text-size-adjust: none; text-size-adjust: none; }',\\n            'html, body { margin: 0; padding: 0; } body { min-height: 100vh }',\\n            'html,body,pre { font-family: \\\"Courier New\\\", \\\"Courier\\\", monospace; font-size: 15px; }',\\n            'h1,h2,h3 { margin: 0; font-size: inherit; font-style: inherit; font-weight: inherit;}',\\n            \\\".c { max-width: 840px; margin: 0 auto; padding: 0 1.5em; }\\\",\\n            // \\\"@media screen and (max-width: 760px) { .c { margin: 2.5em auto; } }\\\",\\n            \\\"a { color: inherit; text-decoration: underline; }\\\",\\n            \\\".w { min-height: 100vh; display: flex; align-items: center; box-sizing: border-box; padding: 10em 0; }\\\",\\n            \\\".s { width: 100%; max-width: 840px; }\\\",\\n            \\\".s:not(.g) a { text-decoration: none; max-width: 100%; display: inline-block; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }\\\",\\n            \\\".t { max-width: 100%; overflow-x: scroll; }\\\",\\n            \\\".i { margin: 50vh 0 5em; }\\\",\\n            // \\\"pre.garden { line-height: 1.3; font-size: 1.2rem;}\\\",\\n            \\\"</style>\\\"\\n        );\\n        html = string.concat(\\n            html, \\\"<body>\\\",\\n            '<div class=\\\"c\\\">',\\n            '<div class=\\\"w\\\"><div class=\\\"s g\\\">',\\n            '<pre class=\\\"garden\\\">',\\n            unicode\\\"       \\u2698                    \\u2698\\\\n\\\",\\n            unicode\\\"             \\u2698\\\\n\\\",\\n            unicode\\\"\\u2698                       \\u2698         \\u2698\\\\n\\\",\\n            unicode\\\"        \\u2698         \\u2698\\\\n\\\",\\n            unicode\\\"   \\u2698                          \\u2698\\\\n\\\",\\n            unicode\\\"</pre>\\\",\\n            '<br /><br />',\\n            unicode\\\"<h1>\\\", Sculpture(garden).title(), \\\"</h1>\\\\n\\\",\\n            '<br /><br />'\\n        );\\n        for (uint256 i = 0; i < sculptures.length; i++) {\\n            string[] memory authors = Sculpture(sculptures[i]).authors();\\n            // Temporary: For now we just use the first author here\\n            if (authors.length > 0) {\\n                html = string.concat(html, authors[0], \\\"<br/>\\\");\\n            }\\n        }\\n        html = string.concat(html,\\n            '<br /><br />',\\n            '<pre class=\\\"garden\\\">',\\n            unicode\\\"      \\u2698                      \\u2698\\\\n\\\",\\n            unicode\\\"              \\u2698\\\\n\\\",\\n            unicode\\\" \\u2698                     \\u2698         \\u2698\\\\n\\\",\\n            unicode\\\"          \\u2698      \\u2698\\\\n\\\",\\n            unicode\\\"     \\u2698                     \\u2698\\\\n\\\",\\n            unicode\\\"</pre>\\\",\\n            '<br />',\\n            '<p>',\\n            'A contract show organized by ',\\n            '<a href=\\\"https://0xfff.love\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">0xfff</a><br />',\\n            'with special thanks to ',\\n            '<a href=\\\"https://x.com/sssluke1\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">sssluke</a> and <a href=\\\"https://x.com/0x113d\\\" rel=\\\"noopener noreferrer\\\" target=\\\"_blank\\\">113</a>',\\n            \\\"</p>\\\",\\n            '<br /><br />'\\n        );\\n\\n        html = string.concat(\\n            html,\\n            \\\"<br />\\\",\\n            \\\"</div></div>\\\"\\n        );\\n\\n        for (uint256 i = 0; i < sculptures.length; i++) {\\n            Sculpture sculpture = Sculpture(sculptures[i]);\\n            string memory title = sculpture.title();\\n            html = string.concat(html, '<div class=\\\"w\\\"><div class=\\\"s\\\">');\\n            string[] memory authors = sculpture.authors();\\n            if (authors.length > 0) {\\n                html = string.concat(html, \\\"<h2>\\\");\\n                for (uint256 j = 0; j < authors.length; j++) {\\n                    if (bytes(authors[j]).length == 0) continue; // ignore empty\\n                    html = string.concat(html, authors[j], \\\"<br/>\\\");\\n                }\\n                html = string.concat(html, \\\"</h2>\\\");\\n            }\\n            if (bytes(title).length > 0) {\\n                html = string.concat(html, \\\"<h3><i>\\\", title, \\\"</i></h3>\\\");\\n            } else {\\n                html = string.concat(html, \\\"<h3><i>\\\", \\\"Untitled\\\", \\\"</i></h3>\\\");\\n            }\\n            address[] memory addresses = sculpture.addresses();\\n            if (addresses.length > 0) {\\n                html = string.concat(html, \\\"<p>\\\");\\n                for (uint256 j = 0; j < addresses.length; j++) {\\n                    html = string.concat(html, LibString.toHexString(addresses[j]), \\\"<br/>\\\");\\n                }\\n                html = string.concat(html, \\\"</p>\\\");\\n            }\\n            string[] memory urls = sculpture.urls();\\n            if (urls.length > 0) {\\n                html = string.concat(html, \\\"<p>\\\");\\n                for (uint256 j = 0; j < urls.length; j++) {\\n                    if (bytes(urls[j]).length == 0) continue; // ignore empty\\n                    html = string.concat(html, renderUrl(urls[j]), \\\"<br/>\\\");\\n                }\\n                html = string.concat(html, \\\"</p>\\\");\\n            }\\n            string memory text = sculpture.text();\\n            bool isSarah = sculpture.authors().length > 0 && keccak256(abi.encodePacked(sculpture.authors()[0])) == keccak256(abi.encodePacked(\\\"Sarah Friend\\\"));\\n            if (bytes(text).length > 0) {\\n                if (isSarah) { html = string.concat(html, '<div class=\\\"t\\\"><pre>', text, '</pre></div>'); }\\n                else { html = string.concat(html, '<div class=\\\"t\\\"><p>', text, '</p></div>'); }\\n            }\\n            html = string.concat(html, \\\"</div></div>\\\");\\n        }\\n        // uint contributed = GardenContributions(garden).getContributed();\\n        // for (uint256 i = 0; i < contributed; i++) {\\n        //     html = string(abi.encodePacked(html, \\\"<li>\\\", GardenContributions(garden).getContribution(i), \\\"</li>\\\"));\\n        // }\\n        html = string.concat(html, '<div class=\\\"i\\\">Generated at block ', LibString.toString(block.number), \\\" (\\\", LibString.toString(block.timestamp), \\\")</div>\\\");\\n        html = string.concat(html, \\\"</div></body></html>\\\");\\n        return html;\\n    }\\n\\n    function stripURL(string memory url) internal pure returns (string memory) {\\n        bytes memory urlBytes = bytes(url);\\n        uint256 length = urlBytes.length;\\n        uint256 start = 0;\\n        uint256 end = length;\\n\\n        // Find the position of \\\"://\\\", which indicates the end of the protocol\\n        for (uint256 i = 0; i < length - 2; i++) {\\n            if (urlBytes[i] == \\\":\\\" && urlBytes[i + 1] == \\\"/\\\" && urlBytes[i + 2] == \\\"/\\\") {\\n                start = i + 3; // Skip the \\\"://\\\"max\\n                break;\\n            }\\n        }\\n\\n        // Find position of \\\"?\\\" or \\\"#\\\" to determine the end of the main URL\\n        for (uint256 i = start; i < length; i++) {\\n            if (urlBytes[i] == \\\"?\\\" || urlBytes[i] == \\\"#\\\") {\\n                end = i;\\n                break;\\n            }\\n        }\\n\\n        // Remove trailing slash if present\\n        if (end > start && urlBytes[end - 1] == \\\"/\\\") {\\n            end -= 1;\\n        }\\n\\n        // Create a new byte array to store the stripped URL\\n        bytes memory strippedUrlBytes = new bytes(end - start);\\n        for (uint256 i = start; i < end; i++) {\\n            strippedUrlBytes[i - start] = urlBytes[i];\\n        }\\n\\n        return string(strippedUrlBytes);\\n    }\\n\\n    function renderUrl(string memory url) internal pure returns (string memory) {\\n        string memory strippedUrl = stripURL(url);\\n        return string.concat('<a href=\\\"', url, '\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">', strippedUrl ,'</a>');\\n    }\\n\\n\\n}\",\"keccak256\":\"0x14e539e8871cb2af50e1a30c2c68017cf5e05f111aefc0a4e7d08e81a7a12617\",\"license\":\"UNLICENSED\"},\"solady/src/auth/Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/auth/Ownable.sol)\\n///\\n/// @dev Note:\\n/// This implementation does NOT auto-initialize the owner to `msg.sender`.\\n/// You MUST call the `_initializeOwner` in the constructor / initializer.\\n///\\n/// While the ownable portion follows\\n/// [EIP-173](https://eips.ethereum.org/EIPS/eip-173) for compatibility,\\n/// the nomenclature for the 2-step ownership handover may be unique to this codebase.\\nabstract contract Ownable {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The caller is not authorized to call the function.\\n    error Unauthorized();\\n\\n    /// @dev The `newOwner` cannot be the zero address.\\n    error NewOwnerIsZeroAddress();\\n\\n    /// @dev The `pendingOwner` does not have a valid handover request.\\n    error NoHandoverRequest();\\n\\n    /// @dev Cannot double-initialize.\\n    error AlreadyInitialized();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                           EVENTS                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The ownership is transferred from `oldOwner` to `newOwner`.\\n    /// This event is intentionally kept the same as OpenZeppelin's Ownable to be\\n    /// compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173),\\n    /// despite it not being as lightweight as a single argument event.\\n    event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\\n\\n    /// @dev An ownership handover to `pendingOwner` has been requested.\\n    event OwnershipHandoverRequested(address indexed pendingOwner);\\n\\n    /// @dev The ownership handover to `pendingOwner` has been canceled.\\n    event OwnershipHandoverCanceled(address indexed pendingOwner);\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipTransferred(address,address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverRequested(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE =\\n        0xdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d;\\n\\n    /// @dev `keccak256(bytes(\\\"OwnershipHandoverCanceled(address)\\\"))`.\\n    uint256 private constant _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE =\\n        0xfa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                          STORAGE                           */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The owner slot is given by:\\n    /// `bytes32(~uint256(uint32(bytes4(keccak256(\\\"_OWNER_SLOT_NOT\\\")))))`.\\n    /// It is intentionally chosen to be a high value\\n    /// to avoid collision with lower slots.\\n    /// The choice of manual storage layout is to enable compatibility\\n    /// with both regular and upgradeable contracts.\\n    bytes32 internal constant _OWNER_SLOT =\\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927;\\n\\n    /// The ownership handover slot of `newOwner` is given by:\\n    /// ```\\n    ///     mstore(0x00, or(shl(96, user), _HANDOVER_SLOT_SEED))\\n    ///     let handoverSlot := keccak256(0x00, 0x20)\\n    /// ```\\n    /// It stores the expiry timestamp of the two-step ownership handover.\\n    uint256 private constant _HANDOVER_SLOT_SEED = 0x389a75e1;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     INTERNAL FUNCTIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Override to return true to make `_initializeOwner` prevent double-initialization.\\n    function _guardInitializeOwner() internal pure virtual returns (bool guard) {}\\n\\n    /// @dev Initializes the owner directly without authorization guard.\\n    /// This function must be called upon initialization,\\n    /// regardless of whether the contract is upgradeable or not.\\n    /// This is to enable generalization to both regular and upgradeable contracts,\\n    /// and to save gas in case the initial owner is not the caller.\\n    /// For performance reasons, this function will not check if there\\n    /// is an existing owner.\\n    function _initializeOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                if sload(ownerSlot) {\\n                    mstore(0x00, 0x0dc149f0) // `AlreadyInitialized()`.\\n                    revert(0x1c, 0x04)\\n                }\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Store the new value.\\n                sstore(_OWNER_SLOT, newOwner)\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, 0, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Sets the owner directly without authorization guard.\\n    function _setOwner(address newOwner) internal virtual {\\n        if (_guardInitializeOwner()) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, or(newOwner, shl(255, iszero(newOwner))))\\n            }\\n        } else {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let ownerSlot := _OWNER_SLOT\\n                // Clean the upper 96 bits.\\n                newOwner := shr(96, shl(96, newOwner))\\n                // Emit the {OwnershipTransferred} event.\\n                log3(0, 0, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, sload(ownerSlot), newOwner)\\n                // Store the new value.\\n                sstore(ownerSlot, newOwner)\\n            }\\n        }\\n    }\\n\\n    /// @dev Throws if the sender is not the owner.\\n    function _checkOwner() internal view virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If the caller is not the stored owner, revert.\\n            if iszero(eq(caller(), sload(_OWNER_SLOT))) {\\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns how long a two-step ownership handover is valid for in seconds.\\n    /// Override to return a different value if needed.\\n    /// Made internal to conserve bytecode. Wrap it in a public function if needed.\\n    function _ownershipHandoverValidFor() internal view virtual returns (uint64) {\\n        return 48 * 3600;\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                  PUBLIC UPDATE FUNCTIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Allows the owner to transfer the ownership to `newOwner`.\\n    function transferOwnership(address newOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(shl(96, newOwner)) {\\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n        _setOwner(newOwner);\\n    }\\n\\n    /// @dev Allows the owner to renounce their ownership.\\n    function renounceOwnership() public payable virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /// @dev Request a two-step ownership handover to the caller.\\n    /// The request will automatically expire in 48 hours (172800 seconds) by default.\\n    function requestOwnershipHandover() public payable virtual {\\n        unchecked {\\n            uint256 expires = block.timestamp + _ownershipHandoverValidFor();\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Compute and set the handover slot to `expires`.\\n                mstore(0x0c, _HANDOVER_SLOT_SEED)\\n                mstore(0x00, caller())\\n                sstore(keccak256(0x0c, 0x20), expires)\\n                // Emit the {OwnershipHandoverRequested} event.\\n                log2(0, 0, _OWNERSHIP_HANDOVER_REQUESTED_EVENT_SIGNATURE, caller())\\n            }\\n        }\\n    }\\n\\n    /// @dev Cancels the two-step ownership handover to the caller, if any.\\n    function cancelOwnershipHandover() public payable virtual {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, caller())\\n            sstore(keccak256(0x0c, 0x20), 0)\\n            // Emit the {OwnershipHandoverCanceled} event.\\n            log2(0, 0, _OWNERSHIP_HANDOVER_CANCELED_EVENT_SIGNATURE, caller())\\n        }\\n    }\\n\\n    /// @dev Allows the owner to complete the two-step ownership handover to `pendingOwner`.\\n    /// Reverts if there is no existing ownership handover requested by `pendingOwner`.\\n    function completeOwnershipHandover(address pendingOwner) public payable virtual onlyOwner {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute and set the handover slot to 0.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            let handoverSlot := keccak256(0x0c, 0x20)\\n            // If the handover does not exist, or has expired.\\n            if gt(timestamp(), sload(handoverSlot)) {\\n                mstore(0x00, 0x6f5e8818) // `NoHandoverRequest()`.\\n                revert(0x1c, 0x04)\\n            }\\n            // Set the handover slot to 0.\\n            sstore(handoverSlot, 0)\\n        }\\n        _setOwner(pendingOwner);\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   PUBLIC READ FUNCTIONS                    */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the owner of the contract.\\n    function owner() public view virtual returns (address result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := sload(_OWNER_SLOT)\\n        }\\n    }\\n\\n    /// @dev Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`.\\n    function ownershipHandoverExpiresAt(address pendingOwner)\\n        public\\n        view\\n        virtual\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Compute the handover slot.\\n            mstore(0x0c, _HANDOVER_SLOT_SEED)\\n            mstore(0x00, pendingOwner)\\n            // Load the handover slot.\\n            result := sload(keccak256(0x0c, 0x20))\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         MODIFIERS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Marks a function as only callable by the owner.\\n    modifier onlyOwner() virtual {\\n        _checkOwner();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xc208cdd9de02bbf4b5edad18b88e23a2be7ff56d2287d5649329dc7cda64b9a3\",\"license\":\"MIT\"},\"solady/src/utils/LibString.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\n///\\n/// @dev Note:\\n/// For performance and bytecode compactness, most of the string operations are restricted to\\n/// byte strings (7-bit ASCII), except where otherwise specified.\\n/// Usage of byte string operations on charsets with runes spanning two or more bytes\\n/// can lead to undefined behavior.\\nlibrary LibString {\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The length of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /// @dev The length of the string is more than 32 bytes.\\n    error TooBigForSmallString();\\n\\n    /// @dev The input string must be a 7-bit ASCII.\\n    error StringNot7BitASCII();\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = type(uint256).max;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;\\n\\n    /// @dev Lookup for 'abcdefghijklmnopqrstuvwxyz'.\\n    uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;\\n\\n    /// @dev Lookup for 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\\n    uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;\\n\\n    /// @dev Lookup for '0123456789'.\\n    uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefABCDEF'.\\n    uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;\\n\\n    /// @dev Lookup for '01234567'.\\n    uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;\\n\\n    /// @dev Lookup for '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~ \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;\\n\\n    /// @dev Lookup for '!\\\"#$%&\\\\'()*+,-./:;<=>?@[\\\\\\\\]^_`{|}~'.\\n    uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;\\n\\n    /// @dev Lookup for ' \\\\t\\\\n\\\\r\\\\x0b\\\\x0c'.\\n    uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits.\\n            str := add(mload(0x40), 0x80)\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end of the memory to calculate the length later.\\n            let w := not(0) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 1)`.\\n                // Store the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\\n                if iszero(temp) { break }\\n            }\\n            let length := sub(end, str)\\n            str := sub(str, 0x20) // Move the pointer 32 bytes back to make room for the length.\\n            mstore(str, length) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(int256 value) internal pure returns (string memory str) {\\n        if (value >= 0) return toString(uint256(value));\\n        unchecked {\\n            str = toString(~uint256(value) + 1);\\n        }\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We still have some spare memory space on the left,\\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\\n            let length := mload(str) // Load the string length.\\n            mstore(str, 0x2d) // Store the '-' character.\\n            str := sub(str, 1) // Move back the string pointer by a byte.\\n            mstore(str, add(length, 1)) // Update the string length.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value, length);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexStringNoPrefix(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            str := add(mload(0x40), and(add(shl(1, length), 0x42), not(0x1f)))\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end to calculate the length later.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let start := sub(str, add(length, length))\\n            let w := not(1) // Tsk.\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for {} 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(xor(str, start)) { break }\\n            }\\n            if temp {\\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\\n                revert(0x1c, 0x04)\\n            }\\n            let strLength := sub(end, str)\\n            str := sub(str, 0x20)\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\".\\n    /// The output excludes leading \\\"0\\\" from the `toHexString` output.\\n    /// `0x00: \\\"0x0\\\", 0x01: \\\"0x1\\\", 0x12: \\\"0x12\\\", 0x123: \\\"0x123\\\"`.\\n    function toMinimalHexString(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(add(str, o), 0x3078) // Store the \\\"0x\\\" prefix, accounting for leading zero.\\n            str := sub(add(str, o), 2) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output excludes leading \\\"0\\\" from the `toHexStringNoPrefix` output.\\n    /// `0x00: \\\"0\\\", 0x01: \\\"1\\\", 0x12: \\\"12\\\", 0x123: \\\"123\\\"`.\\n    function toMinimalHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let o := eq(byte(0, mload(add(str, 0x20))), 0x30) // Whether leading zero is present.\\n            let strLength := mload(str) // Get the length.\\n            str := add(str, o) // Move the pointer, accounting for leading zero.\\n            mstore(str, sub(strLength, o)) // Store the length, accounting for leading zero.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2` bytes.\\n    function toHexStringNoPrefix(uint256 value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            str := add(mload(0x40), 0x80)\\n            mstore(0x40, add(str, 0x20)) // Allocate the memory.\\n            mstore(str, 0) // Zeroize the slot after the string.\\n\\n            let end := str // Cache the end to calculate the length later.\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            let w := not(1) // Tsk.\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let temp := value } 1 {} {\\n                str := add(str, w) // `sub(str, 2)`.\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                if iszero(temp) { break }\\n            }\\n            let strLength := sub(end, str)\\n            str := sub(str, 0x20)\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\", encoded using 2 hexadecimal digits per byte,\\n    /// and the alphabets are capitalized conditionally according to\\n    /// https://eips.ethereum.org/EIPS/eip-55\\n    function toHexStringChecksummed(address value) internal pure returns (string memory str) {\\n        str = toHexString(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\\n            let o := add(str, 0x22)\\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\\n            let t := shl(240, 136) // `0b10001000 << 240`\\n            for { let i := 0 } 1 {} {\\n                mstore(add(i, i), mul(t, byte(i, hashed)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\\n            o := add(o, 0x20)\\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(value);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(address value) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            str := mload(0x40)\\n            // Allocate the memory.\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\\n            mstore(0x40, add(str, 0x80))\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n\\n            str := add(str, 2)\\n            mstore(str, 40) // Store the length.\\n            let o := add(str, 0x20)\\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\\n            value := shl(96, value)\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            for { let i := 0 } 1 {} {\\n                let p := add(o, add(i, i))\\n                let temp := byte(i, value)\\n                mstore8(add(p, 1), mload(and(temp, 15)))\\n                mstore8(p, mload(shr(4, temp)))\\n                i := add(i, 1)\\n                if eq(i, 20) { break }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexString(bytes memory raw) internal pure returns (string memory str) {\\n        str = toHexStringNoPrefix(raw);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let strLength := add(mload(str), 2) // Compute the length.\\n            mstore(str, 0x3078) // Store the \\\"0x\\\" prefix.\\n            str := sub(str, 2) // Move the pointer.\\n            mstore(str, strLength) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the hex encoded string from the raw bytes.\\n    /// The output is encoded using 2 hexadecimal digits per byte.\\n    function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory str) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(raw)\\n            str := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\\n            mstore(str, add(length, length)) // Store the length of the output.\\n\\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \\\"0123456789abcdef\\\" lookup.\\n            let o := add(str, 0x20)\\n            let end := add(raw, length)\\n            for {} iszero(eq(raw, end)) {} {\\n                raw := add(raw, 1)\\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\\n                o := add(o, 2)\\n            }\\n            mstore(o, 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   RUNE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    /// @dev Returns the number of UTF characters in the string.\\n    function runeCount(string memory s) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                mstore(0x00, div(not(0), 255))\\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for { result := 1 } 1 { result := add(result, 1) } {\\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\\n                    if iszero(lt(o, end)) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string.\\n    /// (i.e. all characters codes are in [0..127])\\n    function is7BitASCII(string memory s) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := shl(7, div(not(0), 255))\\n            result := 1\\n            let n := mload(s)\\n            if n {\\n                let o := add(s, 0x20)\\n                let end := add(o, n)\\n                let last := mload(end)\\n                mstore(end, 0)\\n                for {} 1 {} {\\n                    if and(mask, mload(o)) {\\n                        result := 0\\n                        break\\n                    }\\n                    o := add(o, 0x20)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                mstore(end, last)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if this string is a 7-bit ASCII string,\\n    /// AND all characters are in the `allowed` lookup.\\n    /// Note: If `s` is empty, returns true regardless of `allowed`.\\n    function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := 1\\n            if mload(s) {\\n                let allowed_ := shr(128, shl(128, allowed))\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for {} 1 {} {\\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\\n                    o := add(o, 1)\\n                    if iszero(and(result, lt(o, end))) { break }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Converts the bytes in the 7-bit ASCII string `s` to\\n    /// an allowed lookup for use in `is7BitASCII(s, allowed)`.\\n    /// To save runtime gas, you can cache the result in an immutable variable.\\n    function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mload(s) {\\n                let o := add(s, 0x20)\\n                let end := add(o, mload(s))\\n                for {} 1 {} {\\n                    result := or(result, shl(byte(0, mload(o)), 1))\\n                    o := add(o, 1)\\n                    if iszero(lt(o, end)) { break }\\n                }\\n                if shr(128, result) {\\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n        }\\n    }\\n\\n    /*\\u00b4:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0\\u2022.*\\u2022\\u00b4.*:\\u02da.\\u00b0*.\\u02da\\u2022\\u00b4.\\u00b0:\\u00b0\\u2022.\\u00b0+.*\\u2022\\u00b4.*:*/\\n    /*                   BYTE STRING OPERATIONS                   */\\n    /*.\\u2022\\u00b0:\\u00b0.\\u00b4+\\u02da.*\\u00b0.\\u02da:*.\\u00b4\\u2022*.+\\u00b0.\\u2022\\u00b0:\\u00b4*.\\u00b4\\u2022*.\\u2022\\u00b0.\\u2022\\u00b0:\\u00b0.\\u00b4:\\u2022\\u02da\\u00b0.*\\u00b0.\\u02da:*.\\u00b4+\\u00b0.\\u2022*/\\n\\n    // For performance and bytecode compactness, byte string operations are restricted\\n    // to 7-bit ASCII strings. All offsets are byte offsets, not UTF character offsets.\\n    // Usage of byte string operations on charsets with runes spanning two or more bytes\\n    // can lead to undefined behavior.\\n\\n    /// @dev Returns `subject` all occurrences of `search` replaced with `replacement`.\\n    function replace(string memory subject, string memory search, string memory replacement)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            let last := add(add(result, 0x20), k) // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            mstore(result, k) // Store the length.\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    if iszero(gt(from, subjectLength)) {\\n                        result := from\\n                        break\\n                    }\\n                    result := subjectLength\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                subject := add(subjectStart, from)\\n                let end := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(add(search, 0x20))\\n\\n                if iszero(and(lt(subject, end), lt(from, subjectLength))) { break }\\n\\n                if iszero(lt(searchLength, 0x20)) {\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        if iszero(lt(subject, end)) { break }\\n                    }\\n                    break\\n                }\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search, uint256 from)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} 1 {} {\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n                let searchLength := mload(search)\\n                if gt(searchLength, mload(subject)) { break }\\n                let w := result\\n\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) { from := fromMax }\\n\\n                let end := add(add(subject, 0x20), w)\\n                subject := add(add(subject, 0x20), from)\\n                if iszero(gt(subject, end)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(end, 1))\\n                        break\\n                    }\\n                    subject := add(subject, w) // `sub(subject, 1)`.\\n                    if iszero(gt(subject, end)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns true if `search` is found in `subject`, false otherwise.\\n    function contains(string memory subject, string memory search) internal pure returns (bool) {\\n        return indexOf(subject, search) != NOT_FOUND;\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            // forgefmt: disable-next-item\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(add(subject, 0x20), mul(withinRange, sub(subjectLength, searchLength))),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    if iszero(times) { break }\\n                }\\n                mstore(output, 0) // Zeroize the slot after the string.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength) // Store the length.\\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(string memory subject, uint256 start, uint256 end)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) { end := subjectLength }\\n            if iszero(gt(subjectLength, start)) { start := subjectLength }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                let w := not(0x1f)\\n                // Copy the `subject` one word at a time, backwards.\\n                for { let o := and(add(resultLength, 0x1f), w) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := add(o, w) // `sub(o, 0x20)`.\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                mstore(0x40, add(result, add(resultLength, 0x40))) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(sub(add(subject, subjectLength), searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 0x20)) { h := keccak256(search, searchLength) }\\n                let m := shl(3, sub(0x20, and(searchLength, 0x1f)))\\n                let s := mload(search)\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            let indexPtr := add(indices, 0x20)\\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n            mstore(add(indicesEnd, w), mload(subject))\\n            mstore(indices, add(mload(indices), 1))\\n            let prevIndex := 0\\n            for {} 1 {} {\\n                let index := mload(indexPtr)\\n                mstore(indexPtr, 0x60)\\n                if iszero(eq(index, prevIndex)) {\\n                    let element := mload(0x40)\\n                    let elementLength := sub(index, prevIndex)\\n                    mstore(element, elementLength)\\n                    // Copy the `subject` one word at a time, backwards.\\n                    for { let o := and(add(elementLength, 0x1f), w) } 1 {} {\\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                        o := add(o, w) // `sub(o, 0x20)`.\\n                        if iszero(o) { break }\\n                    }\\n                    // Zeroize the slot after the string.\\n                    mstore(add(add(element, 0x20), elementLength), 0)\\n                    // Allocate memory for the length and the bytes,\\n                    // rounded up to a multiple of 32.\\n                    mstore(0x40, add(element, and(add(elementLength, 0x3f), w)))\\n                    // Store the `element` into the array.\\n                    mstore(indexPtr, element)\\n                }\\n                prevIndex := add(index, mload(delimiter))\\n                indexPtr := add(indexPtr, 0x20)\\n                if iszero(lt(indexPtr, indicesEnd)) { break }\\n            }\\n            result := indices\\n            if iszero(mload(delimiter)) {\\n                result := add(indices, 0x20)\\n                mstore(result, sub(mload(indices), 2))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0x1f)\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            for { let o := and(add(aLength, 0x20), w) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, aLength)\\n            // Copy `b` one word at a time, backwards.\\n            for { let o := and(add(bLength, 0x20), w) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := add(o, w) // `sub(o, 0x20)`.\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            mstore(result, totalLength) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns a copy of the string in either lowercase or UPPERCASE.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function toCase(string memory subject, bool toUpper)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let length := mload(subject)\\n            if length {\\n                result := add(mload(0x40), 0x20)\\n                subject := add(subject, 1)\\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\\n                let w := not(0)\\n                for { let o := length } 1 {} {\\n                    o := add(o, w)\\n                    let b := and(0xff, mload(add(subject, o)))\\n                    mstore8(add(result, o), xor(b, and(shr(b, flags), 0x20)))\\n                    if iszero(o) { break }\\n                }\\n                result := mload(0x40)\\n                mstore(result, length) // Store the length.\\n                let last := add(add(result, 0x20), length)\\n                mstore(last, 0) // Zeroize the slot after the string.\\n                mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a string from a small bytes32 string.\\n    /// `s` must be null-terminated, or behavior will be undefined.\\n    function fromSmallString(bytes32 s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40)\\n            let n := 0\\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\\\0'.\\n            mstore(result, n) // Store the length.\\n            let o := add(result, 0x20)\\n            mstore(o, s) // Store the bytes of the string.\\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\\n            mstore(0x40, add(result, 0x40)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Returns the small string, with all bytes after the first null byte zeroized.\\n    function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\\\0'.\\n            mstore(0x00, s)\\n            mstore(result, 0x00)\\n            result := mload(0x00)\\n        }\\n    }\\n\\n    /// @dev Returns the string as a normalized null-terminated small string.\\n    function toSmallString(string memory s) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(s)\\n            if iszero(lt(result, 33)) {\\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\\n                revert(0x1c, 0x04)\\n            }\\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\\n        }\\n    }\\n\\n    /// @dev Returns a lowercased copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function lower(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, false);\\n    }\\n\\n    /// @dev Returns an UPPERCASED copy of the string.\\n    /// WARNING! This function is only compatible with 7-bit ASCII strings.\\n    function upper(string memory subject) internal pure returns (string memory result) {\\n        result = toCase(subject, true);\\n    }\\n\\n    /// @dev Escapes the string to be used within HTML tags.\\n    function escapeHTML(string memory s) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            // Store the bytes of the packed offsets and strides into the scratch space.\\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\\n            mstore(0x1f, 0x900094)\\n            mstore(0x08, 0xc0000000a6ab)\\n            // Store \\\"&quot;&amp;&#39;&lt;&gt;\\\" into the scratch space.\\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                // Not in `[\\\"\\\\\\\"\\\",\\\"'\\\",\\\"&\\\",\\\"<\\\",\\\">\\\"]`.\\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\\n                    mstore8(result, c)\\n                    result := add(result, 1)\\n                    continue\\n                }\\n                let t := shr(248, mload(c))\\n                mstore(result, mload(and(t, 0x1f)))\\n                result := add(result, shr(5, t))\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    /// If `addDoubleQuotes` is true, the result will be enclosed in double-quotes.\\n    function escapeJSON(string memory s, bool addDoubleQuotes)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let end := add(s, mload(s))\\n            result := add(mload(0x40), 0x20)\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n            // into the scratch space.\\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n            // Bitmask for detecting `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            for {} iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) {\\n                        // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) {\\n                    // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            if addDoubleQuotes {\\n                mstore8(result, 34)\\n                result := add(1, result)\\n            }\\n            let last := result\\n            mstore(last, 0) // Zeroize the slot after the string.\\n            result := mload(0x40)\\n            mstore(result, sub(last, add(result, 0x20))) // Store the length.\\n            mstore(0x40, add(last, 0x20)) // Allocate the memory.\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s) internal pure returns (string memory result) {\\n        result = escapeJSON(s, false);\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`.\\n    function eq(string memory a, string memory b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\\n        }\\n    }\\n\\n    /// @dev Returns whether `a` equals `b`, where `b` is a null-terminated small string.\\n    function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // These should be evaluated on compile time, as far as possible.\\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\\n            let x := not(or(m, or(b, add(m, and(b, m)))))\\n            let r := shl(7, iszero(iszero(shr(128, x))))\\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\\n            // forgefmt: disable-next-item\\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    // Load the length and the bytes.\\n                    mload(add(a, 0x1f)),\\n                    // `length != 0 && length < 32`. Abuses underflow.\\n                    // Assumes that the length is valid and within the block gas limit.\\n                    lt(sub(mload(a), 1), 0x1f)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behavior is undefined.\\n    function unpackOne(bytes32 packed) internal pure returns (string memory result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := mload(0x40) // Grab the free memory pointer.\\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(result, 0) // Zeroize the length slot.\\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result :=\\n                mul(\\n                    or( // Load the length and the bytes of `a` and `b`.\\n                        shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                        mload(sub(add(b, 0x1e), aLength))\\n                    ),\\n                    // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                    // Assumes that the lengths are valid and within the block gas limit.\\n                    lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n                )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behavior is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            resultA := mload(0x40) // Grab the free memory pointer.\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Assumes that the string does not start from the scratch space.\\n            let retStart := sub(a, 0x20)\\n            let retUnpaddedSize := add(mload(a), 0x40)\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(retStart, retUnpaddedSize), 0)\\n            mstore(retStart, 0x20) // Store the return offset.\\n            // End the transaction, returning the string.\\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xbb90caa572b7f65689b74867ec211fed8cde92714314101f4287d00a40d95ab2\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040526040518061020001604052806040518060400160405280600f81526020017f746f74616c6c7920617765736f6d65000000000000000000000000000000000081525081526020016040518060400160405280601281526020017f656e746972656c7920657863656c6c656e74000000000000000000000000000081525081526020016040518060400160405280601a81526020017f7472616e7363656e64656e746c792066617363696e6174696e6700000000000081525081526020016040518060400160405280601581526020017f636f6d706c6574656c7920696e7472696775696e67000000000000000000000081525081526020016040518060400160405280600d81526020017f646565706c79206d6f76696e670000000000000000000000000000000000000081525081526020016040518060400160405280601481526020017f70726f666f756e646c7920616666656374696e6700000000000000000000000081525081526020016040518060400160405280600e81526020017f67726f756e64627265616b696e6700000000000000000000000000000000000081525081526020016040518060400160405280600781526020017f736f20637574650000000000000000000000000000000000000000000000000081525081526020016040518060400160405280600c81526020017f746f7465732061646f726273000000000000000000000000000000000000000081525081526020016040518060400160405280601381526020017f737472696b696e676c792070726f666f756e640000000000000000000000000081525081526020016040518060400160405280601481526020017f747269756d7068616e746c7920736b696c66756c00000000000000000000000081525081526020016040518060400160405280600c81526020017f6120726576656c6174696f6e000000000000000000000000000000000000000081525081526020016040518060400160405280601581526020017f756e69676e6f7261626c79206272696c6c69616e74000000000000000000000081525081526020016040518060400160405280601181526020017f74686f756768742070726f766f6b696e6700000000000000000000000000000081525081526020016040518060400160405280601a81526020017f696e74656c6c65637475616c6c79207374696d756c6174696e6700000000000081525081526020016040518060400160405280601481526020017f76697375616c6c79207374696d756c6174696e6700000000000000000000000081525081525060009060106103ce9291906104d6565b503480156103db57600080fd5b506103eb336103f060201b60201c565b6108c5565b6103fe6104d160201b60201c565b15610479577fffffffffffffffffffffffffffffffffffffffffffffffffffffffff7487392780541561043957630dc149f06000526004601cfd5b8160601b60601c9150811560ff1b821781558160007f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3506104ce565b8060601b60601c9050807fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927558060007f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a35b50565b600090565b8260108101928215610511579160200282015b8281111561051057825182908161050091906107f3565b50916020019190600101906104e9565b5b50905061051e9190610522565b5090565b5b8082111561054257600081816105399190610546565b50600101610523565b5090565b5080546105529061060c565b6000825580601f106105645750610583565b601f0160209004906000526020600020908101906105829190610586565b5b50565b5b8082111561059f576000816000905550600101610587565b5090565b600081519050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b6000600282049050600182168061062457607f821691505b602082108103610637576106366105dd565b5b50919050565b60008190508160005260206000209050919050565b60006020601f8301049050919050565b600082821b905092915050565b60006008830261069f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82610662565b6106a98683610662565b95508019841693508086168417925050509392505050565b6000819050919050565b6000819050919050565b60006106f06106eb6106e6846106c1565b6106cb565b6106c1565b9050919050565b6000819050919050565b61070a836106d5565b61071e610716826106f7565b84845461066f565b825550505050565b600090565b610733610726565b61073e818484610701565b505050565b5b818110156107625761075760008261072b565b600181019050610744565b5050565b601f8211156107a7576107788161063d565b61078184610652565b81016020851015610790578190505b6107a461079c85610652565b830182610743565b50505b505050565b600082821c905092915050565b60006107ca600019846008026107ac565b1980831691505092915050565b60006107e383836107b9565b9150826002028217905092915050565b6107fc826105a3565b67ffffffffffffffff811115610815576108146105ae565b5b61081f825461060c565b61082a828285610766565b600060209050601f83116001811461085d576000841561084b578287015190505b61085585826107d7565b8655506108bd565b601f19841661086b8661063d565b60005b828110156108935784890151825560018201915060208501945060208101905061086e565b868310156108b057848901516108ac601f8916826107b9565b8355505b6001600288020188555050505b505050505050565b611eff806108d46000396000f3fe6080604052600436106100dd5760003560e01c806375cb26721161007f578063da0321cd11610059578063da0321cd14610229578063f04e283e14610254578063f2fde38b14610270578063fee81cf41461028c576100dd565b806375cb2672146101ac5780638da5cb5b146101d5578063adcb3b7314610200576100dd565b80632c73dc4a116100bb5780632c73dc4a146101425780634a79d50c1461016d57806354d1f13d14610198578063715018a6146101a2576100dd565b80631f1bd692146100e2578063256929621461010d57806328411ae114610117575b600080fd5b3480156100ee57600080fd5b506100f76102c9565b6040516101049190611151565b60405180910390f35b6101156102d8565b005b34801561012357600080fd5b5061012c61032c565b604051610139919061127f565b60405180910390f35b34801561014e57600080fd5b506101576103dd565b604051610164919061127f565b60405180910390f35b34801561017957600080fd5b506101826103e2565b60405161018f9190611151565b60405180910390f35b6101a0610407565b005b6101aa610443565b005b3480156101b857600080fd5b506101d360048036038101906101ce9190611313565b610457565b005b3480156101e157600080fd5b506101ea610713565b6040516101f79190611361565b60405180910390f35b34801561020c57600080fd5b5061022760048036038101906102229190611417565b61073c565b005b34801561023557600080fd5b5061023e610982565b60405161024b9190611528565b60405180910390f35b61026e6004803603810190610269919061154a565b610a28565b005b61028a6004803603810190610285919061154a565b610a69565b005b34801561029857600080fd5b506102b360048036038101906102ae919061154a565b610a93565b6040516102c09190611586565b60405180910390f35b60606102d3610aae565b905090565b60006102e2610c6f565b67ffffffffffffffff164201905063389a75e1600c5233600052806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d600080a250565b60606000600167ffffffffffffffff81111561034b5761034a6115a1565b5b60405190808252806020026020018201604052801561037e57816020015b60608152602001906001900390816103695790505b5090506040518060400160405280601181526020017f52686561204d7965727320657420616c2e000000000000000000000000000000815250816000815181106103cb576103ca6115d0565b5b60200260200101819052508091505090565b606090565b60606040516020016103f390611625565b604051602081830303815290604052905090565b63389a75e1600c523360005260006020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92600080a2565b61044b610c7a565b6104556000610cb2565b565b61045f610c7a565b80601160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600033905060008273ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610519573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610542919061176c565b905060005b815181101561070c57600073ffffffffffffffffffffffffffffffffffffffff166010600084848151811061057f5761057e6115d0565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16036106ff5760405180604001604052808473ffffffffffffffffffffffffffffffffffffffff16815260200160108361063491906117e4565b60ff1681525060106000848481518110610651576106506115d0565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160146101000a81548160ff021916908360ff1602179055509050505b8080600101915050610547565b5050505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffff7487392754905090565b6000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156107c5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906107ee919061176c565b8581518110610800576107ff6115d0565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff161461085e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161085590611887565b60405180910390fd5b60108260ff16106108a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161089b90611919565b60405180910390fd5b60405180604001604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018360ff16815250601060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160146101000a81548160ff021916908360ff16021790555090505050505050565b60606000600167ffffffffffffffff8111156109a1576109a06115a1565b5b6040519080825280602002602001820160405280156109cf5781602001602082028036833780820191505090505b50905030816000815181106109e7576109e66115d0565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508091505090565b610a30610c7a565b63389a75e1600c52806000526020600c208054421115610a5857636f5e88186000526004601cfd5b6000815550610a6681610cb2565b50565b610a71610c7a565b8060601b610a8757637448fbae6000526004601cfd5b610a9081610cb2565b50565b600063389a75e1600c52816000526020600c20549050919050565b60606000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008173ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610b24573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610b4d919061176c565b9050600060405180602001604052806000815250905060005b8251811015610c65576000838281518110610b8457610b836115d0565b5b602002602001015190506000601060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600073ffffffffffffffffffffffffffffffffffffffff168160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610c565783610c3383610d7a565b604051602001610c44929190611975565b60405160208183030381529060405293505b50508080600101915050610b66565b5080935050505090565b60006202a300905090565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927543314610cb0576382b429006000526004601cfd5b565b610cba610f99565b15610d20577fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739278160601b60601c91508181547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3811560ff1b8217815550610d77565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739278160601b60601c91508181547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3818155505b50565b606060008290506000601060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060400160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016000820160149054906101000a900460ff1660ff1660ff16815250509050610e4f8160000151610f9e565b8273ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610e9a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610ec39190611a3f565b8373ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa158015610f0e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610f379190611b69565b600081518110610f4a57610f496115d0565b5b60200260200101516000846020015160ff1660108110610f6d57610f6c6115d0565b5b01604051602001610f819493929190611e4c565b60405160208183030381529060405292505050919050565b600090565b6060610fa982611018565b905060ff6000190460061b60228201816022026028822016608860f01b60005b600115610fe85782811a82028182015260018101905060148103610fc9575b50838351166000511660011c8351188352602083019250838351166020511660011c835118835250505050919050565b60606110238261103e565b90506002815101613078825260028203915080825250919050565b60606040519050608081016040526f30313233343536373839616263646566600f526002810190506028815260208101600060288201528260601b925060005b6001156110ba57808101820184821a600f81165160018301538060041c518253600183019250601483036110b35750506110ba565b505061107e565b5050919050565b600081519050919050565b600082825260208201905092915050565b60005b838110156110fb5780820151818401526020810190506110e0565b60008484015250505050565b6000601f19601f8301169050919050565b6000611123826110c1565b61112d81856110cc565b935061113d8185602086016110dd565b61114681611107565b840191505092915050565b6000602082019050818103600083015261116b8184611118565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600082825260208201905092915050565b60006111bb826110c1565b6111c5818561119f565b93506111d58185602086016110dd565b6111de81611107565b840191505092915050565b60006111f583836111b0565b905092915050565b6000602082019050919050565b600061121582611173565b61121f818561117e565b9350836020820285016112318561118f565b8060005b8581101561126d578484038952815161124e85826111e9565b9450611259836111fd565b925060208a01995050600181019050611235565b50829750879550505050505092915050565b60006020820190508181036000830152611299818461120a565b905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006112e0826112b5565b9050919050565b6112f0816112d5565b81146112fb57600080fd5b50565b60008135905061130d816112e7565b92915050565b600060208284031215611329576113286112ab565b5b6000611337848285016112fe565b91505092915050565b600061134b826112b5565b9050919050565b61135b81611340565b82525050565b60006020820190506113766000830184611352565b92915050565b6000819050919050565b61138f8161137c565b811461139a57600080fd5b50565b6000813590506113ac81611386565b92915050565b6113bb81611340565b81146113c657600080fd5b50565b6000813590506113d8816113b2565b92915050565b600060ff82169050919050565b6113f4816113de565b81146113ff57600080fd5b50565b600081359050611411816113eb565b92915050565b6000806000606084860312156114305761142f6112ab565b5b600061143e8682870161139d565b935050602061144f868287016113c9565b925050604061146086828701611402565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61149f81611340565b82525050565b60006114b18383611496565b60208301905092915050565b6000602082019050919050565b60006114d58261146a565b6114df8185611475565b93506114ea83611486565b8060005b8381101561151b57815161150288826114a5565b975061150d836114bd565b9250506001810190506114ee565b5085935050505092915050565b6000602082019050818103600083015261154281846114ca565b905092915050565b6000602082840312156115605761155f6112ab565b5b600061156e848285016113c9565b91505092915050565b6115808161137c565b82525050565b600060208201905061159b6000830184611577565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4372697469717565206f6620546869732053686f770000000000000000000000815250565b6000611630826115ff565b601582019150819050919050565b600080fd5b61164c82611107565b810181811067ffffffffffffffff8211171561166b5761166a6115a1565b5b80604052505050565b600061167e6112a1565b905061168a8282611643565b919050565b600067ffffffffffffffff8211156116aa576116a96115a1565b5b602082029050602081019050919050565b600080fd5b6000815190506116cf816113b2565b92915050565b60006116e86116e38461168f565b611674565b9050808382526020820190506020840283018581111561170b5761170a6116bb565b5b835b81811015611734578061172088826116c0565b84526020840193505060208101905061170d565b5050509392505050565b600082601f8301126117535761175261163e565b5b81516117638482602086016116d5565b91505092915050565b600060208284031215611782576117816112ab565b5b600082015167ffffffffffffffff8111156117a05761179f6112b0565b5b6117ac8482850161173e565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006117ef8261137c565b91506117fa8361137c565b92508261180a576118096117b5565b5b828206905092915050565b7f696e76616c696420776f726b2028776173207468652067617264656e2063686160008201527f6e6765643f290000000000000000000000000000000000000000000000000000602082015250565b60006118716026836110cc565b915061187c82611815565b604082019050919050565b600060208201905081810360008301526118a081611864565b9050919050565b7f696e76616c696420637269746963616c206f70696e696f6e2028696e6469636560008201527f73207374617274206174207a65726f2900000000000000000000000000000000602082015250565b60006119036030836110cc565b915061190e826118a7565b604082019050919050565b60006020820190508181036000830152611932816118f6565b9050919050565b600081905092915050565b600061194f826110c1565b6119598185611939565b93506119698185602086016110dd565b80840191505092915050565b60006119818285611944565b915061198d8284611944565b91508190509392505050565b600080fd5b600067ffffffffffffffff8211156119b9576119b86115a1565b5b6119c282611107565b9050602081019050919050565b60006119e26119dd8461199e565b611674565b9050828152602081018484840111156119fe576119fd611999565b5b611a098482856110dd565b509392505050565b600082601f830112611a2657611a2561163e565b5b8151611a368482602086016119cf565b91505092915050565b600060208284031215611a5557611a546112ab565b5b600082015167ffffffffffffffff811115611a7357611a726112b0565b5b611a7f84828501611a11565b91505092915050565b600067ffffffffffffffff821115611aa357611aa26115a1565b5b602082029050602081019050919050565b6000611ac7611ac284611a88565b611674565b90508083825260208201905060208402830185811115611aea57611ae96116bb565b5b835b81811015611b3157805167ffffffffffffffff811115611b0f57611b0e61163e565b5b808601611b1c8982611a11565b85526020850194505050602081019050611aec565b5050509392505050565b600082601f830112611b5057611b4f61163e565b5b8151611b60848260208601611ab4565b91505092915050565b600060208284031215611b7f57611b7e6112ab565b5b600082015167ffffffffffffffff811115611b9d57611b9c6112b0565b5b611ba984828501611b3b565b91505092915050565b7f3c703e0000000000000000000000000000000000000000000000000000000000815250565b7f207468696e6b732074686174203c693e3c7370616e207374796c653d2277686960008201527f74652d73706163653a206e6f777261703b223e00000000000000000000000000602082015250565b6000611c34603383611939565b9150611c3f82611bd8565b603382019050919050565b7f3c2f7370616e3e3c2f693e203c7370616e207374796c653d2277686974652d7360008201527f706163653a206e6f777261703b223e6279200000000000000000000000000000602082015250565b6000611ca6603283611939565b9150611cb182611c4a565b603282019050919050565b7f3c2f7370616e3e206973203c7370616e207374796c653d2277686974652d737060008201527f6163653a206e6f777261703b223e000000000000000000000000000000000000602082015250565b6000611d18602e83611939565b9150611d2382611cbc565b602e82019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611d7557607f821691505b602082108103611d8857611d87611d2e565b5b50919050565b60008190508160005260206000209050919050565b60008154611db081611d5d565b611dba8186611939565b94506001821660008114611dd55760018114611dea57611e1d565b60ff1983168652811515820286019350611e1d565b611df385611d8e565b60005b83811015611e1557815481890152600182019150602081019050611df6565b838801955050505b50505092915050565b7f2e3c2f7370616e3e3c2f703e0a00000000000000000000000000000000000000815250565b6000611e5782611bb2565b600382019150611e678287611944565b9150611e7282611c27565b9150611e7e8286611944565b9150611e8982611c99565b9150611e958285611944565b9150611ea082611d0b565b9150611eac8284611da3565b9150611eb782611e26565b600d820191508190509594505050505056fea2646970667358221220f2327135db0615eacacb28efa773ef22c9d792161cff27dabb417ee7eb02c36e64736f6c634300081b0033",
  "deployedBytecode": "0x6080604052600436106100dd5760003560e01c806375cb26721161007f578063da0321cd11610059578063da0321cd14610229578063f04e283e14610254578063f2fde38b14610270578063fee81cf41461028c576100dd565b806375cb2672146101ac5780638da5cb5b146101d5578063adcb3b7314610200576100dd565b80632c73dc4a116100bb5780632c73dc4a146101425780634a79d50c1461016d57806354d1f13d14610198578063715018a6146101a2576100dd565b80631f1bd692146100e2578063256929621461010d57806328411ae114610117575b600080fd5b3480156100ee57600080fd5b506100f76102c9565b6040516101049190611151565b60405180910390f35b6101156102d8565b005b34801561012357600080fd5b5061012c61032c565b604051610139919061127f565b60405180910390f35b34801561014e57600080fd5b506101576103dd565b604051610164919061127f565b60405180910390f35b34801561017957600080fd5b506101826103e2565b60405161018f9190611151565b60405180910390f35b6101a0610407565b005b6101aa610443565b005b3480156101b857600080fd5b506101d360048036038101906101ce9190611313565b610457565b005b3480156101e157600080fd5b506101ea610713565b6040516101f79190611361565b60405180910390f35b34801561020c57600080fd5b5061022760048036038101906102229190611417565b61073c565b005b34801561023557600080fd5b5061023e610982565b60405161024b9190611528565b60405180910390f35b61026e6004803603810190610269919061154a565b610a28565b005b61028a6004803603810190610285919061154a565b610a69565b005b34801561029857600080fd5b506102b360048036038101906102ae919061154a565b610a93565b6040516102c09190611586565b60405180910390f35b60606102d3610aae565b905090565b60006102e2610c6f565b67ffffffffffffffff164201905063389a75e1600c5233600052806020600c2055337fdbf36a107da19e49527a7176a1babf963b4b0ff8cde35ee35d6cd8f1f9ac7e1d600080a250565b60606000600167ffffffffffffffff81111561034b5761034a6115a1565b5b60405190808252806020026020018201604052801561037e57816020015b60608152602001906001900390816103695790505b5090506040518060400160405280601181526020017f52686561204d7965727320657420616c2e000000000000000000000000000000815250816000815181106103cb576103ca6115d0565b5b60200260200101819052508091505090565b606090565b60606040516020016103f390611625565b604051602081830303815290604052905090565b63389a75e1600c523360005260006020600c2055337ffa7b8eab7da67f412cc9575ed43464468f9bfbae89d1675917346ca6d8fe3c92600080a2565b61044b610c7a565b6104556000610cb2565b565b61045f610c7a565b80601160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600033905060008273ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610519573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610542919061176c565b905060005b815181101561070c57600073ffffffffffffffffffffffffffffffffffffffff166010600084848151811061057f5761057e6115d0565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16036106ff5760405180604001604052808473ffffffffffffffffffffffffffffffffffffffff16815260200160108361063491906117e4565b60ff1681525060106000848481518110610651576106506115d0565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160146101000a81548160ff021916908360ff1602179055509050505b8080600101915050610547565b5050505050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffff7487392754905090565b6000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508273ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156107c5573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f820116820180604052508101906107ee919061176c565b8581518110610800576107ff6115d0565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff161461085e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161085590611887565b60405180910390fd5b60108260ff16106108a4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161089b90611919565b60405180910390fd5b60405180604001604052803373ffffffffffffffffffffffffffffffffffffffff1681526020018360ff16815250601060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008201518160000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555060208201518160000160146101000a81548160ff021916908360ff16021790555090505050505050565b60606000600167ffffffffffffffff8111156109a1576109a06115a1565b5b6040519080825280602002602001820160405280156109cf5781602001602082028036833780820191505090505b50905030816000815181106109e7576109e66115d0565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250508091505090565b610a30610c7a565b63389a75e1600c52806000526020600c208054421115610a5857636f5e88186000526004601cfd5b6000815550610a6681610cb2565b50565b610a71610c7a565b8060601b610a8757637448fbae6000526004601cfd5b610a9081610cb2565b50565b600063389a75e1600c52816000526020600c20549050919050565b60606000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008173ffffffffffffffffffffffffffffffffffffffff166355735c5e6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610b24573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610b4d919061176c565b9050600060405180602001604052806000815250905060005b8251811015610c65576000838281518110610b8457610b836115d0565b5b602002602001015190506000601060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600073ffffffffffffffffffffffffffffffffffffffff168160000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614610c565783610c3383610d7a565b604051602001610c44929190611975565b60405160208183030381529060405293505b50508080600101915050610b66565b5080935050505090565b60006202a300905090565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff74873927543314610cb0576382b429006000526004601cfd5b565b610cba610f99565b15610d20577fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739278160601b60601c91508181547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3811560ff1b8217815550610d77565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffff748739278160601b60601c91508181547f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0600080a3818155505b50565b606060008290506000601060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206040518060400160405290816000820160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020016000820160149054906101000a900460ff1660ff1660ff16815250509050610e4f8160000151610f9e565b8273ffffffffffffffffffffffffffffffffffffffff16634a79d50c6040518163ffffffff1660e01b8152600401600060405180830381865afa158015610e9a573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610ec39190611a3f565b8373ffffffffffffffffffffffffffffffffffffffff166328411ae16040518163ffffffff1660e01b8152600401600060405180830381865afa158015610f0e573d6000803e3d6000fd5b505050506040513d6000823e3d601f19601f82011682018060405250810190610f379190611b69565b600081518110610f4a57610f496115d0565b5b60200260200101516000846020015160ff1660108110610f6d57610f6c6115d0565b5b01604051602001610f819493929190611e4c565b60405160208183030381529060405292505050919050565b600090565b6060610fa982611018565b905060ff6000190460061b60228201816022026028822016608860f01b60005b600115610fe85782811a82028182015260018101905060148103610fc9575b50838351166000511660011c8351188352602083019250838351166020511660011c835118835250505050919050565b60606110238261103e565b90506002815101613078825260028203915080825250919050565b60606040519050608081016040526f30313233343536373839616263646566600f526002810190506028815260208101600060288201528260601b925060005b6001156110ba57808101820184821a600f81165160018301538060041c518253600183019250601483036110b35750506110ba565b505061107e565b5050919050565b600081519050919050565b600082825260208201905092915050565b60005b838110156110fb5780820151818401526020810190506110e0565b60008484015250505050565b6000601f19601f8301169050919050565b6000611123826110c1565b61112d81856110cc565b935061113d8185602086016110dd565b61114681611107565b840191505092915050565b6000602082019050818103600083015261116b8184611118565b905092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b600082825260208201905092915050565b60006111bb826110c1565b6111c5818561119f565b93506111d58185602086016110dd565b6111de81611107565b840191505092915050565b60006111f583836111b0565b905092915050565b6000602082019050919050565b600061121582611173565b61121f818561117e565b9350836020820285016112318561118f565b8060005b8581101561126d578484038952815161124e85826111e9565b9450611259836111fd565b925060208a01995050600181019050611235565b50829750879550505050505092915050565b60006020820190508181036000830152611299818461120a565b905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006112e0826112b5565b9050919050565b6112f0816112d5565b81146112fb57600080fd5b50565b60008135905061130d816112e7565b92915050565b600060208284031215611329576113286112ab565b5b6000611337848285016112fe565b91505092915050565b600061134b826112b5565b9050919050565b61135b81611340565b82525050565b60006020820190506113766000830184611352565b92915050565b6000819050919050565b61138f8161137c565b811461139a57600080fd5b50565b6000813590506113ac81611386565b92915050565b6113bb81611340565b81146113c657600080fd5b50565b6000813590506113d8816113b2565b92915050565b600060ff82169050919050565b6113f4816113de565b81146113ff57600080fd5b50565b600081359050611411816113eb565b92915050565b6000806000606084860312156114305761142f6112ab565b5b600061143e8682870161139d565b935050602061144f868287016113c9565b925050604061146086828701611402565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b61149f81611340565b82525050565b60006114b18383611496565b60208301905092915050565b6000602082019050919050565b60006114d58261146a565b6114df8185611475565b93506114ea83611486565b8060005b8381101561151b57815161150288826114a5565b975061150d836114bd565b9250506001810190506114ee565b5085935050505092915050565b6000602082019050818103600083015261154281846114ca565b905092915050565b6000602082840312156115605761155f6112ab565b5b600061156e848285016113c9565b91505092915050565b6115808161137c565b82525050565b600060208201905061159b6000830184611577565b92915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4372697469717565206f6620546869732053686f770000000000000000000000815250565b6000611630826115ff565b601582019150819050919050565b600080fd5b61164c82611107565b810181811067ffffffffffffffff8211171561166b5761166a6115a1565b5b80604052505050565b600061167e6112a1565b905061168a8282611643565b919050565b600067ffffffffffffffff8211156116aa576116a96115a1565b5b602082029050602081019050919050565b600080fd5b6000815190506116cf816113b2565b92915050565b60006116e86116e38461168f565b611674565b9050808382526020820190506020840283018581111561170b5761170a6116bb565b5b835b81811015611734578061172088826116c0565b84526020840193505060208101905061170d565b5050509392505050565b600082601f8301126117535761175261163e565b5b81516117638482602086016116d5565b91505092915050565b600060208284031215611782576117816112ab565b5b600082015167ffffffffffffffff8111156117a05761179f6112b0565b5b6117ac8482850161173e565b91505092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006117ef8261137c565b91506117fa8361137c565b92508261180a576118096117b5565b5b828206905092915050565b7f696e76616c696420776f726b2028776173207468652067617264656e2063686160008201527f6e6765643f290000000000000000000000000000000000000000000000000000602082015250565b60006118716026836110cc565b915061187c82611815565b604082019050919050565b600060208201905081810360008301526118a081611864565b9050919050565b7f696e76616c696420637269746963616c206f70696e696f6e2028696e6469636560008201527f73207374617274206174207a65726f2900000000000000000000000000000000602082015250565b60006119036030836110cc565b915061190e826118a7565b604082019050919050565b60006020820190508181036000830152611932816118f6565b9050919050565b600081905092915050565b600061194f826110c1565b6119598185611939565b93506119698185602086016110dd565b80840191505092915050565b60006119818285611944565b915061198d8284611944565b91508190509392505050565b600080fd5b600067ffffffffffffffff8211156119b9576119b86115a1565b5b6119c282611107565b9050602081019050919050565b60006119e26119dd8461199e565b611674565b9050828152602081018484840111156119fe576119fd611999565b5b611a098482856110dd565b509392505050565b600082601f830112611a2657611a2561163e565b5b8151611a368482602086016119cf565b91505092915050565b600060208284031215611a5557611a546112ab565b5b600082015167ffffffffffffffff811115611a7357611a726112b0565b5b611a7f84828501611a11565b91505092915050565b600067ffffffffffffffff821115611aa357611aa26115a1565b5b602082029050602081019050919050565b6000611ac7611ac284611a88565b611674565b90508083825260208201905060208402830185811115611aea57611ae96116bb565b5b835b81811015611b3157805167ffffffffffffffff811115611b0f57611b0e61163e565b5b808601611b1c8982611a11565b85526020850194505050602081019050611aec565b5050509392505050565b600082601f830112611b5057611b4f61163e565b5b8151611b60848260208601611ab4565b91505092915050565b600060208284031215611b7f57611b7e6112ab565b5b600082015167ffffffffffffffff811115611b9d57611b9c6112b0565b5b611ba984828501611b3b565b91505092915050565b7f3c703e0000000000000000000000000000000000000000000000000000000000815250565b7f207468696e6b732074686174203c693e3c7370616e207374796c653d2277686960008201527f74652d73706163653a206e6f777261703b223e00000000000000000000000000602082015250565b6000611c34603383611939565b9150611c3f82611bd8565b603382019050919050565b7f3c2f7370616e3e3c2f693e203c7370616e207374796c653d2277686974652d7360008201527f706163653a206e6f777261703b223e6279200000000000000000000000000000602082015250565b6000611ca6603283611939565b9150611cb182611c4a565b603282019050919050565b7f3c2f7370616e3e206973203c7370616e207374796c653d2277686974652d737060008201527f6163653a206e6f777261703b223e000000000000000000000000000000000000602082015250565b6000611d18602e83611939565b9150611d2382611cbc565b602e82019050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680611d7557607f821691505b602082108103611d8857611d87611d2e565b5b50919050565b60008190508160005260206000209050919050565b60008154611db081611d5d565b611dba8186611939565b94506001821660008114611dd55760018114611dea57611e1d565b60ff1983168652811515820286019350611e1d565b611df385611d8e565b60005b83811015611e1557815481890152600182019150602081019050611df6565b838801955050505b50505092915050565b7f2e3c2f7370616e3e3c2f703e0a00000000000000000000000000000000000000815250565b6000611e5782611bb2565b600382019150611e678287611944565b9150611e7282611c27565b9150611e7e8286611944565b9150611e8982611c99565b9150611e958285611944565b9150611ea082611d0b565b9150611eac8284611da3565b9150611eb782611e26565b600d820191508190509594505050505056fea2646970667358221220f2327135db0615eacacb28efa773ef22c9d792161cff27dabb417ee7eb02c36e64736f6c634300081b0033",
  "devdoc": {
    "errors": {
      "AlreadyInitialized()": [
        {
          "details": "Cannot double-initialize."
        }
      ],
      "NewOwnerIsZeroAddress()": [
        {
          "details": "The `newOwner` cannot be the zero address."
        }
      ],
      "NoHandoverRequest()": [
        {
          "details": "The `pendingOwner` does not have a valid handover request."
        }
      ],
      "Unauthorized()": [
        {
          "details": "The caller is not authorized to call the function."
        }
      ]
    },
    "events": {
      "OwnershipHandoverCanceled(address)": {
        "details": "The ownership handover to `pendingOwner` has been canceled."
      },
      "OwnershipHandoverRequested(address)": {
        "details": "An ownership handover to `pendingOwner` has been requested."
      },
      "OwnershipTransferred(address,address)": {
        "details": "The ownership is transferred from `oldOwner` to `newOwner`. This event is intentionally kept the same as OpenZeppelin's Ownable to be compatible with indexers and [EIP-173](https://eips.ethereum.org/EIPS/eip-173), despite it not being as lightweight as a single argument event."
      }
    },
    "kind": "dev",
    "methods": {
      "cancelOwnershipHandover()": {
        "details": "Cancels the two-step ownership handover to the caller, if any."
      },
      "completeOwnershipHandover(address)": {
        "details": "Allows the owner to complete the two-step ownership handover to `pendingOwner`. Reverts if there is no existing ownership handover requested by `pendingOwner`."
      },
      "owner()": {
        "details": "Returns the owner of the contract."
      },
      "ownershipHandoverExpiresAt(address)": {
        "details": "Returns the expiry timestamp for the two-step ownership handover to `pendingOwner`."
      },
      "renounceOwnership()": {
        "details": "Allows the owner to renounce their ownership."
      },
      "requestOwnershipHandover()": {
        "details": "Request a two-step ownership handover to the caller. The request will automatically expire in 48 hours (172800 seconds) by default."
      },
      "transferOwnership(address)": {
        "details": "Allows the owner to transfer the ownership to `newOwner`."
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 479,
        "contract": "contracts/ShowCritique.sol:ShowCritique",
        "label": "OPINIONS",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_string_storage)16_storage"
      },
      {
        "astId": 484,
        "contract": "contracts/ShowCritique.sol:ShowCritique",
        "label": "critiques",
        "offset": 0,
        "slot": "16",
        "type": "t_mapping(t_address,t_struct(Critique)455_storage)"
      },
      {
        "astId": 486,
        "contract": "contracts/ShowCritique.sol:ShowCritique",
        "label": "gardenAddress",
        "offset": 0,
        "slot": "17",
        "type": "t_address_payable"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_address_payable": {
        "encoding": "inplace",
        "label": "address payable",
        "numberOfBytes": "20"
      },
      "t_array(t_string_storage)16_storage": {
        "base": "t_string_storage",
        "encoding": "inplace",
        "label": "string[16]",
        "numberOfBytes": "512"
      },
      "t_mapping(t_address,t_struct(Critique)455_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct ShowCritique.Critique)",
        "numberOfBytes": "32",
        "value": "t_struct(Critique)455_storage"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(Critique)455_storage": {
        "encoding": "inplace",
        "label": "struct ShowCritique.Critique",
        "members": [
          {
            "astId": 452,
            "contract": "contracts/ShowCritique.sol:ShowCritique",
            "label": "critic",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 454,
            "contract": "contracts/ShowCritique.sol:ShowCritique",
            "label": "critique",
            "offset": 20,
            "slot": "0",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}