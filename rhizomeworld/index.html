<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Cstyle%3E%20text%20%7B%20fill:%20%23000;%20%7D%20@media%20(prefers-color-scheme:%20dark)%20%7B%20text%20%7B%20fill:%20%23fff;%20%7D%20%7D%20%3C/style%3E%3Ctext%20y='.9em'%20font-size='90'%3E%20⚘%20%3C/text%3E%3C/svg%3E%0A"
    />
    <title>World Computer Sculpture Garden</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html {
        -moz-text-size-adjust: none;
        -webkit-text-size-adjust: none;
        text-size-adjust: none;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      body {
        min-height: 100vh;
        background-color: #fff;
      }
      html,
      body,
      pre {
        font-family: "Courier New", "Courier", monospace;
        font-size: 15px;
        line-height: 1.3;
      }
      .garden-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        overflow: hidden;
      }
      .garden-field {
        white-space: pre;
        font-size: 15px;
        line-height: 1.5;
        margin: 0;
        padding: 0;
      }
      .flower {
        display: inline-block;
        transition: opacity 15s ease-in-out;
        opacity: 0;
        position: absolute;
        font-size: 15px;
        /* Prevent flickering during animation */
        transform: translateZ(0); /* Force GPU acceleration */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        /* Prevent text selection during animation */
        user-select: none;
      }
      .flower.visible {
        opacity: 1;
      }
      /* Add a special class for animating flowers */
      .flower[data-animating="true"] {
        /* Higher z-index during animation to prevent overlapping issues */
        z-index: 5;
      }
      .info-text {
        position: absolute;
        opacity: 0;
        font-size: 15px;
        pointer-events: none;
        transition: opacity 4s ease-in-out;
        text-align: left;
        white-space: nowrap;
        background-color: rgba(255, 255, 255, 0.9); /* White background with slight transparency */
        padding: 0 4px; /* Horizontal padding for better readability */
        border-radius: 2px; /* Slightly rounded corners */
        box-shadow: 0 0 5px rgba(255, 255, 255, 0.8); /* White glow effect */
        z-index: 10; /* Ensure text appears above flowers */
      }
      .info-text.visible {
        opacity: 1;
      }
      .debug-panel {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        padding: 10px;
        font-size: 12px;
        display: none;
        z-index: 100;
      }
      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #fafafa;
        z-index: 1000;
      }
      .loading-text {
        font-size: 15px;
      }
    </style>
  </head>
  <body>
    <div class="loading"></div>
    <div class="garden-container">
      <div class="garden-field" id="garden-field"></div>
    </div>
    <div class="debug-panel" id="debug-panel">
      <div>Flowers: <span id="flower-count">0</span></div>
      <div>Block: <span id="current-block">-</span></div>
      <div>Wind Effect: <span id="wind-effect">None</span></div>
      <div>Wandering Text: <span id="wandering-state">On</span></div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
    <script>
      document.addEventListener('DOMContentLoaded', async () => {
        // Constants
        const GARDEN_CONTRACT_ADDRESS = '0x2a362fF002f7ce62D3468509dD2A4a9f5A8EBBb0';
        const GARDEN_ABI = [
          "function flowers() view returns (uint256)",
          "function authors() view returns (string[] memory)",
          "function sculptures() view returns (address[] memory)"
        ];
        const SCULPTURE_ABI = [
          "function title() view returns (string memory)",
          "function authors() view returns (string[] memory)"
        ];

        // Contract interaction setup
        let provider, gardenContract, sculptureContracts = [];
        let isDebugMode = location.search.includes('debug=true');
        let artworkInfo = [];
        // Try to get stored flower count, default to 283 if not available
        let currentFlowerCount = parseInt(localStorage.getItem('flowerCount') || '283', 10);
        let displayedFlowers = 0;
        let isInitialized = false;

        // Elements
        const gardenField = document.getElementById('garden-field');
        const debugPanel = document.getElementById('debug-panel');
        const flowerCountEl = document.getElementById('flower-count');
        const currentBlockEl = document.getElementById('current-block');
        const windEffectEl = document.getElementById('wind-effect');
        const loadingEl = document.querySelector('.loading');

        // Show debug panel if needed
        if (isDebugMode) {
          debugPanel.style.display = 'block';
          flowerCountEl.textContent = currentFlowerCount;
        }

        // Grid and visualization settings
        const config = {
          // Dynamically calculate grid size based on window dimensions
          // Default values that will be adjusted in the init function
          gridWidth: 120,         // Characters per line
          gridHeight: 40,         // Number of lines
          infoTextDensity: 10,    // Lower means more info texts
          windStrength: 1.0,      // Wind effect strength (1 unit = 1 cell)
          windInterval: 1000,     // Ms between checking for new wind waves
          windDuration: 2500,     // Ms each wind wave lasts
          flowerFadeInTime: 15000, // Ms for new flowers to fade in
          wanderingTextEnabled: true, // Enable/disable wandering text feature
          wanderingTextInterval: 12000 // Ms between text movements
        };

        // Calculate optimal grid size based on screen dimensions
        function calculateGridSize() {
          // Get window dimensions
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;

          // Calculate how many characters can fit
          // Assuming each character is roughly 1em wide and 1.2em tall
          const fontSizeInPx = 15;
          const charWidth = fontSizeInPx;
          const charHeight = fontSizeInPx * 1.2;

          // Calculate grid dimensions matching exactly to window size
          // Use ceiling to ensure we fill the space completely
          config.gridWidth = Math.ceil(windowWidth / charWidth) - 1;
          config.gridHeight = Math.ceil(windowHeight / charHeight) - 1;

          console.log(`Grid size set to ${config.gridWidth} x ${config.gridHeight} based on screen size`);
        }

        // Initialize application
        async function init() {
          try {
            // Calculate grid size based on screen dimensions
            calculateGridSize();

            // Handle window resize
            window.addEventListener('resize', () => {
              calculateGridSize();
              // Regenerate garden on resize with a debounce
              clearTimeout(window.resizeTimer);
              window.resizeTimer = setTimeout(() => {
                generateGarden();
              }, 500);
            });
            
            // Add keyboard shortcut to toggle wandering text (press 'w')
            document.addEventListener('keydown', (event) => {
              if (event.key === 'w') {
                const isEnabled = toggleWanderingText();
                console.log(`Wandering text ${isEnabled ? 'enabled' : 'disabled'}`);
              }
            });

            // Connect to Ethereum
            provider = new ethers.providers.JsonRpcProvider("https://eth-mainnet.g.alchemy.com/v2/JFKk0rH8qT8yvFnJhbY0MwAX43-YrWAv");
            gardenContract = new ethers.Contract(GARDEN_CONTRACT_ADDRESS, GARDEN_ABI, provider);

            // Get flower count and artwork information
            await fetchFlowerCount();
            await fetchArtworkInfo();

            // Generate the initial garden
            generateGarden();

            // Setup block listeners for updates
            provider.on('block', onNewBlock);

            // Start wind effects
            scheduleWindEffect();

            // Hide loading screen
            loadingEl.style.display = 'none';
            isInitialized = true;

            console.log('Garden visualization initialized');
          } catch (error) {
            console.error('Initialization error:', error);

            // Show static fallback garden without announcing the error
            setTimeout(() => {
              displayStaticGarden();
              loadingEl.style.display = 'none';
            }, 1000);
          }
        }

        // Fetch the current flower count from the contract
        async function fetchFlowerCount() {
          try {
            const count = await gardenContract.flowers();
            currentFlowerCount = parseInt(count.toString(), 10);

            // Store the flower count in localStorage for future sessions
            localStorage.setItem('flowerCount', currentFlowerCount.toString());

            if (isDebugMode) {
              flowerCountEl.textContent = currentFlowerCount;
            }
            return currentFlowerCount;
          } catch (error) {
            console.error('Error fetching flower count:', error);
            return currentFlowerCount; // Return current count (from localStorage or default)
          }
        }

        // Fetch information about the artworks
        async function fetchArtworkInfo() {
          try {
            // Get sculpture addresses
            const sculptureAddresses = await gardenContract.sculptures();

            // For each sculpture, create a contract instance and get info
            for (const address of sculptureAddresses) {
              const sculptureContract = new ethers.Contract(address, SCULPTURE_ABI, provider);
              sculptureContracts.push(sculptureContract);

              try {
                const title = await sculptureContract.title();
                const authors = await sculptureContract.authors();

                artworkInfo.push({
                  title,
                  authors,
                  address
                });
              } catch (err) {
                console.warn(`Failed to get info for sculpture at ${address}:`, err);
              }
            }

            console.log('Artwork info:', artworkInfo);
          } catch (error) {
            console.error('Error fetching artwork info:', error);
          }
        }

        // Generate the garden visualization
        function generateGarden() {
          gardenField.innerHTML = '';
          const grid = createEmptyGrid(config.gridWidth, config.gridHeight);

          // Place flowers based on noise algorithm
          const flowersToDisplay = Math.min(currentFlowerCount, 10000); // Limit for performance
          const flowerPositions = placeFlowersUsingNoise(grid, flowersToDisplay);

          // Create flower elements
          flowerPositions.forEach((pos, i) => {
            const flowerEl = createFlowerElement(pos.x, pos.y);
            gardenField.appendChild(flowerEl);

            // Make initial flowers visible immediately
            flowerEl.classList.add('visible');
          });

          // Place artwork info text
          if (artworkInfo.length > 0) {
            placeInfoText();
          }

          displayedFlowers = flowersToDisplay;
        }

        // Create an empty grid
        function createEmptyGrid(width, height) {
          const grid = [];
          for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
              row.push(' ');
            }
            grid.push(row);
          }
          return grid;
        }

        // Create a seeded pseudo-random number generator
        function createSeededRandom(seed) {
          return function() {
            seed = (seed * 16807) % 2147483647;
            return (seed - 1) / 2147483646;
          };
        }
        
        // Place flowers using deterministic noise algorithm (based on GardenContributions.sol)
        function placeFlowersUsingNoise(grid, count) {
          // Use a fixed seed for deterministic placement
          // This will ensure we get the same pattern every time
          const fixedSeed = 12345; // Fixed seed for consistent patterns
          const random = createSeededRandom(fixedSeed);
          
          const positions = [];
          let placed = 0;
          let attempts = 0;
          
          // Ensure even distribution - divide screen into sections and ensure flowers in each
          const numSections = 4; // Divide screen into quarters
          const sectionHeight = config.gridHeight / numSections;
          const flowersPerSection = Math.ceil(count / numSections);
          
          // Track how many flowers we've placed in each section
          const sectionCounts = new Array(numSections).fill(0);
          
          // Try to place all flowers with better distribution
          while (placed < count && attempts < count * 20) {
            attempts++;

            // Choose a section that needs more flowers
            // Focus on underfilled sections, especially the bottom ones
            let sectionIndex;
            if (attempts < count * 10) {
              // During first half of attempts, prioritize empty sections
              // Give bottom sections higher priority
              const weights = sectionCounts.map((count, index) => {
                // More weight to sections with fewer flowers and sections near the bottom
                return (flowersPerSection - count) * (index + 1);
              });
              
              const totalWeight = weights.reduce((sum, weight) => sum + Math.max(0, weight), 0);
              let randomValue = random() * totalWeight;
              
              for (sectionIndex = 0; sectionIndex < numSections; sectionIndex++) {
                if (weights[sectionIndex] <= 0) continue;
                randomValue -= weights[sectionIndex];
                if (randomValue <= 0) break;
              }
              if (sectionIndex >= numSections) {
                sectionIndex = numSections - 1; // Default to bottom section
              }
            } else {
              // For later attempts, just place anywhere
              sectionIndex = Math.floor(random() * numSections);
            }
            
            // Get position within that section
            const sectionStartY = Math.floor(sectionIndex * sectionHeight);
            const sectionEndY = Math.floor(Math.min(config.gridHeight, (sectionIndex + 1) * sectionHeight));
            
            const x = Math.floor(random() * config.gridWidth);
            const y = sectionStartY + Math.floor(random() * (sectionEndY - sectionStartY));

            // For this grid cell, calculate a noise value
            const noiseVal = gridNoise(x, y, 0xf);

            // We'll make the threshold more lenient as we place more flowers
            // This ensures we get a nice pattern but still place enough flowers
            const baseThreshold = 0.7; // Lower threshold = more flowers
            const threshold = Math.max(0.3, baseThreshold - (placed / count) * 0.5);

            if (Math.abs(noiseVal) > threshold && grid[y][x] === ' ') {
              // Place flower in grid
              grid[y][x] = '⚘';
              positions.push({ x, y });
              placed++;
              sectionCounts[sectionIndex]++;
            }
          }

          return positions;
        }

        // Create a flower element at specific coordinates
        function createFlowerElement(x, y) {
          const flower = document.createElement('div');
          flower.className = 'flower';
          flower.textContent = '⚘';
          flower.style.left = `${x * 1.0}em`;
          flower.style.top = `${y * 1.2}em`;
          flower.dataset.x = x;
          flower.dataset.y = y;
          flower.dataset.baseX = x * 1.0;
          flower.dataset.baseY = y * 1.2;
          flower.dataset.animating = ""; // Initialize animation state
          
          // Prevent potential rendering issues for animation
          flower.style.willChange = 'left, top'; // Hint to browser about properties that will change
          flower.style.backfaceVisibility = 'hidden'; // Prevent flickering in some browsers
          
          return flower;
        }

        // Place text elements with artwork information
        function placeInfoText() {
          // Use same seeded random generator for consistent text placement
          const random = createSeededRandom(789012); // Different seed from flower placement
          
          // Create an array of grid positions that match where flowers could be placed
          // We'll place text at these grid positions to ensure alignment
          const gridPositions = [];
          
          // Generate grid positions (essentially the same as the flower placement logic)
          for (let y = 0; y < config.gridHeight; y++) {
            for (let x = 0; x < config.gridWidth; x++) {
              gridPositions.push({ x, y });
            }
          }
          
          // Shuffle the positions using our deterministic random
          for (let i = gridPositions.length - 1; i > 0; i--) {
            const j = Math.floor(random() * (i + 1));
            [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];
          }
          
          // Keep track of used positions to avoid overlap
          const usedPositions = new Set();
          
          // Function to find an available position for text
          function findAvailablePosition(length, startIdx) {
            // Find a position that has enough space for the text
            for (let i = startIdx; i < gridPositions.length; i++) {
              const pos = gridPositions[i];
              
              // Check if this position and needed length is available
              let available = true;
              for (let j = 0; j < length; j++) {
                const checkPos = `${pos.x + j},${pos.y}`;
                if (usedPositions.has(checkPos) || (pos.x + j) >= config.gridWidth) {
                  available = false;
                  break;
                }
              }
              
              // If we found an available spot, mark it as used
              if (available) {
                for (let j = 0; j < length; j++) {
                  usedPositions.add(`${pos.x + j},${pos.y}`);
                }
                return pos;
              }
            }
            
            // If no position is found, return a fallback
            return { x: 5, y: 5 + artworkInfo.indexOf(artwork) * 2 };
          }
          
          // Start index for art placements
          let posIndex = 100; // Skip some of the first positions to make room for flowers
          
          artworkInfo.forEach((artwork, index) => {
            // Place title in grid
            const titleLength = artwork.title.length;
            const titlePos = findAvailablePosition(titleLength, posIndex);
            posIndex += 50; // Move forward to space out the artworks
            
            const titleEl = document.createElement('div');
            titleEl.className = 'info-text';
            titleEl.textContent = artwork.title;
            titleEl.style.left = `${titlePos.x * 1.0}em`;
            titleEl.style.top = `${titlePos.y * 1.2}em`;
            
            gardenField.appendChild(titleEl);
            
            // Place authors in grid, below the title
            artwork.authors.forEach((author, authorIndex) => {
              const authorLength = author.length;
              // Position below the title
              const authorPos = findAvailablePosition(
                authorLength, 
                posIndex + authorIndex * 20
              );
              
              const authorEl = document.createElement('div');
              authorEl.className = 'info-text';
              authorEl.textContent = author;
              authorEl.style.left = `${authorPos.x * 1.0}em`;
              authorEl.style.top = `${authorPos.y * 1.2}em`;
              
              gardenField.appendChild(authorEl);
            });

            // Make text elements visible immediately
            titleEl.classList.add('visible');
            
            // Extract position from style (remove 'em' and convert to number)
            const titleX = parseInt(titleEl.style.left.replace('em', ''));
            const titleY = parseInt(titleEl.style.top.replace('em', '')) / 1.2;
            
            // Store initial position for wandering
            titleEl.dataset.baseX = titleX;
            titleEl.dataset.baseY = titleY;
            titleEl.dataset.currentX = titleX;
            titleEl.dataset.currentY = titleY;

            artwork.authors.forEach((_, i) => {
              const authorEl = gardenField.querySelectorAll('.info-text')[index * (artwork.authors.length + 1) + i + 1];
              authorEl.classList.add('visible');
              
              // Extract position from style (remove 'em' and convert to number)
              const authorX = parseInt(authorEl.style.left.replace('em', ''));
              const authorY = parseInt(authorEl.style.top.replace('em', '')) / 1.2;
              
              // Store initial position for wandering
              authorEl.dataset.baseX = authorX;
              authorEl.dataset.baseY = authorY;
              authorEl.dataset.currentX = authorX;
              authorEl.dataset.currentY = authorY;
            });
          });
        }

        // Update garden when new flowers are detected
        async function updateGarden(newFlowerCount) {
          if (newFlowerCount <= displayedFlowers) return;

          const additionalFlowers = newFlowerCount - displayedFlowers;
          const grid = createEmptyGrid(config.gridWidth, config.gridHeight);

          // Mark existing flowers in grid
          const existingFlowers = document.querySelectorAll('.flower.visible');
          existingFlowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            if (x >= 0 && y >= 0 && y < grid.length && x < grid[y].length) {
              grid[y][x] = '⚘';
            }
          });

          // Add new flowers
          const newPositions = placeFlowersUsingNoise(grid, additionalFlowers);

          // Create and add new flower elements
          newPositions.forEach(pos => {
            const flowerEl = createFlowerElement(pos.x, pos.y);
            gardenField.appendChild(flowerEl);

            // Fade in the new flower
            setTimeout(() => {
              flowerEl.classList.add('visible');
            }, Math.random() * 1000);
          });

          displayedFlowers = newFlowerCount;

          // Update debug info
          if (isDebugMode) {
            flowerCountEl.textContent = newFlowerCount;
          }
        }

        // Handle new blocks from the blockchain
        async function onNewBlock(blockNumber) {
          if (!isInitialized) return;

          if (isDebugMode) {
            currentBlockEl.textContent = blockNumber;
          }

          // Fetch updated flower count
          const newFlowerCount = await fetchFlowerCount();

          // Add new flowers if needed
          if (newFlowerCount > currentFlowerCount) {
            console.log(`New flowers detected: ${newFlowerCount - currentFlowerCount}`);
            currentFlowerCount = newFlowerCount;
            updateGarden(newFlowerCount);
          }
        }

        // Apply wave-like ripple effect across the garden
        function applyWindEffect(direction, windStrength) {
          if (isDebugMode) {
            windEffectEl.textContent = direction;
          }
          
          // Get all visible flowers and organize them by position
          const flowers = Array.from(document.querySelectorAll('.flower.visible'));
          const flowerMap = {};
          
          // Create a map of flowers by their position for quick lookup
          flowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            flowerMap[`${x},${y}`] = flower;
          });
          
          // Get grid boundaries
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          flowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          });
          
          // Direction vectors for the flower movement and wave direction
          let dx = 0, dy = 0;
          let waveDirection = 'horizontal'; // Default to horizontal
          let waveStartX = 0, waveStartY = 0;
          let waveDx = 0, waveDy = 0; // Wave direction vector
          
          switch (direction) {
            case 'left': 
              dx = -1;
              waveDirection = 'horizontal';
              waveStartX = config.gridWidth - 1; // Start from right edge
              waveStartY = 0;
              waveDx = -1; waveDy = 0; // Wave moves left
              break;
            case 'right': 
              dx = 1;
              waveDirection = 'horizontal';
              waveStartX = 0; // Start from left edge
              waveStartY = 0;
              waveDx = 1; waveDy = 0; // Wave moves right
              break;
            case 'up': 
              dy = -1;
              waveDirection = 'vertical';
              waveStartX = 0;
              waveStartY = config.gridHeight - 1; // Start from bottom edge
              waveDx = 0; waveDy = -1; // Wave moves up
              break;
            case 'down': 
              dy = 1;
              waveDirection = 'vertical';
              waveStartX = 0;
              waveStartY = 0; // Start from top edge
              waveDx = 0; waveDy = 1; // Wave moves down
              break;
            case 'diagonal-up-right': 
              dx = 1; dy = -1;
              waveDirection = 'diagonal';
              waveStartX = 0; // Start from bottom-left
              waveStartY = config.gridHeight - 1;
              waveDx = 1; waveDy = -1; // Wave moves up-right
              break;
            case 'diagonal-up-left': 
              dx = -1; dy = -1;
              waveDirection = 'diagonal';
              waveStartX = config.gridWidth - 1; // Start from bottom-right
              waveStartY = config.gridHeight - 1;
              waveDx = -1; waveDy = -1; // Wave moves up-left
              break;
            case 'diagonal-down-right': 
              dx = 1; dy = 1;
              waveDirection = 'diagonal';
              waveStartX = 0; // Start from top-left
              waveStartY = 0;
              waveDx = 1; waveDy = 1; // Wave moves down-right
              break;
            case 'diagonal-down-left': 
              dx = -1; dy = 1;
              waveDirection = 'diagonal';
              waveStartX = config.gridWidth - 1; // Start from top-right
              waveStartY = 0;
              waveDx = -1; waveDy = 1; // Wave moves down-left
              break;
          }
          
          // Wave animation parameters - defined globally so they can be used in timeout calculations
          const waveWidth = 2; // How many cells wide the wave is
          const waveFrameInterval = 49; // ms between wave animation frames
          // Store in window for access from other functions
          window.currentWaveFrameInterval = waveFrameInterval;
          
          // Calculate wave distance based on direction
          let waveDistance;
          if (waveDirection === 'diagonal') {
            // For diagonal, calculate the exact diagonal distance across the grid
            // Using Pythagorean theorem for the diagonal distance from one corner to the other
            waveDistance = Math.ceil(Math.sqrt(
              Math.pow(config.gridWidth, 2) + 
              Math.pow(config.gridHeight, 2)
            )) + 20; // Add extra distance to ensure it goes all the way
          } else if (waveDirection === 'horizontal') {
            waveDistance = config.gridWidth + 10; // Add extra to ensure full coverage
          } else { // vertical
            waveDistance = config.gridHeight + 10; // Add extra to ensure full coverage
          }
          
          // Calculate total wave duration based on distance and frame interval
          // This ensures waves complete their full journey regardless of grid size
          const waveTotalDuration = waveDistance * waveFrameInterval;
          
          // Animate the wave passing through the garden
          let waveProgress = 0;
          const waveTimer = setInterval(() => {
            // Increment wave position
            waveProgress++;
            
            if (waveProgress > waveDistance) {
              clearInterval(waveTimer);
              resetWindEffect();
              return;
            }
            
            // Calculate which flowers are affected by the current wave position
            // Check all grid positions
            for (let y = 0; y < config.gridHeight; y++) {
              for (let x = 0; x < config.gridWidth; x++) {
                let isInWave = false;
                
                if (waveDirection === 'horizontal') {
                  // For horizontal waves
                  const wavePos = waveStartX + (waveDx * waveProgress);
                  isInWave = Math.abs(x - wavePos) <= waveWidth;
                }
                else if (waveDirection === 'vertical') {
                  // For vertical waves
                  const wavePos = waveStartY + (waveDy * waveProgress);
                  isInWave = Math.abs(y - wavePos) <= waveWidth;
                }
                else if (waveDirection === 'diagonal') {
                  // For diagonal waves, we need a different approach
                  // Project the point onto the wave path to see if it's within the current wave front
                  
                  // Wave path is defined by the start point and the direction
                  // Calculate current wave position along the diagonal
                  const waveX = waveStartX + (waveDx * waveProgress);
                  const waveY = waveStartY + (waveDy * waveProgress);
                  
                  // Calculate the distance along the wave path (dot product)
                  // This gives us how far along the path this point would be
                  const dx2 = x - waveStartX;
                  const dy2 = y - waveStartY;
                  
                  // Project the point onto the wave direction vector
                  // This is effectively dot(point - waveStart, waveDir) / |waveDir|
                  // Since waveDir is normalized (-1, 0, or 1), we can simplify
                  const projectionOnWavePath = dx2 * waveDx + dy2 * waveDy;
                  
                  // Check if this point is close to the current wave progress along the path
                  const distanceFromWaveFront = Math.abs(projectionOnWavePath - waveProgress);
                  
                  // The wave should be narrow in the direction of movement but wide perpendicular to it
                  // Calculate perpendicular distance (distance to the diagonal line)
                  // For a line with direction (dx,dy), the perpendicular is (-dy,dx)
                  const perpendicular = Math.abs(dx2 * (-waveDy) + dy2 * waveDx);
                  
                  // A point is in the wave if:
                  // 1. It's close to the current wave front (within waveWidth in the direction of travel)
                  // 2. It's close to the diagonal path (within a wider range perpendicular to travel)
                  
                  // Use the full grid diagonal as the perpendicular width
                  const gridDiagonal = Math.sqrt(Math.pow(config.gridWidth, 2) + Math.pow(config.gridHeight, 2));
                  // Set the perpendicular width to the full grid diagonal for maximum coverage
                  const diagonalPerpWidth = gridDiagonal;
                  
                  isInWave = (distanceFromWaveFront <= waveWidth * 1.5) && (perpendicular <= diagonalPerpWidth);
                }
                
                // If this position is in the wave and has a flower, animate it
                if (isInWave) {
                  const flower = flowerMap[`${x},${y}`];
                  if (flower) {
                    // Move the flower by adjusting its position
                    const origLeft = parseFloat(flower.dataset.baseX);
                    const origTop = parseFloat(flower.dataset.baseY);
                    
                    // Check if this flower is already being animated
                    if (!flower.dataset.animating) {
                      // Mark as animating to prevent overlapping animations
                      flower.dataset.animating = "true";
                      
                      // Apply the movement with a greatly reduced offset (quarter of the original)
                      flower.style.left = `${origLeft + (dx * windStrength)}em`;
                      flower.style.top = `${origTop + (dy * windStrength)}em`;
                      
                      // Reset flower position after a brief time
                      setTimeout(() => {
                        // Return to original position with transition
                        flower.style.left = `${origLeft}em`;
                        flower.style.top = `${origTop}em`;
                        
                        // After the transition completes, remove the animating flag
                        setTimeout(() => {
                          flower.dataset.animating = "";
                        }, 300); // Slightly longer than the transition time
                      }, waveWidth * 100); // Use fixed value of 100ms here
                    }
                  }
                }
              }
            }
          }, waveFrameInterval);
          
          // Calculate how long it should take for the wave to complete
          // We'll clear the wave timer once it completes its journey
          const waveTimeout = waveTotalDuration + 500; // Add a small buffer
          
          // Only schedule one timeout to clear the timer and reset wind effect
          setTimeout(() => {
            if (waveTimer) {
              clearInterval(waveTimer);
              // Don't call resetWindEffect here as each flower resets itself
            }
          }, waveTimeout);
        }

        // Reset wind effect (return to normal position)
        function resetWindEffect() {
          if (isDebugMode) {
            windEffectEl.textContent = 'None';
          }

          // Reset all flowers to their original positions
          const flowers = document.querySelectorAll('.flower.visible');
          flowers.forEach(flower => {
            const origLeft = parseFloat(flower.dataset.baseX);
            const origTop = parseFloat(flower.dataset.baseY);
            flower.style.left = `${origLeft}em`;
            flower.style.top = `${origTop}em`;
          });
        }

        // Schedule wind effects with deterministic pattern
        function scheduleWindEffect() {
          // Use a seeded random generator for wind pattern
          // This creates a deterministic sequence that repeats
          const windRandom = createSeededRandom(54321);
          let windCounter = 0;
          let waveInProgress = false;
          
          // Use a longer interval between wind effects to reduce animation frequency
          // Only start a new wave if none is in progress
          const checkInterval = setInterval(() => {
            // Don't start a new wave if one is already in progress
            if (waveInProgress) return;
            
            // Wind directions in a deterministic sequence
            const directions = [
              'left', 'right', 'up', 'down',
              'diagonal-up-right', 'diagonal-up-left',
              'diagonal-down-right', 'diagonal-down-left'
            ];
            
            // Use modulo arithmetic to create a repeating pattern
            // But still with some variety based on the seeded random
            windCounter = (windCounter + 1) % 100;
            const dirIndex = Math.floor(windRandom() * directions.length);
            const direction = directions[dirIndex];
            
            // Mark a wave as in progress
            waveInProgress = true;
            
            // Start a wave
            applyWindEffect(direction, windStrength);
            
            // Calculate an appropriate timeout based on grid size
            // We want to ensure the wave completes fully before allowing a new one
            const maxGridDimension = Math.sqrt(
              Math.pow(config.gridWidth, 2) + 
              Math.pow(config.gridHeight, 2)
            );
            const timeoutDuration = maxGridDimension * window.currentWaveFrameInterval * 1.5;
            
            // After the wave is done, allow new waves
            setTimeout(() => {
              waveInProgress = false;
              resetWindEffect(); // Ensure all flowers are reset
            }, timeoutDuration);
          }, config.windInterval * 3); // Increase interval between winds by 3x
        }

        // Create a static garden as fallback for network issues
        function displayStaticGarden() {
          // Use the currentFlowerCount which is already initialized from localStorage or default
          // No need to set a static count - we're using what we have

          // Add static artwork info
          artworkInfo = [
            {
              title: "World Computer Sculpture Garden",
              authors: ["0xfff"],
              address: "0x0000000000000000000000000000000000000000"
            },
            {
              title: "Echoes",
              authors: ["0xhaiku"],
              address: "0x17a79a4900F3Dd0E0b35D5B0c19Bc2E1189174Dc"
            },
            { title: "Extimacy", authors: ["113"], address: "0xB44018DF3284Daf608a8f6b7F8049F30FE14ec92" },
            { title: "Dear God, Layer of Roads (Travelers)", authors: ["Loucas Braconnier (Figure31)"], address: "0x8170e7DB1AB0930D6afbBB67b7be81Dbd66B7c01" },
            { title: "Yesbot", authors: ["Sarah Friend"], address: "0x6802Ba6353bc5a6338DC7598D5e5eE568e807B16" },
            { title: "Modulation Studies", authors: ["Material Protocol Arts"], address: "0xb78212285CcC039733Ea3453F38e591eD91F1D63" },
            { title: "Critique of This Show", authors: ["Rhea Myers et al."], address: "0x6582Adc209769bb9974e42cA61F4Db802D25997E" },
            { title: "Real Abstraction (A Line Made by Proofs)", authors: ["Paul Seidler"], address: "0x3471D8aCdD789a12Aa5c07E7d32c71d7959688E8" },
          ];

          generateGarden();
          scheduleWindEffect();
          isInitialized = true;
        }

        // Grid noise function from GardenContributions.sol
        function gridNoise(x, y, seed) {
          // Converting the noise algorithm to JavaScript
          let n = (1619 * x + 31337 * y + 1013 * seed) & 0x7fffffff;
          n = ((n >> 13) ^ n);

          // Use BigInt for large number calculations
          let bigN = BigInt(n);
          bigN = bigN * (bigN * BigInt(60493) + BigInt(19990303)) + BigInt(1376312589);

          // Convert to binary and slice the last 31 bits
          const binaryStr = bigN.toString(2);
          const last31Bits = binaryStr.slice(-31);

          // Convert back to decimal and normalize to the range [-1, 1]
          n = parseInt(last31Bits, 2);
          return 1 - n / 1073741824;
        }

        // Calculate threshold based on GardenContributions.sol algorithm
        function calculateThreshold(planted) {
          const min = 30, max = 10000;
          const lower = 0.99, higher = 0.8;

          if (planted <= min) return lower;
          if (planted >= max) return higher;

          const normalized = (planted - min) / (max - min);
          const logValue = Math.log10(1 + normalized * (10 - 1));

          return higher + (lower - higher) * (1 - logValue);
        }

        // Function to make text elements wander around the grid
        function wanderingTextElements() {
          // Get all visible text elements
          const textElements = document.querySelectorAll('.info-text.visible');
          
          // Function to check if a position is occupied by any text element
          // Accounts for the full width of text elements
          function isPositionOccupied(x, y, currentElement) {
            for (const el of textElements) {
              // Skip if this is the element we're checking for
              if (el === currentElement) continue;
              
              // Skip if element doesn't have position data
              if (!el.dataset.currentX || !el.dataset.currentY) continue;
              
              const elX = parseInt(el.dataset.currentX, 10);
              const elY = parseInt(el.dataset.currentY, 10);
              const elLength = el.textContent.length;
              
              // Check if position falls within this element's span
              if (elY === y && x >= elX && x < elX + elLength) {
                return el; // Return the element occupying this position
              }
            }
            return null; // Position is not occupied
          }
          
          // Function to check if a new position would cause collision
          function checkCollision(element, newX, newY) {
            const elementLength = element.textContent.length;
            
            // Check every position the element would occupy
            for (let i = 0; i < elementLength; i++) {
              const collidingElement = isPositionOccupied(newX + i, newY, element);
              if (collidingElement) {
                return collidingElement;
              }
            }
            return null; // No collision
          }
          
          // Process each text element
          textElements.forEach(el => {
            // Skip if element doesn't have position data
            if (!el.dataset.currentX || !el.dataset.currentY) return;
            
            const currentX = parseInt(el.dataset.currentX, 10);
            const currentY = parseInt(el.dataset.currentY, 10);
            
            // Randomly choose a direction to move (-1, 0, or 1 for both x and y)
            const directions = [-1, 0, 1];
            const dx = directions[Math.floor(Math.random() * 3)];
            const dy = directions[Math.floor(Math.random() * 3)];
            
            // Calculate new position
            let newX = currentX + dx;
            let newY = currentY + dy;
            
            // Ensure we stay within grid boundaries
            newX = Math.max(0, Math.min(config.gridWidth - el.textContent.length, newX));
            newY = Math.max(0, Math.min(config.gridHeight - 1, newY));
            
            // Check for collisions at the new position
            const collidingElement = checkCollision(el, newX, newY);
            
            if (collidingElement) {
              // Handle collision - move the colliding element down
              const collidingY = parseInt(collidingElement.dataset.currentY, 10) + 1;
              // Make sure we don't go off the bottom of the screen
              const safeY = Math.min(config.gridHeight - 1, collidingY);
              
              // Update position of colliding element
              collidingElement.style.top = `${safeY * 1.2}em`;
              collidingElement.dataset.currentY = safeY;
            }
            
            // Update element position without transition (immediate jump)
            el.style.left = `${newX * 1.0}em`;
            el.style.top = `${newY * 1.2}em`;
            
            // Update dataset values
            el.dataset.currentX = newX;
            el.dataset.currentY = newY;
          });
        }
        
        // Schedule wandering of text elements based on configuration
        let wanderingTextInterval = null;
        
        function startWanderingText() {
          if (config.wanderingTextEnabled && !wanderingTextInterval) {
            wanderingTextInterval = setInterval(wanderingTextElements, config.wanderingTextInterval);
            console.log('Text wandering started');
          }
        }
        
        function stopWanderingText() {
          if (wanderingTextInterval) {
            clearInterval(wanderingTextInterval);
            wanderingTextInterval = null;
            console.log('Text wandering stopped');
          }
        }
        
        // Toggle wandering text based on config
        function toggleWanderingText() {
          config.wanderingTextEnabled = !config.wanderingTextEnabled;
          
          if (config.wanderingTextEnabled) {
            startWanderingText();
          } else {
            stopWanderingText();
          }
          
          // Update debug panel if it's visible
          const wanderingStateEl = document.getElementById('wandering-state');
          if (wanderingStateEl) {
            wanderingStateEl.textContent = config.wanderingTextEnabled ? 'On' : 'Off';
          }
          
          return config.wanderingTextEnabled;
        }
        
        // Initialize text wandering if enabled in config
        if (config.wanderingTextEnabled) {
          startWanderingText();
        }
        
        // Start the application
        init();
      });
    </script>
  </body>
</html>