<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Cstyle%3E%20text%20%7B%20fill:%20%23000;%20%7D%20@media%20(prefers-color-scheme:%20dark)%20%7B%20text%20%7B%20fill:%20%23fff;%20%7D%20%7D%20%3C/style%3E%3Ctext%20y='.9em'%20font-size='90'%3E%20⚘%20%3C/text%3E%3C/svg%3E%0A"
    />
    <title>World Computer Sculpture Garden</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html {
        -moz-text-size-adjust: none;
        -webkit-text-size-adjust: none;
        text-size-adjust: none;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      body {
        min-height: 100vh;
        background-color: #fff;
      }
      html,
      body,
      pre {
        font-family: "Courier New", "Courier", monospace;
        font-size: 15px;
        line-height: 1.3;
      }
      .garden-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        overflow: hidden;
      }
      .garden-field {
        white-space: pre;
        font-size: 15px;
        line-height: 1.5;
        margin: 0;
        padding: 0;
      }
      .flower {
        display: inline-block;
        transition: opacity 15s ease-in-out;
        opacity: 0;
        position: absolute;
        font-size: 15px;
      }
      .flower.visible {
        opacity: 1;
      }
      .info-text {
        position: absolute;
        opacity: 0;
        font-size: 15px;
        pointer-events: none;
        transition: opacity 4s ease-in-out;
        text-align: left;
        white-space: nowrap;
        background-color: rgba(255, 255, 255, 0.9); /* White background with slight transparency */
        padding: 0 4px; /* Horizontal padding for better readability */
        border-radius: 2px; /* Slightly rounded corners */
        box-shadow: 0 0 5px rgba(255, 255, 255, 0.8); /* White glow effect */
        z-index: 10; /* Ensure text appears above flowers */
      }
      .info-text.visible {
        opacity: 1;
      }
      .debug-panel {
        position: fixed;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.8);
        border: 1px solid #ccc;
        padding: 10px;
        font-size: 12px;
        display: none;
        z-index: 100;
      }
      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #fafafa;
        z-index: 1000;
      }
      .loading-text {
        font-size: 15px;
      }
    </style>
  </head>
  <body>
    <div class="loading"></div>
    <div class="garden-container">
      <div class="garden-field" id="garden-field"></div>
    </div>
    <div class="debug-panel" id="debug-panel">
      <div>Flowers: <span id="flower-count">0</span></div>
      <div>Block: <span id="current-block">-</span></div>
      <div>Wind Effect: <span id="wind-effect">None</span></div>
    </div>

    <script src="https://cdn.ethers.io/lib/ethers-5.7.2.umd.min.js" type="application/javascript"></script>
    <script>
      document.addEventListener('DOMContentLoaded', async () => {
        // Constants
        const GARDEN_CONTRACT_ADDRESS = '0x2a362fF002f7ce62D3468509dD2A4a9f5A8EBBb0';
        const GARDEN_ABI = [
          "function flowers() view returns (uint256)",
          "function authors() view returns (string[] memory)",
          "function sculptures() view returns (address[] memory)"
        ];
        const SCULPTURE_ABI = [
          "function title() view returns (string memory)",
          "function authors() view returns (string[] memory)"
        ];

        // Contract interaction setup
        let provider, gardenContract, sculptureContracts = [];
        let isDebugMode = location.search.includes('debug=true');
        let artworkInfo = [];
        // Try to get stored flower count, default to 283 if not available
        let currentFlowerCount = parseInt(localStorage.getItem('flowerCount') || '283', 10);
        let displayedFlowers = 0;
        let isInitialized = false;

        // Elements
        const gardenField = document.getElementById('garden-field');
        const debugPanel = document.getElementById('debug-panel');
        const flowerCountEl = document.getElementById('flower-count');
        const currentBlockEl = document.getElementById('current-block');
        const windEffectEl = document.getElementById('wind-effect');
        const loadingEl = document.querySelector('.loading');

        // Show debug panel if needed
        if (isDebugMode) {
          debugPanel.style.display = 'block';
          flowerCountEl.textContent = currentFlowerCount;
        }

        // Grid and visualization settings
        const config = {
          // Dynamically calculate grid size based on window dimensions
          // Default values that will be adjusted in the init function
          gridWidth: 120,         // Characters per line
          gridHeight: 40,         // Number of lines
          infoTextDensity: 10,    // Lower means more info texts
          windStrength: 1.0,      // Wind effect strength (1 unit = 1 cell)
          windInterval: 5000,     // Ms between checking for new wind waves
          windDuration: 3000,     // Ms each wind wave lasts
          flowerFadeInTime: 15000 // Ms for new flowers to fade in
        };

        // Calculate optimal grid size based on screen dimensions
        function calculateGridSize() {
          // Get window dimensions
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;

          // Calculate how many characters can fit
          // Assuming each character is roughly 1em wide and 1.2em tall
          const fontSizeInPx = 15;
          const charWidth = fontSizeInPx;
          const charHeight = fontSizeInPx * 1.2;

          // Calculate grid dimensions matching exactly to window size
          // Use ceiling to ensure we fill the space completely
          config.gridWidth = Math.ceil(windowWidth / charWidth) - 1;
          config.gridHeight = Math.ceil(windowHeight / charHeight) - 1;

          console.log(`Grid size set to ${config.gridWidth} x ${config.gridHeight} based on screen size`);
        }

        // Initialize application
        async function init() {
          try {
            // Calculate grid size based on screen dimensions
            calculateGridSize();

            // Handle window resize
            window.addEventListener('resize', () => {
              calculateGridSize();
              // Regenerate garden on resize with a debounce
              clearTimeout(window.resizeTimer);
              window.resizeTimer = setTimeout(() => {
                generateGarden();
              }, 500);
            });

            // Connect to Ethereum
            provider = new ethers.providers.JsonRpcProvider("https://eth-mainnet.g.alchemy.com/v2/JFKk0rH8qT8yvFnJhbY0MwAX43-YrWAv");
            gardenContract = new ethers.Contract(GARDEN_CONTRACT_ADDRESS, GARDEN_ABI, provider);

            // Get flower count and artwork information
            await fetchFlowerCount();
            await fetchArtworkInfo();

            // Generate the initial garden
            generateGarden();

            // Setup block listeners for updates
            provider.on('block', onNewBlock);

            // Start wind effects
            scheduleWindEffect();

            // Hide loading screen
            loadingEl.style.display = 'none';
            isInitialized = true;

            console.log('Garden visualization initialized');
          } catch (error) {
            console.error('Initialization error:', error);

            // Show static fallback garden without announcing the error
            setTimeout(() => {
              displayStaticGarden();
              loadingEl.style.display = 'none';
            }, 1000);
          }
        }

        // Fetch the current flower count from the contract
        async function fetchFlowerCount() {
          try {
            const count = await gardenContract.flowers();
            currentFlowerCount = parseInt(count.toString(), 10);

            // Store the flower count in localStorage for future sessions
            localStorage.setItem('flowerCount', currentFlowerCount.toString());

            if (isDebugMode) {
              flowerCountEl.textContent = currentFlowerCount;
            }
            return currentFlowerCount;
          } catch (error) {
            console.error('Error fetching flower count:', error);
            return currentFlowerCount; // Return current count (from localStorage or default)
          }
        }

        // Fetch information about the artworks
        async function fetchArtworkInfo() {
          try {
            // Get sculpture addresses
            const sculptureAddresses = await gardenContract.sculptures();

            // For each sculpture, create a contract instance and get info
            for (const address of sculptureAddresses) {
              const sculptureContract = new ethers.Contract(address, SCULPTURE_ABI, provider);
              sculptureContracts.push(sculptureContract);

              try {
                const title = await sculptureContract.title();
                const authors = await sculptureContract.authors();

                artworkInfo.push({
                  title,
                  authors,
                  address
                });
              } catch (err) {
                console.warn(`Failed to get info for sculpture at ${address}:`, err);
              }
            }

            console.log('Artwork info:', artworkInfo);
          } catch (error) {
            console.error('Error fetching artwork info:', error);
          }
        }

        // Generate the garden visualization
        function generateGarden() {
          gardenField.innerHTML = '';
          const grid = createEmptyGrid(config.gridWidth, config.gridHeight);

          // Place flowers based on noise algorithm
          const flowersToDisplay = Math.min(currentFlowerCount, 10000); // Limit for performance
          const flowerPositions = placeFlowersUsingNoise(grid, flowersToDisplay);

          // Create flower elements
          flowerPositions.forEach((pos, i) => {
            const flowerEl = createFlowerElement(pos.x, pos.y);
            gardenField.appendChild(flowerEl);

            // Make initial flowers visible immediately
            flowerEl.classList.add('visible');
          });

          // Place artwork info text
          if (artworkInfo.length > 0) {
            placeInfoText();
          }

          displayedFlowers = flowersToDisplay;
        }

        // Create an empty grid
        function createEmptyGrid(width, height) {
          const grid = [];
          for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
              row.push(' ');
            }
            grid.push(row);
          }
          return grid;
        }

        // Create a seeded pseudo-random number generator
        function createSeededRandom(seed) {
          return function() {
            seed = (seed * 16807) % 2147483647;
            return (seed - 1) / 2147483646;
          };
        }
        
        // Place flowers using deterministic noise algorithm (based on GardenContributions.sol)
        function placeFlowersUsingNoise(grid, count) {
          // Use a fixed seed for deterministic placement
          // This will ensure we get the same pattern every time
          const fixedSeed = 12345; // Fixed seed for consistent patterns
          const random = createSeededRandom(fixedSeed);
          
          const positions = [];
          let placed = 0;
          let attempts = 0;
          
          // Ensure even distribution - divide screen into sections and ensure flowers in each
          const numSections = 4; // Divide screen into quarters
          const sectionHeight = config.gridHeight / numSections;
          const flowersPerSection = Math.ceil(count / numSections);
          
          // Track how many flowers we've placed in each section
          const sectionCounts = new Array(numSections).fill(0);
          
          // Try to place all flowers with better distribution
          while (placed < count && attempts < count * 20) {
            attempts++;

            // Choose a section that needs more flowers
            // Focus on underfilled sections, especially the bottom ones
            let sectionIndex;
            if (attempts < count * 10) {
              // During first half of attempts, prioritize empty sections
              // Give bottom sections higher priority
              const weights = sectionCounts.map((count, index) => {
                // More weight to sections with fewer flowers and sections near the bottom
                return (flowersPerSection - count) * (index + 1);
              });
              
              const totalWeight = weights.reduce((sum, weight) => sum + Math.max(0, weight), 0);
              let randomValue = random() * totalWeight;
              
              for (sectionIndex = 0; sectionIndex < numSections; sectionIndex++) {
                if (weights[sectionIndex] <= 0) continue;
                randomValue -= weights[sectionIndex];
                if (randomValue <= 0) break;
              }
              if (sectionIndex >= numSections) {
                sectionIndex = numSections - 1; // Default to bottom section
              }
            } else {
              // For later attempts, just place anywhere
              sectionIndex = Math.floor(random() * numSections);
            }
            
            // Get position within that section
            const sectionStartY = Math.floor(sectionIndex * sectionHeight);
            const sectionEndY = Math.floor(Math.min(config.gridHeight, (sectionIndex + 1) * sectionHeight));
            
            const x = Math.floor(random() * config.gridWidth);
            const y = sectionStartY + Math.floor(random() * (sectionEndY - sectionStartY));

            // For this grid cell, calculate a noise value
            const noiseVal = gridNoise(x, y, 0xf);

            // We'll make the threshold more lenient as we place more flowers
            // This ensures we get a nice pattern but still place enough flowers
            const baseThreshold = 0.7; // Lower threshold = more flowers
            const threshold = Math.max(0.3, baseThreshold - (placed / count) * 0.5);

            if (Math.abs(noiseVal) > threshold && grid[y][x] === ' ') {
              // Place flower in grid
              grid[y][x] = '⚘';
              positions.push({ x, y });
              placed++;
              sectionCounts[sectionIndex]++;
            }
          }

          return positions;
        }

        // Create a flower element at specific coordinates
        function createFlowerElement(x, y) {
          const flower = document.createElement('div');
          flower.className = 'flower';
          flower.textContent = '⚘';
          flower.style.left = `${x * 1.0}em`;
          flower.style.top = `${y * 1.2}em`;
          flower.dataset.x = x;
          flower.dataset.y = y;
          flower.dataset.baseX = x * 1.0;
          flower.dataset.baseY = y * 1.2;

          return flower;
        }

        // Place text elements with artwork information
        function placeInfoText() {
          // Use same seeded random generator for consistent text placement
          const random = createSeededRandom(789012); // Different seed from flower placement
          
          // Create an array of grid positions that match where flowers could be placed
          // We'll place text at these grid positions to ensure alignment
          const gridPositions = [];
          
          // Generate grid positions (essentially the same as the flower placement logic)
          for (let y = 0; y < config.gridHeight; y++) {
            for (let x = 0; x < config.gridWidth; x++) {
              gridPositions.push({ x, y });
            }
          }
          
          // Shuffle the positions using our deterministic random
          for (let i = gridPositions.length - 1; i > 0; i--) {
            const j = Math.floor(random() * (i + 1));
            [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];
          }
          
          // Keep track of used positions to avoid overlap
          const usedPositions = new Set();
          
          // Function to find an available position for text
          function findAvailablePosition(length, startIdx) {
            // Find a position that has enough space for the text
            for (let i = startIdx; i < gridPositions.length; i++) {
              const pos = gridPositions[i];
              
              // Check if this position and needed length is available
              let available = true;
              for (let j = 0; j < length; j++) {
                const checkPos = `${pos.x + j},${pos.y}`;
                if (usedPositions.has(checkPos) || (pos.x + j) >= config.gridWidth) {
                  available = false;
                  break;
                }
              }
              
              // If we found an available spot, mark it as used
              if (available) {
                for (let j = 0; j < length; j++) {
                  usedPositions.add(`${pos.x + j},${pos.y}`);
                }
                return pos;
              }
            }
            
            // If no position is found, return a fallback
            return { x: 5, y: 5 + artworkInfo.indexOf(artwork) * 2 };
          }
          
          // Start index for art placements
          let posIndex = 100; // Skip some of the first positions to make room for flowers
          
          artworkInfo.forEach((artwork, index) => {
            // Place title in grid
            const titleLength = artwork.title.length;
            const titlePos = findAvailablePosition(titleLength, posIndex);
            posIndex += 50; // Move forward to space out the artworks
            
            const titleEl = document.createElement('div');
            titleEl.className = 'info-text';
            titleEl.textContent = artwork.title;
            titleEl.style.left = `${titlePos.x * 1.0}em`;
            titleEl.style.top = `${titlePos.y * 1.2}em`;
            
            gardenField.appendChild(titleEl);
            
            // Place authors in grid, below the title
            artwork.authors.forEach((author, authorIndex) => {
              const authorLength = author.length;
              // Position below the title
              const authorPos = findAvailablePosition(
                authorLength, 
                posIndex + authorIndex * 20
              );
              
              const authorEl = document.createElement('div');
              authorEl.className = 'info-text';
              authorEl.textContent = author;
              authorEl.style.left = `${authorPos.x * 1.0}em`;
              authorEl.style.top = `${authorPos.y * 1.2}em`;
              
              gardenField.appendChild(authorEl);
            });

            // Make text elements visible immediately
            titleEl.classList.add('visible');

            artwork.authors.forEach((_, i) => {
              const authorEl = gardenField.querySelectorAll('.info-text')[index * (artwork.authors.length + 1) + i + 1];
              authorEl.classList.add('visible');
            });
          });
        }

        // Update garden when new flowers are detected
        async function updateGarden(newFlowerCount) {
          if (newFlowerCount <= displayedFlowers) return;

          const additionalFlowers = newFlowerCount - displayedFlowers;
          const grid = createEmptyGrid(config.gridWidth, config.gridHeight);

          // Mark existing flowers in grid
          const existingFlowers = document.querySelectorAll('.flower.visible');
          existingFlowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            if (x >= 0 && y >= 0 && y < grid.length && x < grid[y].length) {
              grid[y][x] = '⚘';
            }
          });

          // Add new flowers
          const newPositions = placeFlowersUsingNoise(grid, additionalFlowers);

          // Create and add new flower elements
          newPositions.forEach(pos => {
            const flowerEl = createFlowerElement(pos.x, pos.y);
            gardenField.appendChild(flowerEl);

            // Fade in the new flower
            setTimeout(() => {
              flowerEl.classList.add('visible');
            }, Math.random() * 1000);
          });

          displayedFlowers = newFlowerCount;

          // Update debug info
          if (isDebugMode) {
            flowerCountEl.textContent = newFlowerCount;
          }
        }

        // Handle new blocks from the blockchain
        async function onNewBlock(blockNumber) {
          if (!isInitialized) return;

          if (isDebugMode) {
            currentBlockEl.textContent = blockNumber;
          }

          // Fetch updated flower count
          const newFlowerCount = await fetchFlowerCount();

          // Add new flowers if needed
          if (newFlowerCount > currentFlowerCount) {
            console.log(`New flowers detected: ${newFlowerCount - currentFlowerCount}`);
            currentFlowerCount = newFlowerCount;
            updateGarden(newFlowerCount);
          }
        }

        // Apply wave-like ripple effect across the garden
        function applyWindEffect(direction, strength) {
          if (isDebugMode) {
            windEffectEl.textContent = direction;
          }
          
          // Get all visible flowers and organize them by position
          const flowers = Array.from(document.querySelectorAll('.flower.visible'));
          const flowerMap = {};
          
          // Create a map of flowers by their position for quick lookup
          flowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            flowerMap[`${x},${y}`] = flower;
          });
          
          // Get grid boundaries
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          flowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          });
          
          // Direction vectors for the flower movement
          let dx = 0, dy = 0;
          switch (direction) {
            case 'left': dx = -1; break;
            case 'right': dx = 1; break;
            case 'up': dy = -1; break;
            case 'down': dy = 1; break;
            case 'diagonal-up-right': dx = 1; dy = -1; break;
            case 'diagonal-up-left': dx = -1; dy = -1; break;
            case 'diagonal-down-right': dx = 1; dy = 1; break;
            case 'diagonal-down-left': dx = -1; dy = 1; break;
          }
          
          // Determine wave direction (perpendicular to wind)
          const waveHorizontal = (dy !== 0);
          
          // Wave animation parameters
          const waveWidth = 4; // How many cells wide the wave is
          const waveFrameInterval = 100; // ms between wave animation frames
          const waveDistance = Math.max(maxX - minX, maxY - minY) + waveWidth * 2; // How far the wave travels
          
          // Animate the wave passing through the garden
          let waveProgress = 0;
          const waveTimer = setInterval(() => {
            // Increment wave position
            waveProgress++;
            
            if (waveProgress > waveDistance) {
              clearInterval(waveTimer);
              return;
            }
            
            // Calculate which flowers are affected by the current wave position
            if (waveHorizontal) {
              // Wave moves horizontally (left to right)
              for (let y = minY; y <= maxY; y++) {
                for (let x = minX; x <= maxX; x++) {
                  // Check if this position is within the current wave front
                  if (Math.abs(x - (minX + waveProgress)) <= waveWidth) {
                    const flower = flowerMap[`${x},${y}`];
                    if (flower) {
                      // Move the flower by adjusting its position
                      const origLeft = parseFloat(flower.dataset.baseX);
                      const origTop = parseFloat(flower.dataset.baseY);
                      flower.style.left = `${origLeft + dx}em`;
                      flower.style.top = `${origTop + dy}em`;
                      
                      // Reset flower position after a brief time
                      setTimeout(() => {
                        flower.style.left = `${origLeft}em`;
                        flower.style.top = `${origTop}em`;
                      }, waveWidth * waveFrameInterval);
                    }
                  }
                }
              }
            } else {
              // Wave moves vertically (top to bottom)
              for (let x = minX; x <= maxX; x++) {
                for (let y = minY; y <= maxY; y++) {
                  // Check if this position is within the current wave front 
                  if (Math.abs(y - (minY + waveProgress)) <= waveWidth) {
                    const flower = flowerMap[`${x},${y}`];
                    if (flower) {
                      // Move the flower by adjusting its position
                      const origLeft = parseFloat(flower.dataset.baseX);
                      const origTop = parseFloat(flower.dataset.baseY);
                      flower.style.left = `${origLeft + dx}em`;
                      flower.style.top = `${origTop + dy}em`;
                      
                      // Reset flower position after a brief time
                      setTimeout(() => {
                        flower.style.left = `${origLeft}em`;
                        flower.style.top = `${origTop}em`;
                      }, waveWidth * waveFrameInterval);
                    }
                  }
                }
              }
            }
          }, waveFrameInterval);
          
          // Stop the wave after the total wind duration
          setTimeout(() => {
            clearInterval(waveTimer);
            resetWindEffect();
          }, config.windDuration);
        }

        // Reset wind effect (return to normal position)
        function resetWindEffect() {
          if (isDebugMode) {
            windEffectEl.textContent = 'None';
          }

          // Reset all flowers to their original positions
          const flowers = document.querySelectorAll('.flower.visible');
          flowers.forEach(flower => {
            const origLeft = parseFloat(flower.dataset.baseX);
            const origTop = parseFloat(flower.dataset.baseY);
            flower.style.left = `${origLeft}em`;
            flower.style.top = `${origTop}em`;
          });
        }

        // Schedule wind effects with deterministic pattern
        function scheduleWindEffect() {
          // Use a seeded random generator for wind pattern
          // This creates a deterministic sequence that repeats
          const windRandom = createSeededRandom(54321);
          let windCounter = 0;
          let waveInProgress = false;
          
          // Use a shorter interval for wind effects, but only start a new wave if none is in progress
          const checkInterval = setInterval(() => {
            if (waveInProgress) return;
            
            // Wind directions in a deterministic sequence
            const directions = [
              'left', 'right', 'up', 'down',
              'diagonal-up-right', 'diagonal-up-left',
              'diagonal-down-right', 'diagonal-down-left'
            ];
            
            // Use modulo arithmetic to create a repeating pattern
            // But still with some variety based on the seeded random
            windCounter = (windCounter + 1) % 100;
            const dirIndex = Math.floor(windRandom() * directions.length);
            const direction = directions[dirIndex];
            
            // Deterministic but varied strength (use smaller values for the wave effect)
            const strength = (0.3 + (0.5 * windRandom())) * config.windStrength;
            
            // Mark a wave as in progress
            waveInProgress = true;
            
            // Start a wave
            applyWindEffect(direction, strength);
            
            // After the wave is done, allow new waves
            setTimeout(() => {
              waveInProgress = false;
            }, config.windDuration + 500); // Add a small buffer

            // Reset after wind duration
            setTimeout(() => {
              resetWindEffect();
            }, config.windDuration);
          }, config.windInterval);
        }

        // Create a static garden as fallback for network issues
        function displayStaticGarden() {
          // Use the currentFlowerCount which is already initialized from localStorage or default
          // No need to set a static count - we're using what we have

          // Add static artwork info
          artworkInfo = [
            {
              title: "World Computer Sculpture Garden",
              authors: ["0xfff"],
              address: "0x0000000000000000000000000000000000000000"
            },
            {
              title: "Echoes",
              authors: ["0xhaiku"],
              address: "0x17a79a4900F3Dd0E0b35D5B0c19Bc2E1189174Dc"
            },
            { title: "Extimacy", authors: ["113"], address: "0xB44018DF3284Daf608a8f6b7F8049F30FE14ec92" },
            { title: "Dear God, Layer of Roads (Travelers)", authors: ["Loucas Braconnier (Figure31)"], address: "0x8170e7DB1AB0930D6afbBB67b7be81Dbd66B7c01" },
            { title: "Yesbot", authors: ["Sarah Friend"], address: "0x6802Ba6353bc5a6338DC7598D5e5eE568e807B16" },
            { title: "Modulation Studies", authors: ["Material Protocol Arts"], address: "0xb78212285CcC039733Ea3453F38e591eD91F1D63" },
            { title: "Critique of This Show", authors: ["Rhea Myers et al."], address: "0x6582Adc209769bb9974e42cA61F4Db802D25997E" },
            { title: "Real Abstraction (A Line Made by Proofs)", authors: ["Paul Seidler"], address: "0x3471D8aCdD789a12Aa5c07E7d32c71d7959688E8" },
          ];

          generateGarden();
          scheduleWindEffect();
          isInitialized = true;
        }

        // Grid noise function from GardenContributions.sol
        function gridNoise(x, y, seed) {
          // Converting the noise algorithm to JavaScript
          let n = (1619 * x + 31337 * y + 1013 * seed) & 0x7fffffff;
          n = ((n >> 13) ^ n);

          // Use BigInt for large number calculations
          let bigN = BigInt(n);
          bigN = bigN * (bigN * BigInt(60493) + BigInt(19990303)) + BigInt(1376312589);

          // Convert to binary and slice the last 31 bits
          const binaryStr = bigN.toString(2);
          const last31Bits = binaryStr.slice(-31);

          // Convert back to decimal and normalize to the range [-1, 1]
          n = parseInt(last31Bits, 2);
          return 1 - n / 1073741824;
        }

        // Calculate threshold based on GardenContributions.sol algorithm
        function calculateThreshold(planted) {
          const min = 30, max = 10000;
          const lower = 0.99, higher = 0.8;

          if (planted <= min) return lower;
          if (planted >= max) return higher;

          const normalized = (planted - min) / (max - min);
          const logValue = Math.log10(1 + normalized * (10 - 1));

          return higher + (lower - higher) * (1 - logValue);
        }

        // Start the application
        init();
      });
    </script>
  </body>
</html>