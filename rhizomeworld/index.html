<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="icon"
      type="image/svg+xml"
      href="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20100%20100'%3E%3Cstyle%3E%20text%20%7B%20fill:%20%23000;%20%7D%20@media%20(prefers-color-scheme:%20dark)%20%7B%20text%20%7B%20fill:%20%23fff;%20%7D%20%7D%20%3C/style%3E%3Ctext%20y='.9em'%20font-size='90'%3E%20⚘%20%3C/text%3E%3C/svg%3E%0A"
    />
    <title>World Computer Sculpture Garden</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      html {
        -moz-text-size-adjust: none;
        -webkit-text-size-adjust: none;
        text-size-adjust: none;
      }
      html,
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
      }
      body {
        min-height: 100vh;
        background-color: #fff;
      }
      html,
      body,
      pre {
        font-family: "Courier New", "Courier", monospace;
        font-size: 15px;
        line-height: 1.3;
      }
      .garden-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: flex-start;
        align-items: flex-start;
        overflow: hidden;
      }
      .garden-field {
        white-space: pre;
        font-size: 15px;
        line-height: 1.5;
        margin: 0;
        padding: 0;
      }
      .flower {
        display: inline-block;
        /* transition: opacity 1s ease-in-out; */
        opacity: 0;
        position: absolute;
        font-size: 15px;
        /* Prevent flickering during animation */
        transform: translateZ(0); /* Force GPU acceleration */
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        /* Prevent text selection during animation */
        user-select: none;
      }
      .flower.visible {
        opacity: 1;
      }
      /* Add a special class for animating flowers */
      .flower[data-animating="true"] {
        /* Higher z-index during animation to prevent overlapping issues */
        z-index: 5;
      }
      .info-text {
        position: absolute;
        opacity: 0;
        font-size: 15px;
        pointer-events: none;
        transition: opacity 4s ease-in-out;
        text-align: left;
        white-space: nowrap;
        background-color: #fff; /* White background with slight transparency */
        padding: 0 4px; /* Horizontal padding for better readability */
        line-height: 1.2;
        box-sizing: border-box;
        z-index: 10; /* Ensure text appears above flowers */
        display: flex;
        flex-direction: column;
      }
      .info-text.visible {
        opacity: 1;
      }
      .artwork-title {
        font-style: italic;
      }
      .artwork-author {
        /* margin-bottom: 2px; */
      }
      .debug-panel {
        position: fixed;
        top: 10px;
        right: 10px;
        background: #fff;
        border: 1px solid #000;
        padding: 10px;
        font-size: 12px;
        display: none;
        z-index: 100;
      }
      .loading {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #fff;
        z-index: 1000;
      }
      .loading-text {
        font-size: 15px;
      }

      .wind-marker {
        position: absolute;
        font-size: 15px;
        pointer-events: none;
        text-align: center;
        font-family: monospace !important; /* this fixes the arrows */
        width: 1em;
        z-index: 10;
        display: none; /* Hide the wind marker for now */
      }
    </style>
  </head>
  <body>
    <div class="loading"></div>
    <div class="garden-container">
      <div class="garden-field" id="garden-field"></div>
    </div>
    <div class="debug-panel" id="debug-panel">
      <div>Flowers: <span id="flower-count">0</span></div>
      <div>Block: <span id="current-block">-</span></div>
      <div>Wind Effect: <span id="wind-effect">None</span></div>
      <div>Wandering Text: <span id="wandering-state">On</span></div>
    </div>

    <!-- Load viem library -->
    <script type="module">
      import * as viem from 'https://cdn.jsdelivr.net/npm/viem@2.28.1/+esm'
      import { mainnet } from 'https://cdn.jsdelivr.net/npm/viem@2.28.1/chains/+esm'

      // Make viem and chains available globally
      window.viem = viem;
      window.viemChains = { mainnet };
    </script>
    <script>
      // Wait for both DOM and viem to be ready before initializing
      function checkDependencies() {
        if (typeof window.viem === 'undefined' || typeof window.viemChains === 'undefined') {
          // viem or chains haven't loaded yet, wait a bit longer
          setTimeout(checkDependencies, 100);
          return;
        }

        // Initialize once everything is ready
        initializeGarden();
      }

      // Start the dependency check when DOM is ready
      document.addEventListener('DOMContentLoaded', checkDependencies);

      async function initializeGarden() {
        // Constants
        const GARDEN_CONTRACT_ADDRESS = '0x2a362fF002f7ce62D3468509dD2A4a9f5A8EBBb0';
        // Define ABI using viem's format
        const GARDEN_ABI = [
          {
            name: 'flowers',
            type: 'function',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'uint256' }]
          },
          {
            name: 'authors',
            type: 'function',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'string[]' }]
          },
          {
            name: 'sculptures',
            type: 'function',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'address[]' }]
          }
        ];
        const SCULPTURE_ABI = [
          {
            name: 'title',
            type: 'function',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'string' }]
          },
          {
            name: 'authors',
            type: 'function',
            stateMutability: 'view',
            inputs: [],
            outputs: [{ type: 'string[]' }]
          }
        ];

        // Contract interaction setup using viem
        let publicClient;
        let isDebugMode = location.search.includes('debug=true');
        let artworkInfo = [
            {
              title: "World Computer Sculpture Garden",
              authors: ["0xfff"]
            },
            {
              title: "Echoes",
              authors: ["0xhaiku"],
              address: "0x17a79a4900F3Dd0E0b35D5B0c19Bc2E1189174Dc",
              updateEveryBlock: 7200 // once a day
            },
            {
              title: "Extimacy",
              authors: ["113"],
              address: "0xB44018DF3284Daf608a8f6b7F8049F30FE14ec92",
              updateEveryBlock: 1
            },
            {
              title: "Dear God, Layer of Roads (Travelers)",
              authors: ["Loucas Braconnier (Figure31)"],
              address: "0x8170e7DB1AB0930D6afbBB67b7be81Dbd66B7c01",
              updateEveryBlock: 0 // never
            },
            {
              title: "Yesbot",
              authors: ["Sarah Friend"],
              address: "0x6802Ba6353bc5a6338DC7598D5e5eE568e807B16",
              updateEveryBlock: 0 // never
            },
            {
              title: "Modulation Studies",
              authors: ["Material Protocol Arts"],
              address: "0xb78212285CcC039733Ea3453F38e591eD91F1D63",
              updateEveryBlock: 0 // never
            },
            {
              title: "Critique of This Show",
              authors: ["Rhea Myers et al."],
              address: "0x6582Adc209769bb9974e42cA61F4Db802D25997E",
              updateEveryBlock: 0 // never
            },
            {
              title: "Real Abstraction (A Line Made by Proofs)",
              authors: ["Paul Seidler"],
              address: "0x3471D8aCdD789a12Aa5c07E7d32c71d7959688E8",
              updateEveryBlock: 0 // never
            },
          ];
;
        // Try to get stored flower count, default to 283 if not available
        let currentFlowerCount = parseInt(localStorage.getItem('flowerCount') || '283', 10);
        let displayedFlowers = 0;
        let isInitialized = false;

        // Elements
        const gardenField = document.getElementById('garden-field');
        const debugPanel = document.getElementById('debug-panel');
        const flowerCountEl = document.getElementById('flower-count');
        const currentBlockEl = document.getElementById('current-block');
        const windEffectEl = document.getElementById('wind-effect');
        const loadingEl = document.querySelector('.loading');

        // Wind marker is disabled for now
        // const windMarker = document.createElement('div');
        // windMarker.className = 'wind-marker';
        // windMarker.id = 'wind-marker';
        // windMarker.textContent = '↑'; // Default direction
        // gardenField.appendChild(windMarker);

        // Show debug panel if needed
        if (isDebugMode) {
          debugPanel.style.display = 'block';
          flowerCountEl.textContent = currentFlowerCount;
        }

        // Grid and visualization settings
        const config = {
          // Dynamically calculate grid size based on window dimensions
          // Default values that will be adjusted in the init function
          gridWidth: 120,         // Characters per line
          gridHeight: 40,         // Number of lines
          infoTextDensity: 10,    // Lower means more info texts
          windStrength: 0.25,      // Wind effect strength (1 unit = 1 cell)
          windInterval: 1000,     // Ms between checking for new wind waves
          windSpeed: 33, // ms
          flowerFadeInTime: 15000, // Ms for new flowers to fade in
          wanderingTextEnabled: true, // Enable/disable wandering text feature
          wanderingTextInterval: 12000 // Ms between text movements
        };

        // Calculate optimal grid size based on screen dimensions
        function calculateGridSize() {
          // Get window dimensions
          const windowWidth = window.innerWidth;
          const windowHeight = window.innerHeight;

          // Calculate how many characters can fit
          // Assuming each character is roughly 1em wide and 1.2em tall
          const fontSizeInPx = 15;
          const charWidth = fontSizeInPx;
          const charHeight = fontSizeInPx * 1.2;

          // Calculate grid dimensions matching exactly to window size
          // Use ceiling to ensure we fill the space completely
          config.gridWidth = Math.ceil(windowWidth / charWidth) - 1;
          config.gridHeight = Math.ceil(windowHeight / charHeight) - 1;

          console.log(`Grid size set to ${config.gridWidth} x ${config.gridHeight} based on screen size`);
        }

        // Initialize application
        async function init() {
          try {
            // Calculate grid size based on screen dimensions
            calculateGridSize();

            // Handle window resize
            window.addEventListener('resize', () => {
              calculateGridSize();
              // Regenerate garden on resize with a debounce
              clearTimeout(window.resizeTimer);
              window.resizeTimer = setTimeout(() => {
                generateGarden();
              }, 500);
            });

            // Add keyboard shortcuts
            document.addEventListener('keydown', (event) => {
              // 't' to toggle wandering text
              if (event.key === 't') {
                const isEnabled = toggleWanderingText();
                console.log(`Wandering text ${isEnabled ? 'enabled' : 'disabled'}`);
              }

              // 'f' to add a flower
              if (event.key === 'f') {
                // Add 1 flower
                addNewFlowers(1);
              }

              // 'w' to trigger a wind effect in random direction
              if (event.key === 'w') {
                const directions = [
                  'left', 'right', 'up', 'down',
                  'diagonal-up-right', 'diagonal-up-left',
                  'diagonal-down-right', 'diagonal-down-left'
                ];

                // Choose a random direction
                const direction = directions[Math.floor(Math.random() * directions.length)];
                console.log(`Manually triggering wind effect: ${direction}`);

                // Trigger wind with normal strength
                applyWindEffect(direction, config.windStrength);
              }

              // Number keys 1-8 to trigger specific wind directions
              if (event.key >= '1' && event.key <= '8') {
                const directions = [
                  'left', 'right', 'up', 'down',
                  'diagonal-up-right', 'diagonal-up-left',
                  'diagonal-down-right', 'diagonal-down-left'
                ];

                // Use key number (1-8) to pick direction (index 0-7)
                const index = parseInt(event.key) - 1;
                const direction = directions[index];

                console.log(`Manually triggering wind effect: ${direction}`);
                applyWindEffect(direction, config.windStrength);
              }
            });

            // Connect to Ethereum using viem and public RPC endpoints
            try {
              console.log("Connecting to Ethereum using viem...");

              // Create a client with fallback transport - combines multiple public endpoints
              publicClient = viem.createPublicClient({
                chain: window.viemChains.mainnet,
                transport: viem.fallback([
                  // Try multiple public endpoints for redundancy
                  viem.http('https://eth.llamarpc.com'),
                  viem.http('https://cloudflare-eth.com'),
                  viem.http('https://ethereum.publicnode.com'),
                  viem.http('https://mainnet.infura.io/v3/cd625a10fd7343a987a4463b1bc0873a'),
                ])
              });

              // Test the connection by getting a block number
              const blockNumber = await publicClient.getBlockNumber();
              console.log(`Connected to Ethereum at block ${blockNumber}`);
            } catch (error) {
              console.error("Failed to connect to Ethereum:", error);
              throw new Error("Unable to connect to any Ethereum RPC endpoint");
            }

            // Get flower count
            await fetchFlowerCount();

            // For initial load, do a custom fetch of artwork info to initialize
            // without using the regular update mechanism
            try {
              const initialBlock = await publicClient.getBlockNumber();
              console.log(`Performing initial artwork fetch at block ${Number(initialBlock)}`);

              // Only create contract instances for sculptures with updateEveryBlock > 0
              const dynamicSculptures = artworkInfo.filter(s => s.address && s.updateEveryBlock > 0);

              // Skip everything if there are no dynamic sculptures
              if (dynamicSculptures.length === 0) {
                console.log('No dynamic sculptures to initialize');
              } else {
                console.log(`Initializing ${dynamicSculptures.length} dynamic sculptures`);

                // With viem, we don't need to create contract instances
                // Just initialize the block counter for dynamic sculptures
                for (const sculpture of dynamicSculptures) {
                  // Record this as the last update block to start the counter
                  lastUpdatedBlocks[sculpture.address] = Number(initialBlock);

                  // Fetch initial data using viem
                  try {
                    // Using multicall to batch requests
                    const [title, authors] = await publicClient.multicall({
                      contracts: [
                        {
                          address: sculpture.address,
                          abi: SCULPTURE_ABI,
                          functionName: 'title',
                        },
                        {
                          address: sculpture.address,
                          abi: SCULPTURE_ABI,
                          functionName: 'authors',
                        }
                      ]
                    });

                    // Process the results
                    if (title.status === 'success' && authors.status === 'success') {
                      const titleValue = title.result;
                      const authorsValue = authors.result;

                      // Update data if different
                      if (sculpture.title !== titleValue || !arraysEqual(sculpture.authors, authorsValue)) {
                        sculpture.title = titleValue;
                        sculpture.authors = authorsValue;
                        console.log(`Initial data fetch for "${titleValue}" by ${authorsValue.join(', ')}`);
                      }
                    } else {
                      throw new Error('Failed to fetch initial data');
                    }
                  } catch (err) {
                    console.warn(`Initial fetch failed for ${sculpture.title}: ${err.message}`);
                  }
                }
              }

              // Log static sculptures for clarity
              const staticSculptures = artworkInfo.filter(s => s.address && s.updateEveryBlock === 0);
              if (staticSculptures.length > 0) {
                console.log(`Skipping ${staticSculptures.length} static sculptures with updateEveryBlock: 0`);
                staticSculptures.forEach(s => console.log(` - ${s.title}`));
              }
            } catch (error) {
              console.error('Error in initial artwork fetch:', error);
            }

            // Generate the initial garden
            generateGarden();

            // Setup block listeners for updates using viem's watchBlocks
            let lastProcessedBlock = 0;

            // Create a block watcher
            blockWatcher = publicClient.watchBlocks({
              onBlock: (block) => {
                const blockNumber = Number(block.number);

                // Prevent multiple processing of the same block or out-of-order processing
                if (blockNumber > lastProcessedBlock) {
                  lastProcessedBlock = blockNumber;
                  console.log(`Processing new block: ${blockNumber}`);
                  onNewBlock(blockNumber);
                }
              },
              onError: (error) => {
                console.error('Error watching for blocks:', error);
              }
            });

            // No need to schedule wind effects - they're triggered by blocks now
            // Just hide loading screen and mark as initialized
            loadingEl.style.display = 'none';
            isInitialized = true;

            console.log('Garden visualization initialized');
          } catch (error) {
            console.error('Initialization error:', error);

            // Show static fallback garden without announcing the error
            setTimeout(() => {
              displayStaticGarden();
              loadingEl.style.display = 'none';
            }, 1000);
          }
        }

        // Fetch the current flower count from the contract using viem
        async function fetchFlowerCount() {
          try {
            // Read the flowers function from the garden contract with viem
            const result = await publicClient.readContract({
              address: GARDEN_CONTRACT_ADDRESS,
              abi: GARDEN_ABI,
              functionName: 'flowers'
            });

            // Convert BigInt to Number
            currentFlowerCount = Number(result);

            // Store the flower count in localStorage for future sessions
            localStorage.setItem('flowerCount', currentFlowerCount.toString());

            if (isDebugMode) {
              flowerCountEl.textContent = currentFlowerCount;
            }
            return currentFlowerCount;
          } catch (error) {
            console.error('Error fetching flower count:', error);
            return currentFlowerCount; // Return current count (from localStorage or default)
          }
        }

        // Track last update block for each artwork
        const lastUpdatedBlocks = {};

        // Flag to prevent multiple concurrent fetches
        let isFetchingArtworkInfo = false;

        // Fetch information about the artworks
        async function fetchArtworkInfo(currentBlock) {
          // Prevent concurrent fetches that could lead to 429 errors
          if (isFetchingArtworkInfo) {
            console.log('Already fetching artwork info, skipping');
            return;
          }

          // Must have a valid block number
          if (!currentBlock) {
            console.log('No block number provided, skipping artwork update');
            return;
          }

          try {
            isFetchingArtworkInfo = true;
            console.log(`Checking for artwork updates at block ${currentBlock}`);

            // Only proceed with dynamic sculptures that need updates
            const dynamicSculptures = artworkInfo.filter(s =>
              s.address && s.updateEveryBlock > 0
            );

            // If no dynamic sculptures, exit early
            if (dynamicSculptures.length === 0) {
              console.log('No dynamic sculptures configured for updates');
              return;
            }

            // With viem, we don't need to create contract instances -
            // we just need the address and ABI which we already have

            // Find artworks that need updates based on block frequency
            const artworksToUpdate = [];

            for (const sculpture of dynamicSculptures) {
              // Initialize last updated block if not set
              if (!lastUpdatedBlocks[sculpture.address]) {
                lastUpdatedBlocks[sculpture.address] = 0;
              }

              // Check if it's time to update this sculpture
              const blocksSinceLastUpdate = currentBlock - lastUpdatedBlocks[sculpture.address];
              if (blocksSinceLastUpdate >= sculpture.updateEveryBlock) {
                artworksToUpdate.push(sculpture);
                console.log(`Will update ${sculpture.title} (${blocksSinceLastUpdate} blocks since last update)`);
              }
            }

            // No updates needed? Exit early
            if (artworksToUpdate.length === 0) {
              console.log('No artworks need updating at this time');
              return;
            }

            // Update all needed artworks serially to avoid overwhelming the provider
            for (const sculpture of artworksToUpdate) {
              try {
                console.log(`Fetching data for ${sculpture.title}`);

                // Using viem's multicall to batch requests
                const [title, authors] = await publicClient.multicall({
                  contracts: [
                    // Title read
                    {
                      address: sculpture.address,
                      abi: SCULPTURE_ABI,
                      functionName: 'title',
                    },
                    // Authors read
                    {
                      address: sculpture.address,
                      abi: SCULPTURE_ABI,
                      functionName: 'authors',
                    }
                  ]
                });

                // Handle results, checking for errors
                if (title.status === 'success' && authors.status === 'success') {
                  // Record successful update time
                  lastUpdatedBlocks[sculpture.address] = currentBlock;

                  // Extract the values from the result
                  const titleValue = title.result;
                  const authorsValue = authors.result;

                  // Only update and log if values actually changed
                  if (sculpture.title !== titleValue || !arraysEqual(sculpture.authors, authorsValue)) {
                    console.log(`Data changed for "${titleValue}" by ${authorsValue.join(', ')}`);

                    // Update in-memory data
                    sculpture.title = titleValue;
                    sculpture.authors = authorsValue;

                    // Update DOM elements for this artwork
                    updateArtworkDOM(sculpture);
                  } else {
                    console.log(`No changes for ${sculpture.title}`);
                  }
                } else {
                  // Handle errors from multicall
                  let errorMessage = '';
                  if (title.status === 'failure') errorMessage += ` Title error: ${title.error?.message || 'unknown'}`;
                  if (authors.status === 'failure') errorMessage += ` Authors error: ${authors.error?.message || 'unknown'}`;
                  throw new Error(`Contract read failed: ${errorMessage}`);
                }
              } catch (err) {
                console.warn(`Error fetching info for ${sculpture.title} at ${sculpture.address}:`, err.message);
              }
            }
          } catch (error) {
            console.error('Error in fetchArtworkInfo:', error);
          } finally {
            isFetchingArtworkInfo = false;
          }
        }

        // Helper function to compare arrays
        function arraysEqual(a, b) {
          if (a === b) return true;
          if (a == null || b == null) return false;
          if (a.length !== b.length) return false;

          for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) return false;
          }
          return true;
        }

        // Function to update DOM elements when artwork info changes
        function updateArtworkDOM(artwork) {
          if (!artwork.address) return;

          console.log(`Updating DOM for artwork at address ${artwork.address}`);

          // Find the artwork info element
          const infoEl = document.querySelector(`.info-text[data-artwork-address="${artwork.address}"][data-element-type="artwork-info"]`);
          
          if (infoEl) {
            // Find the title and author elements within the info element
            const titleEl = infoEl.querySelector('.artwork-title');
            const authorEl = infoEl.querySelector('.artwork-author');
            
            // Update title if found
            if (titleEl) {
              console.log(`Found title element for ${artwork.address} - updating from "${titleEl.textContent}" to "${artwork.title}"`);
              titleEl.textContent = artwork.title;
            }
            
            // Update author if found
            if (authorEl) {
              const authorText = artwork.authors.join(', ');
              console.log(`Updating authors for ${artwork.address} from "${authorEl.textContent}" to "${authorText}"`);
              authorEl.textContent = authorText;
            }
          } else {
            console.warn(`Could not find info element for artwork at ${artwork.address}`);
            // If we can't find the element, regenerate the garden to ensure proper display
            generateGarden();
          }
        }

        // Generate the garden visualization
        function generateGarden() {
          gardenField.innerHTML = '';
          const grid = createEmptyGrid(config.gridWidth, config.gridHeight);

          // Place flowers based on noise algorithm
          const flowersToDisplay = Math.min(currentFlowerCount, 10000); // Limit for performance
          const flowerPositions = placeFlowersUsingNoise(grid, flowersToDisplay);

          // Create flower elements
          flowerPositions.forEach((pos, i) => {
            const flowerEl = createFlowerElement(pos.x, pos.y);
            gardenField.appendChild(flowerEl);

            // Make initial flowers visible immediately
            flowerEl.classList.add('visible');
          });

          // Wind marker is currently disabled
          // const windMarkerPosition = placeWindMarker(grid);

          // Place artwork info text
          if (artworkInfo.length > 0) {
            placeInfoText();
          }

          displayedFlowers = flowersToDisplay;
        }

        // Place wind marker using noise algorithm
        function placeWindMarker(grid) {
          // Use a different seed for wind marker placement to ensure uniqueness
          const fixedSeed = 67890;
          const random = createSeededRandom(fixedSeed);

          // Find a suitable position that doesn't overlap with flowers
          let attempts = 0;
          const maxAttempts = 100;

          while (attempts < maxAttempts) {
            attempts++;

            // Generate position proposals with a preference for center area visibility
            const x = Math.floor(config.gridWidth * (0.3 + random() * 0.4)); // 30-70% of width
            const y = Math.floor(config.gridHeight * (0.3 + random() * 0.4)); // 30-70% of height

            // Check if position is available (not occupied by flower)
            if (grid[y][x] === ' ') {
              // Create the marker
              const marker = document.createElement('div');
              marker.className = 'wind-marker';
              marker.id = 'wind-marker';
              marker.textContent = '↑'; // Default direction
              marker.style.left = `${x * 1.0}em`;
              marker.style.top = `${y * 1.2}em`;
              marker.dataset.x = x;
              marker.dataset.y = y;

              // Add to garden
              gardenField.appendChild(marker);

              // Mark position as used in grid
              grid[y][x] = 'W'; // W for wind marker

              return { x, y };
            }
          }

          // Fallback - if all positions are occupied, place at a fixed position
          const x = Math.floor(config.gridWidth * 0.5);
          const y = Math.floor(config.gridHeight * 0.2);

          const marker = document.createElement('div');
          marker.className = 'wind-marker';
          marker.id = 'wind-marker';
          marker.textContent = '↑';
          marker.style.left = `${x * 1.0}em`;
          marker.style.top = `${y * 1.2}em`;
          marker.dataset.x = x;
          marker.dataset.y = y;

          gardenField.appendChild(marker);
          return { x, y };
        }

        // Create an empty grid
        function createEmptyGrid(width, height) {
          const grid = [];
          for (let y = 0; y < height; y++) {
            const row = [];
            for (let x = 0; x < width; x++) {
              row.push(' ');
            }
            grid.push(row);
          }
          return grid;
        }

        // Create a seeded pseudo-random number generator
        function createSeededRandom(seed) {
          return function() {
            seed = (seed * 16807) % 2147483647;
            return (seed - 1) / 2147483646;
          };
        }

        // Place flowers using deterministic noise algorithm (based on GardenContributions.sol)
        function placeFlowersUsingNoise(grid, count) {
          // Always use the same fixed seed for the initial garden
          // But use a separate random generator for positions (not affected by seed)
          const fixedSeed = 12345;
          const initialRandom = createSeededRandom(fixedSeed);

          // For individual flower placements, use position-independent randomness
          const positionRandom = Math.random;

          const positions = [];
          let placed = 0;
          let attempts = 0;
          const maxAttempts = count * 100; // Plenty of attempts

          // Ensure even distribution - divide screen into sections
          const numSections = 4; // Divide screen into quarters
          const sectionHeight = config.gridHeight / numSections;

          console.log(`Attempting to place ${count} flowers...`);

          // Try to place all flowers
          while (placed < count && attempts < maxAttempts) {
            attempts++;

            // Choose a random section (weighted toward bottom)
            const sectionIndex = Math.floor(positionRandom() * numSections);

            // Get position within that section
            const sectionStartY = Math.floor(sectionIndex * sectionHeight);
            const sectionEndY = Math.floor(Math.min(config.gridHeight, (sectionIndex + 1) * sectionHeight));

            const x = Math.floor(positionRandom() * config.gridWidth);
            const y = sectionStartY + Math.floor(positionRandom() * (sectionEndY - sectionStartY));

            // For this grid cell, calculate a noise value
            const noiseVal = gridNoise(x, y, 0xf);

            // Use a fixed threshold that ensures we get enough flowers
            const threshold = 0.3;

            // Only place if position is valid according to noise and grid
            if (Math.abs(noiseVal) > threshold && grid[y][x] === ' ') {
              // Place flower in grid
              grid[y][x] = '⚘';
              positions.push({ x, y });
              placed++;
            }
          }

          console.log(`Placed ${placed} flowers out of ${count} requested`);
          return positions;
        }

        // Create a flower element at specific coordinates
        function createFlowerElement(x, y) {
          const flower = document.createElement('div');
          flower.className = 'flower';
          flower.textContent = '⚘';
          flower.style.left = `${x * 1.0}em`;
          flower.style.top = `${y * 1.2}em`;
          flower.dataset.x = x;
          flower.dataset.y = y;
          flower.dataset.baseX = x * 1.0;
          flower.dataset.baseY = y * 1.2;
          flower.dataset.animating = ""; // Initialize animation state

          // Prevent potential rendering issues for animation
          flower.style.willChange = 'left, top'; // Hint to browser about properties that will change
          flower.style.backfaceVisibility = 'hidden'; // Prevent flickering in some browsers

          return flower;
        }

        // Place text elements with artwork information
        function placeInfoText() {
          // Use same seeded random generator for consistent text placement
          const random = createSeededRandom(789018); // Different seed from flower placement

          // Create an array of grid positions that match where flowers could be placed
          // We'll place text at these grid positions to ensure alignment
          const gridPositions = [];

          // Generate grid positions (essentially the same as the flower placement logic)
          for (let y = 0; y < config.gridHeight; y++) {
            for (let x = 0; x < config.gridWidth; x++) {
              gridPositions.push({ x, y });
            }
          }

          // Shuffle the positions using our deterministic random
          for (let i = gridPositions.length - 1; i > 0; i--) {
            const j = Math.floor(random() * (i + 1));
            [gridPositions[i], gridPositions[j]] = [gridPositions[j], gridPositions[i]];
          }

          // Keep track of used positions to avoid overlap
          const usedPositions = new Set();

          // Function to find an available position for text
          function findAvailablePosition(length, startIdx) {
            // Find a position that has enough space for the text
            for (let i = startIdx; i < gridPositions.length; i++) {
              const pos = gridPositions[i];

              // Check if this position and needed length is available
              let available = true;
              for (let j = 0; j < length; j++) {
                const checkPos = `${pos.x + j},${pos.y}`;
                if (usedPositions.has(checkPos) || (pos.x + j) >= config.gridWidth) {
                  available = false;
                  break;
                }
              }

              // If we found an available spot, mark it as used
              if (available) {
                for (let j = 0; j < length; j++) {
                  usedPositions.add(`${pos.x + j},${pos.y}`);
                }
                return pos;
              }
            }

            // If no position is found, return a fallback position
            // Use a fixed fallback position that doesn't reference undefined variables
            return { x: 5, y: 5 };
          }

          // Start index for art placements
          let posIndex = 100; // Skip some of the first positions to make room for flowers

          artworkInfo.forEach((artwork, index) => {
            // Find the maximum length between author and title for position
            const maxLength = Math.max(
              artwork.title.length,
              ...artwork.authors.map(author => author.length)
            );
            
            // Place combined info element in grid
            const infoPos = findAvailablePosition(maxLength, posIndex);
            posIndex += 50; // Move forward to space out the artworks

            const infoEl = document.createElement('div');
            infoEl.className = 'info-text';
            infoEl.style.left = `${infoPos.x * 1.0}em`;
            infoEl.style.top = `${infoPos.y * 1.2}em`;
            
            // Add data attributes to track artwork elements by address
            if (artwork.address) {
              infoEl.dataset.artworkAddress = artwork.address;
              infoEl.dataset.elementType = 'artwork-info';
            }
            
            // Create author element inside the info element
            const authorText = artwork.authors.join(', ');
            const authorEl = document.createElement('div');
            authorEl.className = 'artwork-author';
            authorEl.textContent = authorText;
            infoEl.appendChild(authorEl);
            
            // Create title element inside the info element
            const titleEl = document.createElement('div');
            titleEl.className = 'artwork-title';
            titleEl.textContent = artwork.title;
            infoEl.appendChild(titleEl);
            
            // Add to garden field
            gardenField.appendChild(infoEl);
            
            // Make text element visible immediately
            infoEl.classList.add('visible');

            // Extract position from style (remove 'em' and convert to number)
            const posX = parseInt(infoEl.style.left.replace('em', ''));
            const posY = parseInt(infoEl.style.top.replace('em', '')) / 1.2;

            // Store initial position for wandering
            infoEl.dataset.baseX = posX;
            infoEl.dataset.baseY = posY;
            infoEl.dataset.currentX = posX;
            infoEl.dataset.currentY = posY;
            
            // Save inner elements for data updating
            infoEl.dataset.titleEl = 'artwork-title';
            infoEl.dataset.authorEl = 'artwork-author';
          });
        }

        // Function to add new flowers to the garden
        function addNewFlowers(count = 1) {
          // Update flower count
          const previousCount = currentFlowerCount;
          currentFlowerCount += count;

          // Update localStorage to persist this change
          localStorage.setItem('flowerCount', currentFlowerCount.toString());

          // Update debug display if visible
          if (isDebugMode) {
            flowerCountEl.textContent = currentFlowerCount;
          }

          // Create grid and add new flowers
          const grid = createEmptyGrid(config.gridWidth, config.gridHeight);

          // Mark existing flowers in grid
          const existingFlowers = document.querySelectorAll('.flower.visible');
          existingFlowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            if (x >= 0 && y >= 0 && y < grid.length && x < grid[y].length) {
              grid[y][x] = '⚘';
            }
          });

          // Add new flowers
          console.log(`Attempting to place ${count} new flowers...`);
          const newPositions = placeFlowersUsingNoise(grid, count);
          console.log(`Found ${newPositions.length} positions for new flowers`);

          // Create and add new flower elements
          newPositions.forEach(pos => {
            console.log(`Placing flower at (${pos.x}, ${pos.y})`);
            const flowerEl = createFlowerElement(pos.x, pos.y);
            gardenField.appendChild(flowerEl);

            // Make new flowers fade in gradually
            // The flower class already has a transition: opacity 5s ease-in-out
            // So we just need to add the 'visible' class
            setTimeout(() => {
              flowerEl.classList.add('visible');
              
              // Create a circular wave emanating from the new flower
              createCircularWave(pos.x, pos.y);
            }, 10); // Small timeout to ensure transition works properly
          });

          displayedFlowers = currentFlowerCount;

          console.log(`Added ${count} flower(s). New count: ${currentFlowerCount}`);
          return count;
        }

        // Update garden when new flowers are detected
        async function updateGarden(newFlowerCount) {
          if (newFlowerCount <= displayedFlowers) return;

          const additionalFlowers = newFlowerCount - displayedFlowers;

          // Use the addNewFlowers function to add the additional flowers
          addNewFlowers(additionalFlowers);
        }

        // Track block-triggered events
        let lastTextMovementBlock = 0;

        // Handle new blocks from the blockchain
        async function onNewBlock(blockNumber) {
          if (!isInitialized) return;

          if (isDebugMode) {
            currentBlockEl.textContent = blockNumber;
          }

          // Always fetch flower count on every block
          const newFlowerCount = await fetchFlowerCount();

          console.log(`new flower count ${newFlowerCount} (old: ${currentFlowerCount})`)

          // Only check for artwork updates that need updating
          // First, determine if any artwork needs updating at this block number
          let needsArtworkUpdate = false;

          for (const sculpture of artworkInfo) {
            // Skip artworks with no address or updateEveryBlock = 0
            if (!sculpture.address || sculpture.updateEveryBlock <= 0) continue;

            // Initialize last update block if not set
            if (!lastUpdatedBlocks[sculpture.address]) {
              lastUpdatedBlocks[sculpture.address] = 0;
            }

            // Check if it's time to update this sculpture
            const blocksSinceLastUpdate = blockNumber - lastUpdatedBlocks[sculpture.address];
            if (blocksSinceLastUpdate >= sculpture.updateEveryBlock) {
              needsArtworkUpdate = true;
              console.log(`Artwork ${sculpture.title} needs update at block ${blockNumber}`);
              break; // No need to check more if at least one needs update
            }
          }

          // Only fetch artwork info if at least one artwork needs updating
          if (needsArtworkUpdate) {
            await fetchArtworkInfo(blockNumber);
          }

          // Add new flowers if needed
          if (newFlowerCount > currentFlowerCount) {
            console.log(`New flowers detected: ${newFlowerCount - currentFlowerCount}`);
            currentFlowerCount = newFlowerCount;
            updateGarden(newFlowerCount);
          }

          // Trigger a wind effect on each new block
          triggerWindOnBlock(blockNumber);

          // Move text elements every 5 blocks
          if (blockNumber - lastTextMovementBlock >= 5) {
            if (config.wanderingTextEnabled) {
              wanderingTextElements();
              lastTextMovementBlock = blockNumber;
              console.log(`Moving text elements at block ${blockNumber}`);
            }
          }
        }

        // Trigger wind effect based on block number
        function triggerWindOnBlock(blockNumber) {
          // Use block number as seed for deterministic wind direction
          const directions = [
            'left', 'right', 'up', 'down',
            'diagonal-up-right', 'diagonal-up-left',
            'diagonal-down-right', 'diagonal-down-left'
          ];

          // Use modulo to select a direction based on block number
          const dirIndex = blockNumber % directions.length;
          const direction = directions[dirIndex];

          console.log(`Block ${blockNumber}: Triggering wind effect (${direction})`);

          // Apply the wind effect with strength based on block hash last digit
          // For simplicity, we use a fixed moderate strength
          applyWindEffect(direction, config.windStrength);
        }

        // Apply wave-like ripple effect across the garden
        function applyWindEffect(direction, windStrength) {
          if (isDebugMode) {
            windEffectEl.textContent = direction;
          }

          // Wind marker is disabled for now
          // updateWindMarkerDirection(direction);

          // Get all visible flowers and organize them by position
          const flowers = Array.from(document.querySelectorAll('.flower.visible'));
          const flowerMap = {};

          // Create a map of flowers by their position for quick lookup
          flowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            flowerMap[`${x},${y}`] = flower;
          });

          // Get grid boundaries
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          flowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          });

          // Direction vectors for the flower movement and wave direction
          let dx = 0, dy = 0;
          let waveDirection = 'horizontal'; // Default to horizontal
          let waveStartX = 0, waveStartY = 0;
          let waveDx = 0, waveDy = 0; // Wave direction vector

          switch (direction) {
            case 'left':
              dx = -1;
              waveDirection = 'horizontal';
              waveStartX = config.gridWidth - 1; // Start from right edge
              waveStartY = 0;
              waveDx = -1; waveDy = 0; // Wave moves left
              break;
            case 'right':
              dx = 1;
              waveDirection = 'horizontal';
              waveStartX = 0; // Start from left edge
              waveStartY = 0;
              waveDx = 1; waveDy = 0; // Wave moves right
              break;
            case 'up':
              dy = -1;
              waveDirection = 'vertical';
              waveStartX = 0;
              waveStartY = config.gridHeight - 1; // Start from bottom edge
              waveDx = 0; waveDy = -1; // Wave moves up
              break;
            case 'down':
              dy = 1;
              waveDirection = 'vertical';
              waveStartX = 0;
              waveStartY = 0; // Start from top edge
              waveDx = 0; waveDy = 1; // Wave moves down
              break;
            case 'diagonal-up-right':
              dx = 1; dy = -1;
              waveDirection = 'diagonal';
              waveStartX = 0; // Start from bottom-left
              waveStartY = config.gridHeight - 1;
              waveDx = 1; waveDy = -1; // Wave moves up-right
              break;
            case 'diagonal-up-left':
              dx = -1; dy = -1;
              waveDirection = 'diagonal';
              waveStartX = config.gridWidth - 1; // Start from bottom-right
              waveStartY = config.gridHeight - 1;
              waveDx = -1; waveDy = -1; // Wave moves up-left
              break;
            case 'diagonal-down-right':
              dx = 1; dy = 1;
              waveDirection = 'diagonal';
              waveStartX = 0; // Start from top-left
              waveStartY = 0;
              waveDx = 1; waveDy = 1; // Wave moves down-right
              break;
            case 'diagonal-down-left':
              dx = -1; dy = 1;
              waveDirection = 'diagonal';
              waveStartX = config.gridWidth - 1; // Start from top-right
              waveStartY = 0;
              waveDx = -1; waveDy = 1; // Wave moves down-left
              break;
          }

          // Wave animation parameters - defined globally so they can be used in timeout calculations
          const waveWidth = 4; // How many cells wide the wave is
          const waveFrameInterval = 33; // ms between wave animation frames
          // Store in window for access from other functions
          window.currentWaveFrameInterval = waveFrameInterval;

          // Calculate wave distance based on direction
          let waveDistance;
          if (waveDirection === 'diagonal') {
            // For diagonal, calculate the exact diagonal distance across the grid
            // Using Pythagorean theorem for the diagonal distance from one corner to the other
            waveDistance = Math.ceil(Math.sqrt(
              Math.pow(config.gridWidth, 2) +
              Math.pow(config.gridHeight, 2)
            )) + 20; // Add extra distance to ensure it goes all the way
          } else if (waveDirection === 'horizontal') {
            waveDistance = config.gridWidth + 10; // Add extra to ensure full coverage
          } else { // vertical
            waveDistance = config.gridHeight + 10; // Add extra to ensure full coverage
          }

          // Calculate total wave duration based on distance and frame interval
          // This ensures waves complete their full journey regardless of grid size
          const waveTotalDuration = waveDistance * waveFrameInterval;

          // Animate the wave passing through the garden
          let waveProgress = 0;
          const waveTimer = setInterval(() => {
            // Increment wave position
            waveProgress++;

            if (waveProgress > waveDistance) {
              clearInterval(waveTimer);
              resetWindEffect();
              return;
            }

            // Calculate which flowers are affected by the current wave position
            // Check all grid positions
            for (let y = 0; y < config.gridHeight; y++) {
              for (let x = 0; x < config.gridWidth; x++) {
                let isInWave = false;

                if (waveDirection === 'horizontal') {
                  // For horizontal waves
                  const wavePos = waveStartX + (waveDx * waveProgress);
                  isInWave = Math.abs(x - wavePos) <= waveWidth;
                }
                else if (waveDirection === 'vertical') {
                  // For vertical waves
                  const wavePos = waveStartY + (waveDy * waveProgress);
                  isInWave = Math.abs(y - wavePos) <= waveWidth;
                }
                else if (waveDirection === 'diagonal') {
                  // For diagonal waves, we need a different approach
                  // Project the point onto the wave path to see if it's within the current wave front

                  // Wave path is defined by the start point and the direction
                  // Calculate current wave position along the diagonal
                  const waveX = waveStartX + (waveDx * waveProgress);
                  const waveY = waveStartY + (waveDy * waveProgress);

                  // Calculate the distance along the wave path (dot product)
                  // This gives us how far along the path this point would be
                  const dx2 = x - waveStartX;
                  const dy2 = y - waveStartY;

                  // Project the point onto the wave direction vector
                  // This is effectively dot(point - waveStart, waveDir) / |waveDir|
                  // Since waveDir is normalized (-1, 0, or 1), we can simplify
                  const projectionOnWavePath = dx2 * waveDx + dy2 * waveDy;

                  // Check if this point is close to the current wave progress along the path
                  const distanceFromWaveFront = Math.abs(projectionOnWavePath - waveProgress);

                  // The wave should be narrow in the direction of movement but wide perpendicular to it
                  // Calculate perpendicular distance (distance to the diagonal line)
                  // For a line with direction (dx,dy), the perpendicular is (-dy,dx)
                  const perpendicular = Math.abs(dx2 * (-waveDy) + dy2 * waveDx);

                  // A point is in the wave if:
                  // 1. It's close to the current wave front (within waveWidth in the direction of travel)
                  // 2. It's close to the diagonal path (within a wider range perpendicular to travel)

                  // Use the full grid diagonal as the perpendicular width
                  const gridDiagonal = Math.sqrt(Math.pow(config.gridWidth, 2) + Math.pow(config.gridHeight, 2));
                  // Set the perpendicular width to the full grid diagonal for maximum coverage
                  const diagonalPerpWidth = gridDiagonal;

                  isInWave = (distanceFromWaveFront <= waveWidth * 1.5) && (perpendicular <= diagonalPerpWidth);
                }

                // If this position is in the wave and has a flower, animate it
                if (isInWave) {
                  const flower = flowerMap[`${x},${y}`];
                  if (flower) {
                    // Move the flower by adjusting its position
                    const origLeft = parseFloat(flower.dataset.baseX);
                    const origTop = parseFloat(flower.dataset.baseY);

                    // Check if this flower is already being animated
                    if (!flower.dataset.animating) {
                      // Mark as animating to prevent overlapping animations
                      flower.dataset.animating = "true";
                      
                      // Calculate distance from wave front for intensity scaling
                      let distanceFromStart;
                      if (waveDirection === 'horizontal') {
                        distanceFromStart = Math.abs(waveStartX - x);
                      } else if (waveDirection === 'vertical') {
                        distanceFromStart = Math.abs(waveStartY - y);
                      } else { // diagonal
                        // For diagonal, use Manhattan distance from starting point
                        distanceFromStart = Math.abs(waveStartX - x) + Math.abs(waveStartY - y);
                      }
                      
                      // Normalize distance to range [0,1] based on grid dimensions
                      const maxPossibleDistance = config.gridWidth + config.gridHeight;
                      const normalizedDistance = Math.min(1, distanceFromStart / maxPossibleDistance);
                      
                      // Calculate diminishing factor (starts at 1.0, goes down to 0.3)
                      // This ensures we never drop below 30% of the original strength
                      const minStrengthFactor = 0.3;
                      const strengthFactor = 1 - ((1 - minStrengthFactor) * normalizedDistance);
                      
                      // Apply the movement with distance-based intensity
                      flower.style.left = `${origLeft + (dx * windStrength * strengthFactor)}em`;
                      flower.style.top = `${origTop + (dy * windStrength * strengthFactor)}em`;

                      // Reset flower position after a brief time
                      setTimeout(() => {
                        // Return to original position with transition
                        flower.style.left = `${origLeft}em`;
                        flower.style.top = `${origTop}em`;

                        // After the transition completes, remove the animating flag
                        setTimeout(() => {
                          flower.dataset.animating = "";
                        }, 300); // Slightly longer than the transition time
                      }, waveWidth * waveFrameInterval); // Use fixed value of 100ms here
                    }
                  }
                }
              }
            }
          }, waveFrameInterval);

          // Calculate how long it should take for the wave to complete
          // We'll clear the wave timer once it completes its journey
          const waveTimeout = waveTotalDuration + 500; // Add a small buffer

          // Only schedule one timeout to clear the timer and reset wind effect
          setTimeout(() => {
            if (waveTimer) {
              clearInterval(waveTimer);
              // Don't call resetWindEffect here as each flower resets itself
            }
          }, waveTimeout);
        }

        // Reset wind effect (return to normal position)
        function resetWindEffect() {
          if (isDebugMode) {
            windEffectEl.textContent = 'None';
          }

          // Reset all flowers to their original positions
          const flowers = document.querySelectorAll('.flower.visible');
          flowers.forEach(flower => {
            const origLeft = parseFloat(flower.dataset.baseX);
            const origTop = parseFloat(flower.dataset.baseY);
            flower.style.left = `${origLeft}em`;
            flower.style.top = `${origTop}em`;
          });
        }

        // Update the wind marker to show the current wind direction
        function updateWindMarkerDirection(direction) {
          const windMarker = document.getElementById('wind-marker');
          if (!windMarker) return;

          // Map wind directions to arrow characters
          const directionArrows = {
            'left': '←',
            'right': '→',
            'up': '↑',
            'down': '↓',
            'diagonal-up-right': '↗',
            'diagonal-up-left': '↖',
            'diagonal-down-right': '↘',
            'diagonal-down-left': '↙'
          };

          // Update the arrow character
          if (directionArrows[direction]) {
            windMarker.textContent = directionArrows[direction];
          }
        }
        
        // Create a circular wave effect emanating from a specific point
        function createCircularWave(centerX, centerY) {
          // Get all visible flowers to animate
          const flowers = Array.from(document.querySelectorAll('.flower.visible'));
          
          // Create a map of flowers for quick lookup
          const flowerMap = {};
          flowers.forEach(flower => {
            const x = parseInt(flower.dataset.x, 10);
            const y = parseInt(flower.dataset.y, 10);
            flowerMap[`${x},${y}`] = flower;
          });
          
          // Wave animation parameters
          const maxRadius = 500; // Maximum radius of the wave (in grid cells)
          const waveWidth = 2; // Width of the wave (in grid cells)
          const waveSpeed = 33; // Speed of the wave propagation (ms per cell)
          const animationDuration = 200; // How long each flower animates (ms)
          
          // Function to calculate distance between two points
          function distanceToCenter(x, y) {
            return Math.sqrt(
              Math.pow(x - centerX, 2) + 
              Math.pow(y - centerY, 2)
            );
          }
          
          // Function to apply wave effect to flowers at a specific radius
          function animateWaveAtRadius(radius) {
            // Find grid positions at current wave radius
            for (let y = Math.max(0, centerY - radius - waveWidth); y <= Math.min(config.gridHeight - 1, centerY + radius + waveWidth); y++) {
              for (let x = Math.max(0, centerX - radius - waveWidth); x <= Math.min(config.gridWidth - 1, centerX + radius + waveWidth); x++) {
                // Calculate distance from this position to center
                const distance = distanceToCenter(x, y);
                
                // Check if this position is within the current wave front
                if (Math.abs(distance - radius) <= waveWidth) {
                  // Get the flower at this position
                  const flower = flowerMap[`${x},${y}`];
                  if (flower && !flower.dataset.animating) {
                    // Mark as animating to prevent overlapping animations
                    flower.dataset.animating = "true";
                    
                    // Calculate displacement direction (away from center)
                    const dx = (x - centerX) === 0 ? 0 : (x - centerX) / Math.abs(x - centerX);
                    const dy = (y - centerY) === 0 ? 0 : (y - centerY) / Math.abs(y - centerY);
                    
                    // Scale by distance from center for more natural effect
                    const distanceFactor = Math.min(1, 1 / Math.max(0.5, distance / 5));
                    
                    // Apply the transformation
                    const baseX = parseFloat(flower.dataset.baseX);
                    const baseY = parseFloat(flower.dataset.baseY);
                    
                    // Move slightly outward from center
                    flower.style.left = `${baseX + dx * 1.0 * distanceFactor}em`;
                    flower.style.top = `${baseY + dy * 1.2 * distanceFactor}em`;
                    
                    // Reset position after animation completes
                    setTimeout(() => {
                      flower.style.left = `${baseX}em`;
                      flower.style.top = `${baseY}em`;
                      
                      // Remove animating flag once animation is complete
                      setTimeout(() => {
                        flower.dataset.animating = "";
                      }, 300);
                    }, animationDuration);
                  }
                }
              }
            }
          }
          
          // Animate the expanding wave
          let currentRadius = 1;
          const waveInterval = setInterval(() => {
            animateWaveAtRadius(currentRadius);
            currentRadius++;
            
            // Stop the animation when the wave reaches max radius
            if (currentRadius > maxRadius) {
              clearInterval(waveInterval);
            }
          }, waveSpeed);
        }

        // Wind effects are now triggered by blockchain events instead of on a schedule

        // Create a static garden as fallback for network issues
        function displayStaticGarden() {
          // Use the currentFlowerCount which is already initialized from localStorage or default
          // No need to set a static count - we're using what we have

          // Add static artwork info
          generateGarden();
          isInitialized = true;

          // In static mode (offline), trigger an initial wind effect
          triggerWindOnBlock(Math.floor(Math.random() * 1000));
        }

        // Grid noise function from GardenContributions.sol
        function gridNoise(x, y, seed) {
          // Converting the noise algorithm to JavaScript
          let n = (1619 * x + 31337 * y + 1013 * seed) & 0x7fffffff;
          n = ((n >> 13) ^ n);

          // Use BigInt for large number calculations
          let bigN = BigInt(n);
          bigN = bigN * (bigN * BigInt(60493) + BigInt(19990303)) + BigInt(1376312589);

          // Convert to binary and slice the last 31 bits
          const binaryStr = bigN.toString(2);
          const last31Bits = binaryStr.slice(-31);

          // Convert back to decimal and normalize to the range [-1, 1]
          n = parseInt(last31Bits, 2);
          return 1 - n / 1073741824;
        }

        // Calculate threshold based on GardenContributions.sol algorithm
        function calculateThreshold(planted) {
          const min = 30, max = 10000;
          const lower = 0.99, higher = 0.8;

          if (planted <= min) return lower;
          if (planted >= max) return higher;

          const normalized = (planted - min) / (max - min);
          const logValue = Math.log10(1 + normalized * (10 - 1));

          return higher + (lower - higher) * (1 - logValue);
        }

        // Track which element should move next
        let lastMovedElementIndex = -1;

        // Function to make text elements wander around the grid - one at a time
        function wanderingTextElements() {
          // Get all visible text elements
          const textElements = Array.from(document.querySelectorAll('.info-text.visible'));
          
          // If no elements to move, exit early
          if (textElements.length === 0) return;
          
          // Function to get element dimensions
          function getElementDimensions(el) {
            // Get the width based on the longest child element
            let maxWidth = 0;
            let height = 0;
            
            // Iterate through child elements to find the longest one
            Array.from(el.children).forEach(child => {
              maxWidth = Math.max(maxWidth, child.textContent.length);
              height++; // Count each child as one row
            });
            
            // If no children, use the element's own text length
            if (height === 0) {
              maxWidth = el.textContent.length;
              height = 1;
            }
            
            return { width: maxWidth, height: height };
          }
          
          // Function to check if a position is occupied by any text element
          // Accounts for the full dimensions of text elements (width and height)
          function isPositionOccupied(x, y, width, height, currentElement) {
            for (const el of textElements) {
              // Skip if this is the element we're checking for
              if (el === currentElement) continue;

              // Skip if element doesn't have position data
              if (!el.dataset.currentX || !el.dataset.currentY) continue;

              const elX = parseInt(el.dataset.currentX, 10);
              const elY = parseInt(el.dataset.currentY, 10);
              const { width: elWidth, height: elHeight } = getElementDimensions(el);

              // Check for overlap in both dimensions
              // Two boxes overlap if:
              // 1. One box's left edge is to the left of the other's right edge, AND
              // 2. One box's right edge is to the right of the other's left edge, AND
              // 3. One box's top edge is above the other's bottom edge, AND
              // 4. One box's bottom edge is below the other's top edge
              const horizontalOverlap = 
                x < (elX + elWidth) && (x + width) > elX;
              const verticalOverlap = 
                y < (elY + elHeight) && (y + height) > elY;

              if (horizontalOverlap && verticalOverlap) {
                return el; // Return the element occupying this position
              }
            }
            return null; // Position is not occupied
          }

          // Function to check if a new position would cause collision
          function checkCollision(element, newX, newY) {
            const { width, height } = getElementDimensions(element);
            return isPositionOccupied(newX, newY, width, height, element);
          }

          // Move to the next element
          lastMovedElementIndex = (lastMovedElementIndex + 1) % textElements.length;
          
          // Get the element to move
          const el = textElements[lastMovedElementIndex];
          
          // Skip if element doesn't have position data
          if (!el.dataset.currentX || !el.dataset.currentY) return;

          // Get the first 20 chars of any text for logging
          const debugText = el.textContent.replace(/\s+/g, ' ').substring(0, 20);
          console.log(`Moving text element ${lastMovedElementIndex}: "${debugText}${debugText.length > 20 ? '...' : ''}"`);
          
          const currentX = parseInt(el.dataset.currentX, 10);
          const currentY = parseInt(el.dataset.currentY, 10);
          const { width, height } = getElementDimensions(el);

          // Randomly choose a direction to move (-1, 0, or 1 for both x and y)
          const directions = [-1, 0, 1];
          const dx = directions[Math.floor(Math.random() * 3)];
          const dy = directions[Math.floor(Math.random() * 3)];

          // Calculate new position
          let newX = currentX + dx;
          let newY = currentY + dy;

          // Ensure we stay within grid boundaries
          newX = Math.max(0, Math.min(config.gridWidth - width, newX));
          newY = Math.max(0, Math.min(config.gridHeight - height, newY));

          // Check for collisions at the new position
          const collidingElement = checkCollision(el, newX, newY);

          if (collidingElement) {
            // Handle collision - move the colliding element down
            const collidingY = parseInt(collidingElement.dataset.currentY, 10) + 1;
            const collidingDimensions = getElementDimensions(collidingElement);
            
            // Make sure we don't go off the bottom of the screen
            const safeY = Math.min(config.gridHeight - collidingDimensions.height, collidingY);

            // Update position of colliding element
            collidingElement.style.top = `${safeY * 1.2}em`;
            collidingElement.dataset.currentY = safeY;
          }

          // Update element position without transition (immediate jump)
          el.style.left = `${newX * 1.0}em`;
          el.style.top = `${newY * 1.2}em`;

          // Update dataset values
          el.dataset.currentX = newX;
          el.dataset.currentY = newY;
        }

        // Text wandering is now block-based instead of time-based

        // Toggle wandering text based on config
        function toggleWanderingText() {
          config.wanderingTextEnabled = !config.wanderingTextEnabled;

          // Update debug panel if it's visible
          const wanderingStateEl = document.getElementById('wandering-state');
          if (wanderingStateEl) {
            wanderingStateEl.textContent = config.wanderingTextEnabled ? 'On' : 'Off';
          }

          console.log(`Text wandering ${config.wanderingTextEnabled ? 'enabled' : 'disabled'}`);
          return config.wanderingTextEnabled;
        }

        // Start the application
        init();
      }
    </script>
  </body>
</html>